This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
architecture.md
docs/plugin_system.md
docs/unique_features.md
migration_analysis.md
README.md
requirements.md
src/core/application.py
src/core/bookmarks.py
src/core/content_security.py
src/core/cookies.py
src/core/downloads.py
src/core/history.py
src/core/security_integration.py
src/core/security.py
src/core/settings.py
src/core/tab_manager.py
src/core/web_engine.py
src/main.py
src/plugins/__init__.py
src/plugins/hook_registry.py
src/plugins/my_toolbar_button_plugin/__init__.py
src/plugins/my_toolbar_button_plugin/manifest.json
src/plugins/plugin_api.py
src/plugins/plugin_base.py
src/plugins/plugin_loader.py
src/plugins/plugin_manager.py
src/plugins/quick_search_plugin/__init__.py
src/plugins/quick_search_plugin/manifest.json
src/plugins/README.md
src/plugins/sample_plugins/__init__.py
src/plugins/sample_plugins/create_icon.py
src/plugins/sample_plugins/generate_icon.py
src/plugins/sample_plugins/manifest.json
src/plugins/sandbox.py
src/themes/default_themes.py
src/themes/theme_loader.py
src/themes/theme_manager.py
src/ui/address_bar.py
src/ui/bookmarks_dialog.py
src/ui/browser_tabs.py
src/ui/downloads_dialog.py
src/ui/history_dialog.py
src/ui/main_window.py
src/ui/plugin_dialog.py
src/ui/settings_dialog.py
src/ui/status_bar.py
src/ui/toolbar.py
src/utils/file_utils.py
src/utils/logger.py
src/utils/url_utils.py
tests/test_browser.py
tests/test_plugin_system.py
tests/test_theming_system.py
todo.md
unique_features.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="architecture.md">
# NebulaFusion Browser Architecture

## Overview

NebulaFusion is designed with a modular, extensible architecture that enables a powerful plugin system while maintaining security and performance. The architecture follows a layered approach with clear separation of concerns.

## Core Components

### 1. Application Layer
- **MainWindow**: Central application window managing the overall UI
- **ApplicationController**: Manages application lifecycle and coordinates between components
- **SettingsManager**: Handles configuration and persistent settings
- **ThemeManager**: Controls UI theming and appearance

### 2. Browser Engine Layer
- **WebEngineManager**: Wrapper around QWebEngine functionality
- **TabManager**: Handles tab creation, deletion, and switching
- **NavigationController**: Manages navigation actions (back, forward, reload)
- **HistoryManager**: Tracks and manages browsing history
- **BookmarkManager**: Handles bookmark storage and organization
- **CookieManager**: Manages cookie storage and permissions
- **DownloadManager**: Handles file downloads and management

### 3. Plugin System Layer
- **PluginLoader**: Dynamically loads and initializes plugins
- **PluginManager**: Manages plugin lifecycle and configuration
- **HookRegistry**: Registers and dispatches plugin hooks
- **PluginAPI**: Provides interfaces for plugins to interact with browser components
- **PluginSandbox**: Enforces security boundaries for plugin execution

### 4. UI Layer
- **BrowserUI**: Main browser interface components
- **TabView**: UI for displaying and managing tabs
- **AddressBar**: URL input and display
- **NavigationBar**: Navigation controls (back, forward, etc.)
- **StatusBar**: Status information display
- **SidePanel**: Expandable panel for additional features
- **ContextMenus**: Right-click menus throughout the application

### 5. Unique Features Layer
- **RealityAugmentation**: Handles camera integration and AR features
- **CollaborativeBrowsing**: Manages shared browsing sessions
- **ContentTransformation**: Transforms webpage content between formats
- **TimeTravel**: Manages webpage snapshots and version comparison
- **NeuralInterface**: Adapts UI based on user behavior
- **DimensionalTabs**: Implements 3D tab organization
- **VoiceCommands**: Processes voice input for browser control

### 6. Utility Layer
- **EventBus**: Application-wide event system
- **Logger**: Logging and diagnostics
- **SecurityUtils**: Security-related utilities
- **NetworkUtils**: Networking utilities
- **StorageUtils**: Data storage utilities

## Plugin System Architecture

### Plugin Structure
Each plugin is a Python package with a specific structure:
```
plugin_name/
  ├── __init__.py       # Plugin entry point
  ├── manifest.json     # Plugin metadata
  ├── icon.png          # Plugin icon
  ├── resources/        # Plugin resources
  └── settings.json     # Plugin default settings
```

### Plugin Manifest
The manifest.json file defines plugin metadata and required hooks:
```json
{
  "name": "Example Plugin",
  "version": "1.0.0",
  "author": "Developer Name",
  "description": "Example plugin description",
  "permissions": ["tabs", "bookmarks", "history"],
  "hooks": ["onPageLoad", "onTabCreated", "onBookmarkAdded"],
  "settings_page": "settings_ui.py",
  "min_browser_version": "1.0.0",
  "dependencies": []
}
```

### Hook System
The hook system allows plugins to extend browser functionality at specific points:

#### Browser Lifecycle Hooks
- `onBrowserStart`: Called when browser starts
- `onBrowserExit`: Called when browser exits
- `onSettingsChanged`: Called when browser settings change

#### Tab Hooks
- `onTabCreated`: Called when a new tab is created
- `onTabClosed`: Called when a tab is closed
- `onTabSelected`: Called when a tab is selected
- `onTabMoved`: Called when a tab is moved

#### Navigation Hooks
- `beforeNavigation`: Called before navigating to a URL
- `afterNavigation`: Called after navigating to a URL
- `onPageStartLoad`: Called when a page starts loading
- `onPageFinishLoad`: Called when a page finishes loading
- `onPageError`: Called when a page fails to load

#### Content Hooks
- `beforeDOMLoad`: Called before DOM is loaded
- `afterDOMLoad`: Called after DOM is loaded
- `onHTMLModify`: Called when HTML is modified
- `onCSSModify`: Called when CSS is modified
- `onJSExecute`: Called when JavaScript is executed

#### UI Hooks
- `onToolbarCreated`: Called when toolbar is created
- `onMenuCreated`: Called when menu is created
- `onContextMenu`: Called when context menu is shown
- `onStatusBarUpdate`: Called when status bar is updated
- `onAddressBarUpdate`: Called when address bar is updated

#### Data Hooks
- `onBookmarkAdded`: Called when bookmark is added
- `onBookmarkRemoved`: Called when bookmark is removed
- `onHistoryAdded`: Called when history entry is added
- `onHistoryRemoved`: Called when history entry is removed
- `onCookieSet`: Called when cookie is set
- `onCookieRemoved`: Called when cookie is removed

#### Download Hooks
- `onDownloadStart`: Called when download starts
- `onDownloadProgress`: Called during download progress
- `onDownloadComplete`: Called when download completes
- `onDownloadError`: Called when download fails

#### Unique Feature Hooks
- `onRealityAugmentation`: Called when reality augmentation is activated
- `onCollaborativeSession`: Called when collaborative session starts/ends
- `onContentTransform`: Called when content transformation occurs
- `onTimeTravelSnapshot`: Called when time travel snapshot is taken
- `onDimensionalTabChange`: Called when dimensional tab arrangement changes
- `onVoiceCommand`: Called when voice command is processed

### Plugin API
The Plugin API provides interfaces for plugins to interact with browser components:

#### Browser API
- `getBrowserInfo()`: Get browser information
- `getVersion()`: Get browser version
- `restart()`: Restart browser
- `exit()`: Exit browser

#### Tab API
- `getTabs()`: Get all tabs
- `getCurrentTab()`: Get current tab
- `createTab(url)`: Create new tab
- `closeTab(tabId)`: Close tab
- `selectTab(tabId)`: Select tab
- `moveTab(tabId, index)`: Move tab
- `getTabInfo(tabId)`: Get tab information

#### Navigation API
- `navigate(url)`: Navigate to URL
- `goBack()`: Go back
- `goForward()`: Go forward
- `reload()`: Reload page
- `stop()`: Stop loading
- `getCurrentURL()`: Get current URL

#### Content API
- `getPageHTML()`: Get page HTML
- `getPageDOM()`: Get page DOM
- `injectCSS(css)`: Inject CSS
- `injectJS(js)`: Inject JavaScript
- `modifyDOM(selector, action)`: Modify DOM elements

#### UI API
- `addToolbarButton(icon, text, callback)`: Add toolbar button
- `addMenuItem(menu, text, callback)`: Add menu item
- `addContextMenuItem(text, callback)`: Add context menu item
- `showNotification(title, message)`: Show notification
- `createPanel(title, content)`: Create side panel

#### Data API
- `getBookmarks()`: Get all bookmarks
- `addBookmark(url, title)`: Add bookmark
- `removeBookmark(id)`: Remove bookmark
- `getHistory()`: Get browsing history
- `clearHistory()`: Clear history
- `getCookies(domain)`: Get cookies
- `setCookie(cookie)`: Set cookie
- `removeCookie(name, domain)`: Remove cookie

#### Download API
- `downloadFile(url, path)`: Download file
- `pauseDownload(id)`: Pause download
- `resumeDownload(id)`: Resume download
- `cancelDownload(id)`: Cancel download
- `getDownloads()`: Get all downloads

#### Settings API
- `getSettings()`: Get plugin settings
- `setSetting(key, value)`: Set plugin setting
- `getBrowserSettings()`: Get browser settings
- `registerSettingsPage(page)`: Register settings page

#### Unique Features API
- `startRealityAugmentation()`: Start reality augmentation
- `startCollaborativeSession(sessionId)`: Start collaborative session
- `transformContent(type)`: Transform content
- `takeTimeSnapshot()`: Take time travel snapshot
- `organizeDimensionalTabs(arrangement)`: Organize dimensional tabs
- `registerVoiceCommand(command, callback)`: Register voice command

### Plugin Sandboxing
The plugin sandbox enforces security boundaries:

- **Resource Limits**: CPU, memory, and network usage limits
- **Permission System**: Explicit permission model for API access
- **Isolation**: Each plugin runs in an isolated environment
- **Code Validation**: Static analysis of plugin code before execution
- **Event Monitoring**: Monitoring of plugin behavior for suspicious activity

## Data Flow

1. **User Input** → **UI Layer** → **Browser Engine Layer** → **Web Content**
2. **Web Content** → **Browser Engine Layer** → **UI Layer** → **User Display**
3. **Plugin System** intercepts at various points via hooks
4. **Unique Features** enhance the standard flow with additional capabilities

## Communication Patterns

1. **Event-Based**: Components communicate via the EventBus
2. **Direct API Calls**: For synchronous operations
3. **Signal/Slot**: For UI updates (Qt's native mechanism)
4. **Hook System**: For plugin integration points

## File Structure

```
src/
  ├── main.py                 # Application entry point
  ├── core/                   # Core browser functionality
  │   ├── application.py      # Application controller
  │   ├── settings.py         # Settings manager
  │   ├── web_engine.py       # Web engine wrapper
  │   ├── tab_manager.py      # Tab management
  │   ├── history.py          # History management
  │   ├── bookmarks.py        # Bookmark management
  │   ├── cookies.py          # Cookie management
  │   ├── downloads.py        # Download management
  │   └── security.py         # Security features
  ├── ui/                     # User interface components
  │   ├── main_window.py      # Main application window
  │   ├── browser_tabs.py     # Tab UI components
  │   ├── address_bar.py      # Address bar UI
  │   ├── navigation_bar.py   # Navigation controls UI
  │   ├── status_bar.py       # Status bar UI
  │   ├── side_panel.py       # Side panel UI
  │   ├── context_menus.py    # Context menus
  │   └── dialogs/            # Dialog windows
  ├── plugins/                # Plugin system
  │   ├── plugin_loader.py    # Plugin loading mechanism
  │   ├── plugin_manager.py   # Plugin lifecycle management
  │   ├── hook_registry.py    # Hook registration and dispatch
  │   ├── plugin_api.py       # Plugin API interfaces
  │   ├── sandbox.py          # Plugin sandboxing
  │   └── default_plugins/    # Built-in plugins
  ├── features/               # Unique browser features
  │   ├── reality_augmentation.py  # Reality augmentation
  │   ├── collaborative.py    # Collaborative browsing
  │   ├── content_transform.py # Content transformation
  │   ├── time_travel.py      # Time travel browsing
  │   ├── neural_interface.py # Neural interface
  │   ├── dimensional_tabs.py # Dimensional tabs
  │   └── voice_commands.py   # Voice command system
  ├── themes/                 # Theming system
  │   ├── theme_manager.py    # Theme management
  │   ├── theme_loader.py     # Theme loading
  │   └── default_themes/     # Default themes
  └── utils/                  # Utility modules
      ├── event_bus.py        # Event system
      ├── logger.py           # Logging
      ├── security_utils.py   # Security utilities
      ├── network_utils.py    # Network utilities
      └── storage_utils.py    # Storage utilities
```

## Initialization Sequence

1. Load application settings
2. Initialize core components
3. Set up UI components
4. Load and initialize plugins
5. Restore previous session (if applicable)
6. Initialize unique features
7. Display main window

This architecture provides a solid foundation for the NebulaFusion browser, with clear separation of concerns, extensive plugin capabilities, and support for the unique features that set it apart from other browsers.
</file>

<file path="docs/plugin_system.md">
#!/usr/bin/env python3
# NebulaFusion Browser - Plugin System Documentation

# NebulaFusion Browser - Plugin System Documentation

## Overview

The NebulaFusion browser features a robust plugin system that allows developers to extend browser functionality through Python modules. Plugins can interact with all aspects of the browser, from tab management to content manipulation, and can even leverage NebulaFusion's unique features like Reality Augmentation and Dimensional Tabs.

## Plugin Structure

A NebulaFusion plugin consists of at least two files:

1. `__init__.py` - The main plugin code
2. `manifest.json` - Plugin metadata and configuration

These files should be placed in a directory with the plugin's name, which should be placed in the plugins directory (default: `~/.nebulafusion/plugins/`).

Example structure:
```
~/.nebulafusion/plugins/
└── my_plugin/
    ├── __init__.py
    └── manifest.json
```

## Plugin Manifest

The `manifest.json` file defines the plugin's metadata, required permissions, and hooks. Here's an example:

```json
{
    "name": "My Plugin",
    "version": "1.0.0",
    "author": "Developer Name",
    "description": "This plugin adds awesome functionality to NebulaFusion.",
    "min_browser_version": "1.0.0",
    "permissions": [
        "tabs",
        "bookmarks",
        "history",
        "navigation",
        "content",
        "ui"
    ],
    "hooks": [
        "onBrowserStart",
        "onTabCreated",
        "onPageFinishLoad"
    ],
    "default_settings": {
        "enable_feature_x": true,
        "feature_y_color": "#4a86e8"
    }
}
```

### Manifest Fields

- `name`: The display name of the plugin
- `version`: The plugin version (semantic versioning recommended)
- `author`: The plugin author's name
- `description`: A brief description of the plugin
- `min_browser_version`: The minimum NebulaFusion version required
- `permissions`: The browser features the plugin needs access to
- `hooks`: The browser events the plugin wants to handle
- `default_settings`: Default settings for the plugin

## Available Permissions

Plugins must request permissions to access browser features:

| Permission | Description |
|------------|-------------|
| `browser` | Access to browser information and lifecycle |
| `tabs` | Tab creation, manipulation, and access |
| `bookmarks` | Bookmark management |
| `history` | Browsing history access |
| `navigation` | Page navigation control |
| `content` | Page content access and manipulation |
| `ui` | UI customization (toolbars, menus, etc.) |
| `cookies` | Cookie access and management |
| `downloads` | Download management |
| `settings` | Browser settings access |
| `reality_augmentation` | Reality Augmentation feature |
| `collaborative` | Collaborative Browsing feature |
| `content_transform` | Content Transformation feature |
| `time_travel` | Time-Travel Browsing feature |
| `dimensional_tabs` | Dimensional Tabs feature |
| `voice_commands` | Voice Command System |
| `all` | All permissions (use with caution) |

## Available Hooks

Hooks allow plugins to respond to browser events:

### Browser Lifecycle Hooks
- `onBrowserStart`: Called when the browser starts
- `onBrowserExit`: Called when the browser is about to exit
- `onSettingsChanged`: Called when browser settings change

### Tab Hooks
- `onTabCreated`: Called when a new tab is created
- `beforeTabClosed`: Called before a tab is closed
- `onTabClosed`: Called after a tab is closed
- `onTabSelected`: Called when a tab is selected
- `onTabMoved`: Called when a tab is moved

### Navigation Hooks
- `beforeNavigation`: Called before navigating to a URL
- `afterNavigation`: Called after navigating to a URL
- `onPageStartLoad`: Called when a page starts loading
- `onPageLoadProgress`: Called during page load progress
- `onPageFinishLoad`: Called when a page finishes loading
- `onPageError`: Called when a page fails to load

### Content Hooks
- `beforeDOMLoad`: Called before the DOM is loaded
- `afterDOMLoad`: Called after the DOM is loaded
- `onHTMLModify`: Called when HTML is modified
- `onCSSModify`: Called when CSS is modified
- `onJSExecute`: Called when JavaScript is executed

### UI Hooks
- `onToolbarCreated`: Called when the toolbar is created
- `onMenuCreated`: Called when a menu is created
- `onContextMenu`: Called when a context menu is shown
- `onStatusBarUpdate`: Called when the status bar is updated
- `onAddressBarUpdate`: Called when the address bar is updated

### Data Hooks
- `onBookmarkAdded`: Called when a bookmark is added
- `onBookmarkRemoved`: Called when a bookmark is removed
- `onHistoryAdded`: Called when a history entry is added
- `onHistoryRemoved`: Called when a history entry is removed
- `onCookieSet`: Called when a cookie is set
- `onCookieRemoved`: Called when a cookie is removed
- `onCookiesCleared`: Called when cookies are cleared

### Download Hooks
- `onDownloadStart`: Called when a download starts
- `onDownloadProgress`: Called during download progress
- `onDownloadComplete`: Called when a download completes
- `onDownloadError`: Called when a download fails
- `onDownloadCanceled`: Called when a download is canceled

### Unique Feature Hooks
- `onRealityAugmentation`: Called when Reality Augmentation is used
- `onCollaborativeSession`: Called when a Collaborative Session is started
- `onContentTransform`: Called when Content Transformation is used
- `onTimeTravelSnapshot`: Called when a Time-Travel snapshot is taken
- `onDimensionalTabChange`: Called when Dimensional Tabs change
- `onVoiceCommand`: Called when a Voice Command is received

## Plugin Class

The `__init__.py` file should contain a class that implements the plugin functionality. The class must have at least the following methods:

```python
class MyPlugin:
    def __init__(self):
        """Initialize the plugin."""
        self.initialized = False
    
    def initialize(self, api):
        """Initialize the plugin with the provided API."""
        self.api = api
        self.initialized = True
        return True
    
    def shutdown(self):
        """Shutdown the plugin."""
        self.initialized = False
        return True
```

Additionally, the class should implement methods for any hooks specified in the manifest:

```python
def onBrowserStart(self):
    """Handle browser start event."""
    self.api.show_notification("My Plugin", "Browser started!")
    return True

def onTabCreated(self, tab_index):
    """Handle tab created event."""
    tab_info = self.api.get_tab_info(tab_index)
    self.api.show_notification("My Plugin", f"New tab created: {tab_info['title']}")
    return True

def onPageFinishLoad(self, url):
    """Handle page finish load event."""
    self.api.show_notification("My Plugin", f"Page loaded: {url}")
    return True
```

## Plugin API

The plugin API is provided to the plugin during initialization and gives access to browser features. Here's an overview of the available API methods:

### Browser API
- `get_browser_info()`: Get browser information
- `get_version()`: Get browser version
- `restart()`: Restart the browser
- `exit()`: Exit the browser

### Tab API
- `get_tabs()`: Get all tabs
- `get_current_tab()`: Get current tab
- `create_tab(url, background=False, private=False)`: Create new tab
- `close_tab(tab_index)`: Close tab
- `select_tab(tab_index)`: Select tab
- `move_tab(tab_index, new_index)`: Move tab
- `get_tab_info(tab_index)`: Get tab information

### Navigation API
- `navigate(url, new_tab=False)`: Navigate to URL
- `go_back()`: Go back
- `go_forward()`: Go forward
- `reload()`: Reload page
- `stop()`: Stop loading
- `get_current_url()`: Get current URL

### Content API
- `get_page_html()`: Get page HTML
- `get_page_dom()`: Get page DOM
- `inject_css(css)`: Inject CSS
- `inject_js(js)`: Inject JavaScript
- `modify_dom(selector, action)`: Modify DOM elements

### UI API
- `add_toolbar_button(icon, text, callback)`: Add toolbar button
- `add_menu_item(menu, text, callback)`: Add menu item
- `add_context_menu_item(text, callback)`: Add context menu item
- `show_notification(title, message)`: Show notification
- `create_panel(title, content)`: Create side panel

### Data API
- `get_bookmarks()`: Get all bookmarks
- `add_bookmark(url, title, folder="other")`: Add bookmark
- `remove_bookmark(bookmark_id)`: Remove bookmark
- `get_history(limit=100, offset=0, search=None)`: Get browsing history
- `clear_history(time_range=None)`: Clear history
- `get_cookies(domain=None)`: Get cookies
- `set_cookie(cookie)`: Set cookie
- `remove_cookie(name, domain)`: Remove cookie

### Download API
- `download_file(url, path=None)`: Download file
- `pause_download(download_id)`: Pause download
- `resume_download(download_id)`: Resume download
- `cancel_download(download_id)`: Cancel download
- `get_downloads()`: Get all downloads

### Settings API
- `get_settings()`: Get plugin settings
- `set_setting(key, value)`: Set plugin setting
- `get_browser_settings()`: Get browser settings
- `register_settings_page(page)`: Register settings page

### Unique Features API
- `start_reality_augmentation()`: Start reality augmentation
- `start_collaborative_session(session_id=None)`: Start collaborative session
- `transform_content(transform_type)`: Transform content
- `take_time_snapshot()`: Take time travel snapshot
- `organize_dimensional_tabs(arrangement)`: Organize dimensional tabs
- `register_voice_command(command, callback)`: Register voice command

## Plugin Sandboxing

For security, plugins run in a sandboxed environment with the following restrictions:

- Limited CPU usage
- Limited memory usage
- Limited network requests
- Limited file access
- Permission-based API access

Plugins that exceed resource limits or attempt unauthorized actions will be disabled.

## Plugin Settings

Plugins can store and retrieve settings using the Settings API:

```python
# Get plugin settings
settings = self.api.get_settings()

# Get a specific setting with default value
show_notifications = settings.get("show_notifications", True)

# Set a setting
self.api.set_setting("show_notifications", False)
```

Default settings can be specified in the manifest.json file.

## Example Plugin

Here's a simple example plugin that adds a toolbar button and responds to tab creation:

### manifest.json
```json
{
    "name": "Hello World",
    "version": "1.0.0",
    "author": "NebulaFusion Team",
    "description": "A simple hello world plugin for NebulaFusion.",
    "min_browser_version": "1.0.0",
    "permissions": [
        "tabs",
        "ui"
    ],
    "hooks": [
        "onTabCreated"
    ],
    "default_settings": {
        "greeting": "Hello, World!"
    }
}
```

### __init__.py
```python
class HelloWorld:
    def __init__(self):
        self.initialized = False
    
    def initialize(self, api):
        self.api = api
        self.initialized = True
        
        # Get settings
        self.settings = self.api.get_settings()
        
        # Add toolbar button
        self.api.add_toolbar_button(
            "hello_icon.png",
            "Hello",
            self.on_hello_clicked
        )
        
        return True
    
    def shutdown(self):
        self.initialized = False
        return True
    
    def on_hello_clicked(self):
        greeting = self.settings.get("greeting", "Hello, World!")
        self.api.show_notification("Hello World Plugin", greeting)
    
    def onTabCreated(self, tab_index):
        self.api.show_notification(
            "Hello World Plugin",
            "A new tab was created!"
        )
        return True
```

## Best Practices

1. **Request only necessary permissions**: Request only the permissions your plugin actually needs.
2. **Handle errors gracefully**: Check for errors and handle them appropriately.
3. **Clean up resources**: Release resources in the shutdown method.
4. **Respect user settings**: Allow users to configure your plugin's behavior.
5. **Provide clear feedback**: Use notifications to inform users about important actions.
6. **Optimize performance**: Minimize resource usage, especially in frequently called hooks.
7. **Follow UI guidelines**: Maintain consistency with the browser's UI.
8. **Document your plugin**: Provide clear documentation for users.

## Troubleshooting

If your plugin isn't working as expected:

1. Check the browser console for error messages
2. Verify that your plugin has the necessary permissions
3. Ensure your hook methods have the correct signatures
4. Check that your plugin is enabled in the browser settings
5. Verify that your plugin's manifest.json is valid JSON

## Further Resources

- Sample plugins in the `src/plugins/sample_plugins` directory
- NebulaFusion API documentation
- PyQt5 documentation: https://www.riverbankcomputing.com/static/Docs/PyQt5/
- Qt WebEngine documentation: https://doc.qt.io/qt-5/qtwebengine-index.html
</file>

<file path="docs/unique_features.md">
#!/usr/bin/env python3
# NebulaFusion Browser - Unique Features Documentation

# NebulaFusion Browser - Unique Features Documentation

NebulaFusion Browser includes several innovative features that set it apart from other web browsers. This document provides an overview of these unique capabilities and how to use them.

## Reality Augmentation

Reality Augmentation overlays digital information on web content, enhancing your browsing experience with contextual data.

### How It Works
When enabled, Reality Augmentation analyzes the content of web pages and adds relevant information overlays:

- **Entity Recognition**: Identifies people, places, companies, and other entities, providing quick information cards when you hover over them.
- **Data Visualization**: Transforms tables and statistics into interactive charts and graphs.
- **Spatial Context**: Adds 3D models and spatial information to geographic or product-related content.
- **Historical Context**: Provides historical information about topics mentioned on the page.

### Usage
1. Enable Reality Augmentation in Settings → Unique Features
2. Browse normally - augmented elements will be highlighted with a subtle glow
3. Hover over highlighted elements to see augmented information
4. Click the Reality Augmentation icon in the toolbar to adjust settings

### API for Plugins
Plugins can extend Reality Augmentation with custom overlays:

```python
# Register a custom augmentation provider
self.api.register_augmentation_provider("my_provider", self.augment_content)

# Augmentation callback
def augment_content(self, content, content_type, url):
    # Process content and return augmentation data
    augmentations = [
        {
            "selector": ".product-item",
            "type": "overlay",
            "content": "<div class='augmentation'>Enhanced product info</div>",
            "position": "right"
        }
    ]
    return augmentations
```

## Collaborative Browsing

Collaborative Browsing allows multiple users to share browsing sessions in real-time, enabling joint research, shopping, or troubleshooting.

### How It Works
- **Session Sharing**: Create or join collaborative sessions with unique IDs
- **Synchronized Navigation**: All participants see the same web pages
- **Cursor Sharing**: See where other participants are pointing and clicking
- **Chat Integration**: Communicate with session participants via text or voice
- **Annotation Tools**: Highlight, draw, or add notes to shared web pages

### Usage
1. Click the Collaborative icon in the toolbar
2. Create a new session or join an existing one with a session ID
3. Share the session ID with others you want to invite
4. Use the collaboration panel to see participants and access tools

### API for Plugins
Plugins can extend Collaborative Browsing functionality:

```python
# Start a collaborative session
session = self.api.start_collaborative_session()

# Add custom collaboration tools
self.api.add_collaboration_tool("my_tool", "My Tool", self.on_tool_activated)

# Send custom data to session participants
self.api.send_collaboration_data("custom_event", {"key": "value"})

# Listen for collaboration events
def onCollaborativeSession(self, session_id, participants):
    # Handle session events
    pass
```

## Content Transformation

Content Transformation converts web content between different formats and presentations to improve accessibility and usability.

### How It Works
- **Reading Mode**: Strips away distractions for a clean reading experience
- **Format Conversion**: Transform content between text, audio, and visual formats
- **Translation**: Automatically translate page content to your preferred language
- **Simplification**: Adjust content complexity for easier comprehension
- **Media Adaptation**: Convert videos to text transcripts or images to descriptions

### Usage
1. Click the Transform icon in the toolbar
2. Select the desired transformation type
3. Adjust transformation settings if needed
4. View the transformed content

### API for Plugins
Plugins can add custom transformation types:

```python
# Register a custom transformation
self.api.register_content_transformation(
    "my_transform",
    "My Transformation",
    self.transform_content
)

# Transformation callback
def transform_content(self, content, url):
    # Process content and return transformed version
    transformed = process_my_way(content)
    return transformed
```

## Time-Travel Browsing

Time-Travel Browsing allows you to navigate through historical versions of web pages, comparing changes over time or accessing content that has been removed.

### How It Works
- **Snapshot Creation**: Automatically or manually create snapshots of web pages
- **Timeline Navigation**: Browse through page versions using a timeline slider
- **Change Highlighting**: See what's changed between versions
- **Restoration**: Restore previous versions of dynamically generated content
- **Archive Integration**: Access archived versions from web archives

### Usage
1. Enable Time-Travel in Settings → Unique Features
2. Browse normally - snapshots will be created automatically
3. Click the Time-Travel icon to open the timeline
4. Use the slider to navigate between versions
5. Click "Take Snapshot" to manually create a snapshot

### API for Plugins
Plugins can interact with the Time-Travel system:

```python
# Take a snapshot of the current page
snapshot = self.api.take_time_snapshot()

# Retrieve a specific snapshot
content = self.api.get_time_snapshot(snapshot_id)

# Compare snapshots
diff = self.api.compare_time_snapshots(snapshot_id1, snapshot_id2)

# Listen for snapshot events
def onTimeTravelSnapshot(self, snapshot_id, timestamp):
    # Handle snapshot creation
    pass
```

## Neural Interface Customization

Neural Interface Customization adapts the browser UI based on your usage patterns, learning your preferences to create a personalized browsing experience.

### How It Works
- **Usage Analysis**: Learns from your browsing habits and preferences
- **Adaptive UI**: Automatically adjusts layouts, button positions, and tool visibility
- **Predictive Navigation**: Suggests content and actions based on context
- **Focus Adaptation**: Minimizes distractions during focused reading or work
- **Mood-Based Theming**: Adjusts visual style based on content and time of day

### Usage
1. Enable Neural Interface in Settings → Unique Features
2. Use the browser normally - the system will learn from your interactions
3. Access the Neural Interface dashboard to view insights and adjust settings
4. Use the "Reset Learning" option if you want to start fresh

### API for Plugins
Plugins can interact with the Neural Interface system:

```python
# Get user preference insights
insights = self.api.get_neural_insights()

# Register custom adaptations
self.api.register_neural_adaptation(
    "my_adaptation",
    "My Adaptation",
    self.adapt_interface
)

# Adaptation callback
def adapt_interface(self, context, insights):
    # Return adaptation instructions
    return {
        "elements": [
            {"id": "toolbar", "visibility": 0.8},
            {"id": "sidebar", "position": "right"}
        ]
    }
```

## Dimensional Tabs

Dimensional Tabs organize your tabs in a multi-dimensional space, grouping related content and creating spatial relationships between tabs.

### How It Works
- **Spatial Organization**: Arrange tabs in 2D or 3D space based on relationships
- **Automatic Clustering**: Group related tabs by topic, domain, or session
- **Zoom Navigation**: Zoom out to see the big picture, zoom in to focus
- **Connection Visualization**: See how tabs are related to each other
- **Context Preservation**: Maintain context when switching between tab groups

### Usage
1. Click the Dimensions icon in the toolbar
2. Choose a dimensional view (2D Map, 3D Space, etc.)
3. Drag tabs to organize them manually, or use auto-arrange
4. Use pinch gestures or mouse wheel to zoom in/out
5. Create named dimensions to separate work, personal, and project tabs

### API for Plugins
Plugins can extend Dimensional Tabs functionality:

```python
# Create a new dimension
dimension = self.api.create_tab_dimension("my_dimension", "My Dimension")

# Add tabs to a dimension
self.api.add_tab_to_dimension(tab_index, dimension_id)

# Define tab relationships
self.api.set_tab_relationship(tab_index1, tab_index2, "related", 0.8)

# Listen for dimension changes
def onDimensionalTabChange(self, dimension):
    # Handle dimension change
    pass
```

## Voice Command System

The Voice Command System allows you to control the browser using natural language voice commands, enabling hands-free browsing.

### How It Works
- **Natural Language Processing**: Understand commands in conversational language
- **Context Awareness**: Interpret commands based on current browsing context
- **Custom Commands**: Define your own voice commands for specific actions
- **Voice Feedback**: Receive audio confirmation of commands and actions
- **Continuous Listening**: Option for always-on listening or push-to-talk

### Usage
1. Enable Voice Commands in Settings → Unique Features
2. Click the Voice icon or use the keyboard shortcut (Alt+V) to activate
3. Speak your command clearly (e.g., "Open new tab", "Bookmark this page")
4. Use the Voice Command Settings to view available commands and add custom ones

### API for Plugins
Plugins can add custom voice commands:

```python
# Register a voice command
self.api.register_voice_command(
    "show [something]",
    "Shows something on the page",
    self.handle_show_command
)

# Command handler
def handle_show_command(self, params):
    what = params.get("something", "")
    # Handle the command
    return True

# Listen for voice commands
def onVoiceCommand(self, command, confidence):
    # Handle voice command
    pass
```

## Integration Between Features

NebulaFusion's unique features are designed to work together seamlessly:

- **Reality Augmentation + Collaborative Browsing**: Share augmented views with collaborators
- **Time-Travel + Content Transformation**: Transform historical versions of content
- **Dimensional Tabs + Neural Interface**: Adaptive spatial organization based on your work patterns
- **Voice Commands + Reality Augmentation**: Control augmentations with voice
- **Collaborative Browsing + Dimensional Tabs**: Share entire dimensions with collaborators

## Extending Unique Features

Developers can extend all unique features through the plugin system. See the Plugin System Documentation for detailed API references and examples.

## Future Enhancements

The NebulaFusion team is continuously working on enhancing these unique features:

- **AI-Powered Content Analysis**: Deeper understanding of web content
- **Extended Reality Integration**: VR/AR support for immersive browsing
- **Brain-Computer Interface**: Experimental support for direct neural input
- **Quantum Rendering**: Utilizing quantum computing principles for content processing
- **Predictive Browsing**: Preloading content you're likely to want next

Stay tuned for updates and new features in future releases!
</file>

<file path="migration_analysis.md">
# PyQt5 to PyQt6 Migration Analysis

## Key Import Changes

### Main Module Changes
- `PyQt5` → `PyQt6`
- `PyQt5.QtWebEngineWidgets` → `PyQt6.QtWebEngineWidgets` 
- `PyQt5.QtWebEngine` → `PyQt6.QtWebEngineCore`

### Specific Import Changes
- `from PyQt5.QtCore import ...` → `from PyQt6.QtCore import ...`
- `from PyQt5.QtWidgets import ...` → `from PyQt6.QtWidgets import ...`
- `from PyQt5.QtGui import ...` → `from PyQt6.QtGui import ...`
- `from PyQt5.QtWebEngineWidgets import ...` → `from PyQt6.QtWebEngineWidgets import ...`
- `from PyQt5.QtWebEngineCore import ...` → `from PyQt6.QtWebEngineCore import ...`
- `from PyQt5.QtTest import ...` → `from PyQt6.QtTest import ...`

## API Changes

### Signal/Slot Connection Syntax
- PyQt5: `object.signal.connect(slot)`
- PyQt6: Same syntax, but stricter type checking

### QWebEngineProfile Changes
- `QWebEngineProfile.defaultProfile()` remains but some methods may have changed
- Cookie store access might need adjustment

### QWebEnginePage Changes
- Some methods might have been renamed or parameters changed
- JavaScript execution methods might have different signatures

### QAction Changes
- Constructor signature might have changed
- Some methods might have been renamed

### QUrl Changes
- API remains largely the same, but some methods might have been renamed

### QWebEngineSettings Changes
- Some enum values might have been renamed or moved to different classes

## Removed/Deprecated Features

- `QString` and `QVariant` are completely removed (though they were already deprecated in PyQt5)
- Some older Qt4-era compatibility methods might be removed
- Some widget-specific methods might have been renamed or parameters changed

## New Features in PyQt6

- Better type hinting support
- More consistent API
- New widgets and functionality that could be leveraged

## Migration Strategy

1. Update all imports first
2. Fix class and method names that have changed
3. Update signal/slot connections if needed
4. Address any parameter changes in method calls
5. Test each component after migration
6. Leverage new PyQt6 features where appropriate

## Components Requiring Special Attention

### WebEngine Components
- QWebEngineView
- QWebEnginePage
- QWebEngineProfile
- QWebEngineSettings
- QWebEngineCookieStore

### Core Browser Components
- Tab management
- Navigation controls
- Cookie handling
- Download management

### UI Components
- Toolbar and menu creation
- Context menus
- Dialog boxes

### Plugin System
- Signal/slot connections
- JavaScript execution
- DOM manipulation

### Theming System
- QSS (Qt Style Sheets) syntax might have changes
- Widget styling methods

## Testing Strategy

1. Test core browser functionality first
2. Test plugin system and API
3. Test theming system
4. Test unique features
5. Run the full test suite
</file>

<file path="README.md">
# Template Plugin

A template plugin for NebulaFusion browser.

## Features

- Basic plugin structure
- Hook registration
- Plugin lifecycle management

## Installation

1. Copy this directory to the NebulaFusion plugins directory
2. Enable the plugin in the browser settings

## Development

This template provides a starting point for developing NebulaFusion plugins.
Customize it to add your own features and functionality.

## License

MIT
</file>

<file path="requirements.md">
# PyQt Browser Detailed Requirements

## Core Browser Features

### Tabbed Browsing
- Multiple tabs with ability to open, close, and switch between tabs
- Tab title and favicon display
- Tab reordering via drag and drop
- New tab button and keyboard shortcut (Ctrl+T)
- Tab context menu with close, reload, duplicate options
- Session management to restore tabs on restart

### Navigation Controls
- Address bar with URL input and display
- Back, forward, reload, and stop buttons
- Progress indicator during page loading
- SSL/security status indicator
- Search engine integration in address bar
- Keyboard shortcuts for navigation (F5 for reload, etc.)

### History Management
- Store visited URLs with timestamps
- History view with search and filtering options
- Clear history functionality (all/selected/time range)
- Most visited sites tracking
- History API for plugins

### Bookmarks System
- Add, edit, delete bookmarks
- Bookmark folders and organization
- Import/export bookmarks
- Bookmarks toolbar
- Bookmark search functionality
- Bookmark API for plugins

### Private/Incognito Mode
- Toggle for private browsing
- No history or cookie storage in private mode
- Visual indicator for private mode
- Separate window for private browsing
- Automatic clearing of session data on close

### Cookie Management
- Persistent cookie storage using QWebEngineCookieStore
- Cookie viewer and manager UI
- Cookie blocking/allowing per site
- Cookie expiration handling
- Third-party cookie controls
- Cookie API for plugins

### Download Manager
- Download progress tracking
- Pause/resume downloads
- Download history
- Default download location setting
- Open downloaded file option
- Download API for plugins

## Plugin System

### Plugin Loading
- Dynamic loading of Python modules from plugins folder
- Plugin metadata parsing (name, version, author, description)
- Plugin dependencies handling
- Plugin enable/disable functionality
- Plugin installation/removal during runtime
- Plugin update mechanism

### Plugin Hooks
- Page load hooks (before/after)
- Request/response interception hooks
- DOM modification hooks
- UI extension hooks (toolbar, menu, sidebar)
- Context menu extension hooks
- Tab event hooks (open, close, switch)
- Navigation hooks (before/after navigation)
- Download hooks
- Bookmark/history hooks
- Settings hooks

### Plugin API
- Browser object model access
- Tab management API
- Navigation control API
- Cookie and storage access API
- UI modification API
- Network request/response API
- Inter-plugin communication API
- Plugin settings storage API
- Browser event subscription API

### Plugin UI
- Plugin manager interface
- Plugin settings UI integration
- Plugin status indicators
- Plugin resource usage monitoring
- Plugin error reporting

## Theming Support

### Theme Management
- Theme loading from themes folder
- Theme metadata parsing
- Theme switching mechanism
- Theme preview functionality
- Custom theme creation support

### Theme Components
- Light and dark mode base themes
- Color scheme customization
- Font customization
- UI element styling
- Icon sets
- Animation settings

### Theme Settings
- Theme selection UI
- Color customization UI
- Font selection UI
- UI density controls
- Theme import/export

## Security Considerations

### Plugin Sandboxing
- Resource usage limitations
- File system access restrictions
- Network request filtering
- API access control
- Plugin code validation
- Plugin signing/verification

### Data Security
- Secure storage of sensitive data
- Password manager integration
- Form data protection
- HTTPS enforcement options
- Security warning system
- Privacy controls

## Additional Features

### Keyboard Shortcuts
- Customizable keyboard shortcuts
- Shortcut conflicts resolution
- Shortcut categories (navigation, tabs, etc.)
- Shortcut overlay/help display
- Plugin shortcut integration

### Settings Management
- Settings UI with categories
- Settings storage in JSON/XML
- Settings import/export
- Settings search functionality
- Default settings restoration
- Settings API for plugins

### Developer Tools
- Plugin debugging console
- Network request inspector
- DOM inspector integration
- JavaScript console access
- Performance monitoring
- Error logging system

### Accessibility
- Screen reader compatibility
- Keyboard navigation
- Font size adjustment
- High contrast mode
- Zoom functionality
- Color blindness accommodations
</file>

<file path="src/core/application.py">
#!/usr/bin/env python3
# NebulaFusion Browser - Application

import os
import sys
import logging
from PyQt6.QtWidgets import QApplication
from PyQt6.QtCore import QObject, pyqtSignal, QUrl, QSettings

# Import core modules
from src.core.web_engine import WebEngineManager
from src.core.tab_manager import TabManager
from src.core.history import HistoryManager
from src.core.bookmarks import BookmarksManager
from src.core.cookies import CookiesManager
from src.core.downloads import DownloadManager
from src.core.security import SecurityManager
from src.core.content_security import ContentSecurityManager

# Import plugin modules
from src.plugins.plugin_loader import PluginLoader
from src.plugins.plugin_manager import PluginManager
from src.plugins.hook_registry import HookRegistry

# Import theme modules
from src.themes.theme_manager import ThemeManager

# Import UI modules
from src.ui.main_window import MainWindow


class Application(QObject):
    """
    Main application class for NebulaFusion browser.
    Handles initialization, cleanup, and management of browser components.
    """

    # Signals
    initialized = pyqtSignal()  # THIS IS THE SIGNAL. Keep this name.
    starting = pyqtSignal()
    closing = pyqtSignal()

    def __init__(self):
        """Initialize the application."""
        super().__init__()

        # Application state
        self._is_initialized_flag = (
            False  # CHANGED: Renamed the boolean flag to avoid collision
        )
        self.main_window = None

        # Setup logging
        self._setup_logging()

        # Create managers
        self._create_managers()

    def _setup_logging(self):
        """Setup logging."""
        # Create logger
        self.logger = logging.getLogger("NebulaFusion")
        self.logger.setLevel(logging.INFO)

        # Create console handler
        console_handler = logging.StreamHandler()
        console_handler.setLevel(logging.INFO)

        # Create formatter
        formatter = logging.Formatter(
            "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
        )
        console_handler.setFormatter(formatter)

        # Add handler to logger
        self.logger.addHandler(console_handler)

        # Create log directory
        log_dir = os.path.expanduser("~/.nebulafusion/logs")
        os.makedirs(log_dir, exist_ok=True)

        # Create file handler
        file_handler = logging.FileHandler(os.path.join(log_dir, "nebulafusion.log"))
        file_handler.setLevel(logging.INFO)
        file_handler.setFormatter(formatter)

        # Add handler to logger
        self.logger.addHandler(file_handler)

    def _create_managers(self):
        """Create managers."""
        # Create settings manager
        self.settings_manager = SettingsManager(self)

        # Create web engine manager
        self.web_engine_manager = WebEngineManager(self)

        # Create tab manager
        self.tab_manager = TabManager(self)

        # Create history manager
        self.history_manager = HistoryManager(self)

        # Create bookmarks manager
        self.bookmarks_manager = BookmarksManager(self)

        # Create cookies manager
        self.cookies_manager = CookiesManager(self)

        # Create download manager
        self.download_manager = DownloadManager(self)

        # Create security manager
        self.security_manager = SecurityManager(self)

        # Create content security manager
        self.content_security_manager = ContentSecurityManager(self)

        # Create hook registry
        self.hook_registry = HookRegistry(self)

        # Create plugin loader
        self.plugin_loader = PluginLoader(self)

        # Create plugin manager
        self.plugin_manager = PluginManager(self)

        # Create theme manager
        self.theme_manager = ThemeManager(self)

    def initialize(self):
        """Initialize the application."""
        self.logger.info("Initializing NebulaFusion browser...")

        # Emit starting signal
        self.starting.emit()

        # Initialize core managers first
        self.logger.info("Initializing core managers...")
        self.settings_manager.initialize()
        self.web_engine_manager.initialize()
        self.tab_manager.initialize()
        self.history_manager.initialize()
        self.bookmarks_manager.initialize()
        self.cookies_manager.initialize()
        self.download_manager.initialize()
        self.security_manager.initialize()
        self.content_security_manager.initialize()

        # Initialize hook registry before plugins
        self.logger.info("Initializing hook registry...")
        self.hook_registry.initialize()

        # Initialize plugin system
        self.logger.info("Initializing plugin system...")
        self.plugin_loader.initialize()
        self.plugin_manager.initialize()

        # Initialize theme manager
        self.logger.info("Initializing theme manager...")
        self.theme_manager.initialize()

        # Create main window
        self.logger.info("Creating main window...")
        self.main_window = MainWindow(self)

        # Show main window
        if self.main_window:
            self.main_window.show()
            self.logger.info("Main window created and shown.")
        else:
            self.logger.error("Main window could not be created.")
            return False

        # Trigger browser start hook
        self.logger.info("Triggering browser start hook...")
        self.hook_registry.trigger_hook("onBrowserStart")

        # Load and enable plugins
        self.logger.info("Loading and enabling plugins...")
        self._initialize_plugins()

        # Update state
        self._is_initialized_flag = True

        # Emit initialized signal
        self.initialized.emit()
        self.logger.info("NebulaFusion browser initialized.")

        return True

    def _initialize_plugins(self):
        """Initialize and enable all plugins."""
        try:
            # Get all available plugins
            available_plugins = self.plugin_manager.get_available_plugins()
            self.logger.info(f"Found {len(available_plugins)} available plugins")

            # Enable all plugins
            for plugin_id in available_plugins:
                try:
                    self.logger.info(f"Enabling plugin: {plugin_id}")
                    self.plugin_manager.enable_plugin(plugin_id)
                except Exception as e:
                    self.logger.error(f"Error enabling plugin {plugin_id}: {str(e)}")
        except Exception as e:
            self.logger.error(f"Error initializing plugins: {str(e)}")

    def show(self):  # <--- ADD THIS METHOD
        if self.main_window:
            self.main_window.show()
        else:
            self.logger.error("Main window not initialized, cannot show.")

    def cleanup(self):
        """Clean up the application."""
        self.logger.info("Cleaning up NebulaFusion browser...")

        # Emit closing signal
        self.closing.emit()

        # Trigger hook
        self.hook_registry.trigger_hook("onBrowserExit")

        # Clean up managers
        self.theme_manager.cleanup()
        self.plugin_manager.cleanup()
        self.plugin_loader.cleanup()
        self.hook_registry.cleanup()
        self.content_security_manager.cleanup()
        self.security_manager.cleanup()
        self.download_manager.cleanup()
        self.cookies_manager.cleanup()
        self.bookmarks_manager.cleanup()
        self.history_manager.cleanup()
        self.tab_manager.cleanup()
        self.web_engine_manager.cleanup()
        self.settings_manager.cleanup()

        self.logger.info("NebulaFusion browser cleaned up.")

        return True

    def get_version(self):
        """Get the application version."""
        return "1.0.0"

    def get_name(self):
        """Get the application name."""
        return "NebulaFusion"

    def get_description(self):
        """Get the application description."""
        return "A modern web browser with a robust plugin system."

    def get_author(self):
        """Get the application author."""
        return "NebulaFusion Team"

    def get_website(self):
        """Get the application website."""
        return "https://nebulafusion.example.com"

    def get_license(self):
        """Get the application license."""
        return "MIT"


# SettingsManager class remains unchanged from your provided file, it seems correct.
class SettingsManager(QObject):
    """
    Manager for application settings.
    Handles loading, saving, and accessing settings.
    """

    # Signals
    setting_changed = pyqtSignal(str, object)  # key, value

    def __init__(self, app_controller):
        """Initialize the settings manager."""
        super().__init__()
        self.app_controller = app_controller

        # Settings
        self.settings = QSettings("NebulaFusion", "Browser")

        # Default settings
        self.default_settings = {
            "general.homepage": "https://www.google.com",
            "general.search_engine": "https://www.google.com/search?q=",
            "general.new_tab_page": "about:newtab",
            "general.download_directory": os.path.expanduser("~/Downloads"),
            "general.startup_mode": "restore",  # restore, homepage, blank
            "general.language": "en-US",
            "privacy.do_not_track": True,
            "privacy.block_third_party_cookies": False,
            "privacy.clear_history_on_exit": False,
            "privacy.clear_cookies_on_exit": False,
            "privacy.clear_cache_on_exit": False,
            "appearance.theme": "Default",
            "appearance.show_bookmarks_bar": True,
            "appearance.show_status_bar": True,
            "appearance.show_home_button": True,
            "tabs.close_button_on_tabs": True,
            "tabs.confirm_close_multiple_tabs": True,
            "tabs.switch_to_new_tabs": True,
            "advanced.hardware_acceleration": True,
            "advanced.javascript_enabled": True,
            "advanced.plugins_enabled": True,
            "advanced.developer_tools_enabled": True,
        }

        # Initialize settings
        self.initialized = (
            False  # This is specific to SettingsManager, no conflict here
        )

    def initialize(self):
        """Initialize the settings manager."""
        self.app_controller.logger.info("Initializing settings manager...")

        # Load settings
        self._load_settings()

        # Update state
        self.initialized = True

        self.app_controller.logger.info("Settings manager initialized.")

        return True

    def cleanup(self):
        """Clean up the settings manager."""
        self.app_controller.logger.info("Cleaning up settings manager...")

        # Save settings
        self._save_settings()

        # Update state
        self.initialized = False

        self.app_controller.logger.info("Settings manager cleaned up.")

        return True

    def _load_settings(self):
        """Load settings."""
        # Load settings from QSettings
        for key, default_value in self.default_settings.items():
            value = self.settings.value(key, default_value)

            # Convert value to correct type
            if isinstance(default_value, bool):
                if isinstance(value, str):
                    value = value.lower() in ["true", "1", "yes"]
                else:
                    value = bool(value)
            elif isinstance(default_value, int):
                value = int(value)
            elif isinstance(default_value, float):
                value = float(value)

            # Set setting
            self.set_setting(key, value, emit_signal=False)

    def _save_settings(self):
        """Save settings."""
        # Save settings to QSettings
        for key, value in self.default_settings.items():
            self.settings.setValue(key, value)

    def get_setting(self, key, default=None):
        """Get a setting."""
        # Check if key exists
        if key in self.default_settings:
            return self.default_settings[key]

        # Return default value
        return default

    def set_setting(self, key, value, emit_signal=True):
        """Set a setting."""
        # Set setting
        self.default_settings[key] = value

        # Save setting
        self.settings.setValue(key, value)

        # Emit signal
        if emit_signal:
            self.setting_changed.emit(key, value)

        return True

    def reset_setting(self, key):
        """Reset a setting to its default value."""
        # Check if key exists
        if key in self.default_settings:
            # Get default value
            default_value = self.default_settings[key]

            # Set setting
            self.set_setting(key, default_value)

            return True

        return False

    def reset_all_settings(self):
        """Reset all settings to their default values."""
        # Reset all settings
        for key in self.default_settings:
            self.reset_setting(key)

        return True
</file>

<file path="src/core/bookmarks.py">
#!/usr/bin/env python3
# NebulaFusion Browser - Bookmarks Manager

import os
import sys
import json
import sqlite3
import time
from PyQt6.QtCore import QObject, pyqtSignal, QUrl

class BookmarksManager(QObject):
    """
    Manager for browser bookmarks.
    Handles storing, retrieving, and managing bookmarks.
    """
    
    # Signals
    bookmark_added = pyqtSignal(str, str, str)  # url, title, folder
    bookmark_removed = pyqtSignal(str, str)  # url, folder
    bookmark_updated = pyqtSignal(str, str, str, str)  # old_url, new_url, new_title, new_folder
    folder_added = pyqtSignal(str)  # folder_name
    folder_removed = pyqtSignal(str)  # folder_name
    folder_renamed = pyqtSignal(str, str)  # old_name, new_name
    bookmarks_imported = pyqtSignal()
    bookmarks_exported = pyqtSignal()
    
    def __init__(self, app_controller):
        """Initialize the bookmarks manager."""
        super().__init__()
        self.app_controller = app_controller
        
        # Database connection
        self.db_conn = None
        
        # Default folders
        self.default_folders = [
            "Bookmarks Bar",
            "Other Bookmarks",
            "Mobile Bookmarks"
        ]
        
        # Initialize bookmarks
        self.initialized = False
    
    def initialize(self):
        """Initialize the bookmarks manager."""
        self.app_controller.logger.info("Initializing bookmarks manager...")
        
        # Create bookmarks directory
        bookmarks_dir = os.path.expanduser("~/.nebulafusion/bookmarks")
        os.makedirs(bookmarks_dir, exist_ok=True)
        
        # Connect to database
        db_path = os.path.join(bookmarks_dir, "bookmarks.db")
        self.db_conn = sqlite3.connect(db_path)
        
        # Create tables
        self._create_tables()
        
        # Create default folders
        self._create_default_folders()
        
        # Update state
        self.initialized = True
        
        self.app_controller.logger.info("Bookmarks manager initialized.")
        
        return True
    
    def cleanup(self):
        """Clean up the bookmarks manager."""
        self.app_controller.logger.info("Cleaning up bookmarks manager...")
        
        # Close database connection
        if self.db_conn:
            self.db_conn.close()
            self.db_conn = None
        
        # Update state
        self.initialized = False
        
        self.app_controller.logger.info("Bookmarks manager cleaned up.")
        
        return True
    
    def _create_tables(self):
        """Create database tables."""
        # Create cursor
        cursor = self.db_conn.cursor()
        
        # Create folders table
        cursor.execute("""
        CREATE TABLE IF NOT EXISTS folders (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT UNIQUE,
            created_at INTEGER,
            updated_at INTEGER
        )
        """)
        
        # Create bookmarks table
        cursor.execute("""
        CREATE TABLE IF NOT EXISTS bookmarks (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            url TEXT,
            title TEXT,
            folder_id INTEGER,
            created_at INTEGER,
            updated_at INTEGER,
            FOREIGN KEY (folder_id) REFERENCES folders (id),
            UNIQUE (url, folder_id)
        )
        """)
        
        # Commit changes
        self.db_conn.commit()
    
    def _create_default_folders(self):
        """Create default folders."""
        # Create cursor
        cursor = self.db_conn.cursor()
        
        # Get current time
        current_time = int(time.time())
        
        # Create default folders
        for folder_name in self.default_folders:
            cursor.execute("""
            INSERT OR IGNORE INTO folders (name, created_at, updated_at)
            VALUES (?, ?, ?)
            """, (folder_name, current_time, current_time))
        
        # Commit changes
        self.db_conn.commit()
    
    def add_bookmark(self, url, title, folder="Bookmarks Bar"):
        """Add a bookmark."""
        try:
            # Create cursor
            cursor = self.db_conn.cursor()
            
            # Get current time
            current_time = int(time.time())
            
            # Get folder ID
            cursor.execute("""
            SELECT id FROM folders WHERE name = ?
            """, (folder,))
            
            folder_id = cursor.fetchone()
            
            if not folder_id:
                # Create folder
                self.add_folder(folder)
                
                # Get folder ID
                cursor.execute("""
                SELECT id FROM folders WHERE name = ?
                """, (folder,))
                
                folder_id = cursor.fetchone()
            
            folder_id = folder_id[0]
            
            # Add bookmark
            cursor.execute("""
            INSERT OR REPLACE INTO bookmarks (url, title, folder_id, created_at, updated_at)
            VALUES (?, ?, ?, ?, ?)
            """, (url, title, folder_id, current_time, current_time))
            
            # Commit changes
            self.db_conn.commit()
            
            # Emit signal
            self.bookmark_added.emit(url, title, folder)
            
            # Trigger hook
            self.app_controller.hook_registry.trigger_hook("onBookmarkAdded", url, title, folder)
            
            self.app_controller.logger.info(f"Bookmark added: {url} in {folder}")
            
            return True
        
        except Exception as e:
            self.app_controller.logger.error(f"Error adding bookmark: {e}")
            return False
    
    def remove_bookmark(self, url, folder=None):
        """Remove a bookmark."""
        try:
            # Create cursor
            cursor = self.db_conn.cursor()
            
            if folder:
                # Get folder ID
                cursor.execute("""
                SELECT id FROM folders WHERE name = ?
                """, (folder,))
                
                folder_id = cursor.fetchone()
                
                if not folder_id:
                    self.app_controller.logger.warning(f"Folder not found: {folder}")
                    return False
                
                folder_id = folder_id[0]
                
                # Remove bookmark
                cursor.execute("""
                DELETE FROM bookmarks WHERE url = ? AND folder_id = ?
                """, (url, folder_id))
            else:
                # Remove bookmark from all folders
                cursor.execute("""
                DELETE FROM bookmarks WHERE url = ?
                """, (url,))
            
            # Commit changes
            self.db_conn.commit()
            
            # Emit signal
            self.bookmark_removed.emit(url, folder or "all")
            
            # Trigger hook
            self.app_controller.hook_registry.trigger_hook("onBookmarkRemoved", url, folder)
            
            self.app_controller.logger.info(f"Bookmark removed: {url} from {folder or 'all'}")
            
            return True
        
        except Exception as e:
            self.app_controller.logger.error(f"Error removing bookmark: {e}")
            return False
    
    def update_bookmark(self, url, new_url=None, new_title=None, new_folder=None):
        """Update a bookmark."""
        try:
            # Create cursor
            cursor = self.db_conn.cursor()
            
            # Get current time
            current_time = int(time.time())
            
            # Get bookmark
            cursor.execute("""
            SELECT b.id, b.title, f.name
            FROM bookmarks b
            JOIN folders f ON b.folder_id = f.id
            WHERE b.url = ?
            """, (url,))
            
            bookmark = cursor.fetchone()
            
            if not bookmark:
                self.app_controller.logger.warning(f"Bookmark not found: {url}")
                return False
            
            bookmark_id, title, folder = bookmark
            
            # Update bookmark
            if new_folder and new_folder != folder:
                # Get new folder ID
                cursor.execute("""
                SELECT id FROM folders WHERE name = ?
                """, (new_folder,))
                
                new_folder_id = cursor.fetchone()
                
                if not new_folder_id:
                    # Create folder
                    self.add_folder(new_folder)
                    
                    # Get folder ID
                    cursor.execute("""
                    SELECT id FROM folders WHERE name = ?
                    """, (new_folder,))
                    
                    new_folder_id = cursor.fetchone()
                
                new_folder_id = new_folder_id[0]
                
                # Update bookmark
                cursor.execute("""
                UPDATE bookmarks
                SET url = ?, title = ?, folder_id = ?, updated_at = ?
                WHERE id = ?
                """, (new_url or url, new_title or title, new_folder_id, current_time, bookmark_id))
            else:
                # Update bookmark
                cursor.execute("""
                UPDATE bookmarks
                SET url = ?, title = ?, updated_at = ?
                WHERE id = ?
                """, (new_url or url, new_title or title, current_time, bookmark_id))
            
            # Commit changes
            self.db_conn.commit()
            
            # Emit signal
            self.bookmark_updated.emit(url, new_url or url, new_title or title, new_folder or folder)
            
            # Trigger hook
            self.app_controller.hook_registry.trigger_hook("onBookmarkUpdated", url, new_url or url, new_title or title, new_folder or folder)
            
            self.app_controller.logger.info(f"Bookmark updated: {url} to {new_url or url}")
            
            return True
        
        except Exception as e:
            self.app_controller.logger.error(f"Error updating bookmark: {e}")
            return False
    
    def add_folder(self, folder_name):
        """Add a bookmark folder."""
        try:
            # Create cursor
            cursor = self.db_conn.cursor()
            
            # Get current time
            current_time = int(time.time())
            
            # Add folder
            cursor.execute("""
            INSERT OR IGNORE INTO folders (name, created_at, updated_at)
            VALUES (?, ?, ?)
            """, (folder_name, current_time, current_time))
            
            # Commit changes
            self.db_conn.commit()
            
            # Emit signal
            self.folder_added.emit(folder_name)
            
            # Trigger hook
            self.app_controller.hook_registry.trigger_hook("onBookmarkFolderAdded", folder_name)
            
            self.app_controller.logger.info(f"Bookmark folder added: {folder_name}")
            
            return True
        
        except Exception as e:
            self.app_controller.logger.error(f"Error adding bookmark folder: {e}")
            return False
    
    def remove_folder(self, folder_name):
        """Remove a bookmark folder."""
        try:
            # Check if folder is a default folder
            if folder_name in self.default_folders:
                self.app_controller.logger.warning(f"Cannot remove default folder: {folder_name}")
                return False
            
            # Create cursor
            cursor = self.db_conn.cursor()
            
            # Get folder ID
            cursor.execute("""
            SELECT id FROM folders WHERE name = ?
            """, (folder_name,))
            
            folder_id = cursor.fetchone()
            
            if not folder_id:
                self.app_controller.logger.warning(f"Folder not found: {folder_name}")
                return False
            
            folder_id = folder_id[0]
            
            # Remove bookmarks in folder
            cursor.execute("""
            DELETE FROM bookmarks WHERE folder_id = ?
            """, (folder_id,))
            
            # Remove folder
            cursor.execute("""
            DELETE FROM folders WHERE id = ?
            """, (folder_id,))
            
            # Commit changes
            self.db_conn.commit()
            
            # Emit signal
            self.folder_removed.emit(folder_name)
            
            # Trigger hook
            self.app_controller.hook_registry.trigger_hook("onBookmarkFolderRemoved", folder_name)
            
            self.app_controller.logger.info(f"Bookmark folder removed: {folder_name}")
            
            return True
        
        except Exception as e:
            self.app_controller.logger.error(f"Error removing bookmark folder: {e}")
            return False
    
    def rename_folder(self, old_name, new_name):
        """Rename a bookmark folder."""
        try:
            # Check if folder is a default folder
            if old_name in self.default_folders:
                self.app_controller.logger.warning(f"Cannot rename default folder: {old_name}")
                return False
            
            # Create cursor
            cursor = self.db_conn.cursor()
            
            # Get current time
            current_time = int(time.time())
            
            # Rename folder
            cursor.execute("""
            UPDATE folders
            SET name = ?, updated_at = ?
            WHERE name = ?
            """, (new_name, current_time, old_name))
            
            # Commit changes
            self.db_conn.commit()
            
            # Emit signal
            self.folder_renamed.emit(old_name, new_name)
            
            # Trigger hook
            self.app_controller.hook_registry.trigger_hook("onBookmarkFolderRenamed", old_name, new_name)
            
            self.app_controller.logger.info(f"Bookmark folder renamed: {old_name} to {new_name}")
            
            return True
        
        except Exception as e:
            self.app_controller.logger.error(f"Error renaming bookmark folder: {e}")
            return False
    
    def get_bookmarks(self, folder=None):
        """Get bookmarks."""
        try:
            # Create cursor
            cursor = self.db_conn.cursor()
            
            if folder:
                # Get folder ID
                cursor.execute("""
                SELECT id FROM folders WHERE name = ?
                """, (folder,))
                
                folder_id = cursor.fetchone()
                
                if not folder_id:
                    self.app_controller.logger.warning(f"Folder not found: {folder}")
                    return []
                
                folder_id = folder_id[0]
                
                # Get bookmarks
                cursor.execute("""
                SELECT b.url, b.title, f.name, b.created_at, b.updated_at
                FROM bookmarks b
                JOIN folders f ON b.folder_id = f.id
                WHERE b.folder_id = ?
                ORDER BY b.title
                """, (folder_id,))
            else:
                # Get all bookmarks
                cursor.execute("""
                SELECT b.url, b.title, f.name, b.created_at, b.updated_at
                FROM bookmarks b
                JOIN folders f ON b.folder_id = f.id
                ORDER BY f.name, b.title
                """)
            
            # Convert to list of dictionaries
            bookmarks = []
            for row in cursor.fetchall():
                url, title, folder_name, created_at, updated_at = row
                bookmarks.append({
                    "url": url,
                    "title": title,
                    "folder": folder_name,
                    "created_at": created_at,
                    "updated_at": updated_at
                })
            
            return bookmarks
        
        except Exception as e:
            self.app_controller.logger.error(f"Error getting bookmarks: {e}")
            return []
    
    def get_folders(self):
        """Get bookmark folders."""
        try:
            # Create cursor
            cursor = self.db_conn.cursor()
            
            # Get folders
            cursor.execute("""
            SELECT name FROM folders ORDER BY name
            """)
            
            # Convert to list
            folders = [row[0] for row in cursor.fetchall()]
            
            return folders
        
        except Exception as e:
            self.app_controller.logger.error(f"Error getting bookmark folders: {e}")
            return []
    
    def search_bookmarks(self, query):
        """Search bookmarks."""
        try:
            # Create cursor
            cursor = self.db_conn.cursor()
            
            # Search bookmarks
            cursor.execute("""
            SELECT b.url, b.title, f.name, b.created_at, b.updated_at
            FROM bookmarks b
            JOIN folders f ON b.folder_id = f.id
            WHERE b.url LIKE ? OR b.title LIKE ?
            ORDER BY f.name, b.title
            """, (f"%{query}%", f"%{query}%"))
            
            # Convert to list of dictionaries
            bookmarks = []
            for row in cursor.fetchall():
                url, title, folder_name, created_at, updated_at = row
                bookmarks.append({
                    "url": url,
                    "title": title,
                    "folder": folder_name,
                    "created_at": created_at,
                    "updated_at": updated_at
                })
            
            return bookmarks
        
        except Exception as e:
            self.app_controller.logger.error(f"Error searching bookmarks: {e}")
            return []
    
    def import_bookmarks(self, file_path):
        """Import bookmarks from a file."""
        try:
            # Check file extension
            if file_path.endswith(".json"):
                # Import from JSON
                with open(file_path, "r") as f:
                    data = json.load(f)
                
                # Check if data is valid
                if not isinstance(data, list):
                    self.app_controller.logger.error("Invalid bookmarks file format")
                    return False
                
                # Import bookmarks
                for bookmark in data:
                    if "url" in bookmark and "title" in bookmark:
                        folder = bookmark.get("folder", "Imported Bookmarks")
                        self.add_bookmark(bookmark["url"], bookmark["title"], folder)
            
            elif file_path.endswith(".html") or file_path.endswith(".htm"):
                # Import from HTML
                with open(file_path, "r") as f:
                    content = f.read()
                
                # Parse HTML
                import re
                
                # Find all links
                links = re.findall(r'<A HREF="([^"]+)"[^>]*>([^<]+)</A>', content)
                
                # Import bookmarks
                for url, title in links:
                    self.add_bookmark(url, title, "Imported Bookmarks")
            
            else:
                self.app_controller.logger.error("Unsupported bookmarks file format")
                return False
            
            # Emit signal
            self.bookmarks_imported.emit()
            
            # Trigger hook
            self.app_controller.hook_registry.trigger_hook("onBookmarksImported")
            
            self.app_controller.logger.info(f"Bookmarks imported from {file_path}")
            
            return True
        
        except Exception as e:
            self.app_controller.logger.error(f"Error importing bookmarks: {e}")
            return False
    
    def export_bookmarks(self, file_path):
        """Export bookmarks to a file."""
        try:
            # Get all bookmarks
            bookmarks = self.get_bookmarks()
            
            # Check file extension
            if file_path.endswith(".json"):
                # Export to JSON
                with open(file_path, "w") as f:
                    json.dump(bookmarks, f, indent=4)
            
            elif file_path.endswith(".html") or file_path.endswith(".htm"):
                # Export to HTML
                with open(file_path, "w") as f:
                    f.write('<!DOCTYPE NETSCAPE-Bookmark-file-1>\n')
                    f.write('<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8">\n')
                    f.write('<TITLE>Bookmarks</TITLE>\n')
                    f.write('<H1>Bookmarks</H1>\n')
                    f.write('<DL><p>\n')
                    
                    # Group bookmarks by folder
                    folders = {}
                    for bookmark in bookmarks:
                        folder = bookmark["folder"]
                        if folder not in folders:
                            folders[folder] = []
                        folders[folder].append(bookmark)
                    
                    # Write folders
                    for folder, folder_bookmarks in folders.items():
                        f.write(f'    <DT><H3>{folder}</H3>\n')
                        f.write('    <DL><p>\n')
                        
                        # Write bookmarks
                        for bookmark in folder_bookmarks:
                            f.write(f'        <DT><A HREF="{bookmark["url"]}">{bookmark["title"]}</A>\n')
                        
                        f.write('    </DL><p>\n')
                    
                    f.write('</DL><p>\n')
            
            else:
                self.app_controller.logger.error("Unsupported bookmarks file format")
                return False
            
            # Emit signal
            self.bookmarks_exported.emit()
            
            # Trigger hook
            self.app_controller.hook_registry.trigger_hook("onBookmarksExported")
            
            self.app_controller.logger.info(f"Bookmarks exported to {file_path}")
            
            return True
        
        except Exception as e:
            self.app_controller.logger.error(f"Error exporting bookmarks: {e}")
            return False
    
    def is_bookmarked(self, url, folder=None):
        """Check if a URL is bookmarked."""
        try:
            # Create cursor
            cursor = self.db_conn.cursor()
            
            if folder:
                # Get folder ID
                cursor.execute("""
                SELECT id FROM folders WHERE name = ?
                """, (folder,))
                
                folder_id = cursor.fetchone()
                
                if not folder_id:
                    return False
                
                folder_id = folder_id[0]
                
                # Check if URL is bookmarked
                cursor.execute("""
                SELECT COUNT(*) FROM bookmarks WHERE url = ? AND folder_id = ?
                """, (url, folder_id))
            else:
                # Check if URL is bookmarked in any folder
                cursor.execute("""
                SELECT COUNT(*) FROM bookmarks WHERE url = ?
                """, (url,))
            
            # Get result
            count = cursor.fetchone()[0]
            
            return count > 0
        
        except Exception as e:
            self.app_controller.logger.error(f"Error checking if URL is bookmarked: {e}")
            return False
</file>

<file path="src/core/content_security.py">
#!/usr/bin/env python3
# NebulaFusion Browser - Content Security Manager

import os
import sys
import logging
from PyQt6.QtCore import QObject, pyqtSignal, QUrl

class ContentSecurityManager(QObject):
    """
    Manager for content security policies and protections.
    Handles content security policies, safe browsing, and content filtering.
    """
    
    # Signals
    threat_detected = pyqtSignal(str, str)  # url, threat_type
    content_blocked = pyqtSignal(str, str)  # url, reason
    
    def __init__(self, app_controller):
        """Initialize the content security manager."""
        super().__init__()
        self.app_controller = app_controller
        
        # Blocklists
        self.malware_domains = set()
        self.phishing_domains = set()
        self.ad_domains = set()
        self.tracker_domains = set()
        
        # Content filters
        self.content_filters = {}
        
        # Initialize content security
        self.initialized = False
    
    def initialize(self):
        """Initialize the content security manager."""
        self.app_controller.logger.info("Initializing content security manager...")
        
        # Load blocklists
        self._load_blocklists()
        
        # Register default content filters
        self._register_default_filters()
        
        # Update state
        self.initialized = True
        
        self.app_controller.logger.info("Content security manager initialized.")
        
        return True
    
    def cleanup(self):
        """Clean up the content security manager."""
        self.app_controller.logger.info("Cleaning up content security manager...")
        
        # Clear blocklists
        self.malware_domains.clear()
        self.phishing_domains.clear()
        self.ad_domains.clear()
        self.tracker_domains.clear()
        
        # Clear content filters
        self.content_filters.clear()
        
        # Update state
        self.initialized = False
        
        self.app_controller.logger.info("Content security manager cleaned up.")
        
        return True
    
    def _load_blocklists(self):
        """Load blocklists."""
        try:
            # Create blocklists directory
            blocklists_dir = os.path.expanduser("~/.nebulafusion/blocklists")
            os.makedirs(blocklists_dir, exist_ok=True)
            
            # Load malware domains
            malware_path = os.path.join(blocklists_dir, "malware.txt")
            if os.path.exists(malware_path):
                with open(malware_path, "r") as f:
                    self.malware_domains = set(line.strip() for line in f if line.strip())
            
            # Load phishing domains
            phishing_path = os.path.join(blocklists_dir, "phishing.txt")
            if os.path.exists(phishing_path):
                with open(phishing_path, "r") as f:
                    self.phishing_domains = set(line.strip() for line in f if line.strip())
            
            # Load ad domains
            ad_path = os.path.join(blocklists_dir, "ads.txt")
            if os.path.exists(ad_path):
                with open(ad_path, "r") as f:
                    self.ad_domains = set(line.strip() for line in f if line.strip())
            
            # Load tracker domains
            tracker_path = os.path.join(blocklists_dir, "trackers.txt")
            if os.path.exists(tracker_path):
                with open(tracker_path, "r") as f:
                    self.tracker_domains = set(line.strip() for line in f if line.strip())
            
            self.app_controller.logger.info(f"Loaded blocklists: {len(self.malware_domains)} malware, {len(self.phishing_domains)} phishing, {len(self.ad_domains)} ads, {len(self.tracker_domains)} trackers")
        
        except Exception as e:
            self.app_controller.logger.error(f"Error loading blocklists: {e}")
    
    def _register_default_filters(self):
        """Register default content filters."""
        # Register malware filter
        self.register_content_filter("malware", self._filter_malware)
        
        # Register phishing filter
        self.register_content_filter("phishing", self._filter_phishing)
        
        # Register ad filter
        self.register_content_filter("ads", self._filter_ads)
        
        # Register tracker filter
        self.register_content_filter("trackers", self._filter_trackers)
    
    def register_content_filter(self, filter_id, filter_func):
        """Register a content filter."""
        self.content_filters[filter_id] = filter_func
        self.app_controller.logger.info(f"Registered content filter: {filter_id}")
        return True
    
    def unregister_content_filter(self, filter_id):
        """Unregister a content filter."""
        if filter_id in self.content_filters:
            del self.content_filters[filter_id]
            self.app_controller.logger.info(f"Unregistered content filter: {filter_id}")
            return True
        return False
    
    def check_url(self, url):
        """Check if a URL is safe."""
        # Get URL domain
        domain = self._get_domain(url)
        
        # Check all filters
        for filter_id, filter_func in self.content_filters.items():
            result = filter_func(url, domain)
            if result:
                return False, filter_id
        
        return True, None
    
    def _filter_malware(self, url, domain):
        """Filter malware domains."""
        if domain in self.malware_domains:
            self.threat_detected.emit(url, "malware")
            self.app_controller.hook_registry.trigger_hook("onThreatDetected", url, "malware")
            self.app_controller.logger.warning(f"Malware detected: {url}")
            return True
        return False
    
    def _filter_phishing(self, url, domain):
        """Filter phishing domains."""
        if domain in self.phishing_domains:
            self.threat_detected.emit(url, "phishing")
            self.app_controller.hook_registry.trigger_hook("onThreatDetected", url, "phishing")
            self.app_controller.logger.warning(f"Phishing detected: {url}")
            return True
        return False
    
    def _filter_ads(self, url, domain):
        """Filter ad domains."""
        if domain in self.ad_domains:
            self.content_blocked.emit(url, "ad")
            self.app_controller.hook_registry.trigger_hook("onContentBlocked", url, "ad")
            self.app_controller.logger.info(f"Ad blocked: {url}")
            return True
        return False
    
    def _filter_trackers(self, url, domain):
        """Filter tracker domains."""
        if domain in self.tracker_domains:
            self.content_blocked.emit(url, "tracker")
            self.app_controller.hook_registry.trigger_hook("onContentBlocked", url, "tracker")
            self.app_controller.logger.info(f"Tracker blocked: {url}")
            return True
        return False
    
    def _get_domain(self, url):
        """Get domain from URL."""
        try:
            # Parse URL
            qurl = QUrl(url)
            
            # Get domain
            domain = qurl.host()
            
            # Remove www prefix
            if domain.startswith("www."):
                domain = domain[4:]
            
            return domain
        
        except Exception as e:
            self.app_controller.logger.error(f"Error getting domain from URL: {e}")
            return ""
    
    def add_to_blocklist(self, domain, blocklist_type):
        """Add a domain to a blocklist."""
        try:
            # Check blocklist type
            if blocklist_type == "malware":
                self.malware_domains.add(domain)
            elif blocklist_type == "phishing":
                self.phishing_domains.add(domain)
            elif blocklist_type == "ads":
                self.ad_domains.add(domain)
            elif blocklist_type == "trackers":
                self.tracker_domains.add(domain)
            else:
                self.app_controller.logger.warning(f"Unknown blocklist type: {blocklist_type}")
                return False
            
            # Save blocklist
            self._save_blocklist(blocklist_type)
            
            self.app_controller.logger.info(f"Added {domain} to {blocklist_type} blocklist")
            
            return True
        
        except Exception as e:
            self.app_controller.logger.error(f"Error adding to blocklist: {e}")
            return False
    
    def remove_from_blocklist(self, domain, blocklist_type):
        """Remove a domain from a blocklist."""
        try:
            # Check blocklist type
            if blocklist_type == "malware":
                self.malware_domains.discard(domain)
            elif blocklist_type == "phishing":
                self.phishing_domains.discard(domain)
            elif blocklist_type == "ads":
                self.ad_domains.discard(domain)
            elif blocklist_type == "trackers":
                self.tracker_domains.discard(domain)
            else:
                self.app_controller.logger.warning(f"Unknown blocklist type: {blocklist_type}")
                return False
            
            # Save blocklist
            self._save_blocklist(blocklist_type)
            
            self.app_controller.logger.info(f"Removed {domain} from {blocklist_type} blocklist")
            
            return True
        
        except Exception as e:
            self.app_controller.logger.error(f"Error removing from blocklist: {e}")
            return False
    
    def _save_blocklist(self, blocklist_type):
        """Save a blocklist."""
        try:
            # Create blocklists directory
            blocklists_dir = os.path.expanduser("~/.nebulafusion/blocklists")
            os.makedirs(blocklists_dir, exist_ok=True)
            
            # Get blocklist
            if blocklist_type == "malware":
                blocklist = self.malware_domains
                filename = "malware.txt"
            elif blocklist_type == "phishing":
                blocklist = self.phishing_domains
                filename = "phishing.txt"
            elif blocklist_type == "ads":
                blocklist = self.ad_domains
                filename = "ads.txt"
            elif blocklist_type == "trackers":
                blocklist = self.tracker_domains
                filename = "trackers.txt"
            else:
                self.app_controller.logger.warning(f"Unknown blocklist type: {blocklist_type}")
                return False
            
            # Save blocklist
            path = os.path.join(blocklists_dir, filename)
            with open(path, "w") as f:
                for domain in sorted(blocklist):
                    f.write(f"{domain}\n")
            
            return True
        
        except Exception as e:
            self.app_controller.logger.error(f"Error saving blocklist: {e}")
            return False
    
    def import_blocklist(self, file_path, blocklist_type):
        """Import a blocklist from a file."""
        try:
            # Check if file exists
            if not os.path.exists(file_path):
                self.app_controller.logger.warning(f"File not found: {file_path}")
                return False
            
            # Read domains
            with open(file_path, "r") as f:
                domains = set(line.strip() for line in f if line.strip())
            
            # Add domains to blocklist
            for domain in domains:
                self.add_to_blocklist(domain, blocklist_type)
            
            self.app_controller.logger.info(f"Imported {len(domains)} domains to {blocklist_type} blocklist")
            
            return True
        
        except Exception as e:
            self.app_controller.logger.error(f"Error importing blocklist: {e}")
            return False
    
    def export_blocklist(self, file_path, blocklist_type):
        """Export a blocklist to a file."""
        try:
            # Get blocklist
            if blocklist_type == "malware":
                blocklist = self.malware_domains
            elif blocklist_type == "phishing":
                blocklist = self.phishing_domains
            elif blocklist_type == "ads":
                blocklist = self.ad_domains
            elif blocklist_type == "trackers":
                blocklist = self.tracker_domains
            else:
                self.app_controller.logger.warning(f"Unknown blocklist type: {blocklist_type}")
                return False
            
            # Create directory
            os.makedirs(os.path.dirname(file_path), exist_ok=True)
            
            # Save blocklist
            with open(file_path, "w") as f:
                for domain in sorted(blocklist):
                    f.write(f"{domain}\n")
            
            self.app_controller.logger.info(f"Exported {len(blocklist)} domains from {blocklist_type} blocklist")
            
            return True
        
        except Exception as e:
            self.app_controller.logger.error(f"Error exporting blocklist: {e}")
            return False
    
    def clear_blocklist(self, blocklist_type):
        """Clear a blocklist."""
        try:
            # Check blocklist type
            if blocklist_type == "malware":
                self.malware_domains.clear()
            elif blocklist_type == "phishing":
                self.phishing_domains.clear()
            elif blocklist_type == "ads":
                self.ad_domains.clear()
            elif blocklist_type == "trackers":
                self.tracker_domains.clear()
            else:
                self.app_controller.logger.warning(f"Unknown blocklist type: {blocklist_type}")
                return False
            
            # Save blocklist
            self._save_blocklist(blocklist_type)
            
            self.app_controller.logger.info(f"Cleared {blocklist_type} blocklist")
            
            return True
        
        except Exception as e:
            self.app_controller.logger.error(f"Error clearing blocklist: {e}")
            return False
</file>

<file path="src/core/cookies.py">
#!/usr/bin/env python3
# NebulaFusion Browser - Cookies Manager

import os
import sys
import json
import sqlite3
import time
from PyQt6.QtCore import QObject, pyqtSignal, QUrl
from PyQt6.QtWebEngineCore import QWebEngineCookieStore

class CookiesManager(QObject):
    """
    Manager for browser cookies.
    Handles storing, retrieving, and managing cookies.
    """
    
    # Signals
    cookies_cleared = pyqtSignal()
    
    def __init__(self, app_controller):
        """Initialize the cookies manager."""
        super().__init__()
        self.app_controller = app_controller
        
        # Cookie stores
        self.cookie_stores = {}
        
        # Initialize cookies
        self.initialized = False
    
    def initialize(self):
        """Initialize the cookies manager."""
        self.app_controller.logger.info("Initializing cookies manager...")
        
        # Get default profile cookie store
        default_profile = self.app_controller.web_engine_manager.get_default_profile()
        self.cookie_stores["default"] = default_profile.cookieStore()
        
        # Get private profile cookie store
        private_profile = self.app_controller.web_engine_manager.get_private_profile()
        self.cookie_stores["private"] = private_profile.cookieStore()
        
        # Connect signals
        self._connect_signals()
        
        # Update state
        self.initialized = True
        
        self.app_controller.logger.info("Cookies manager initialized.")
        
        return True
    
    def cleanup(self):
        """Clean up the cookies manager."""
        self.app_controller.logger.info("Cleaning up cookies manager...")
        
        # Disconnect signals
        self._disconnect_signals()
        
        # Clear cookie stores
        self.cookie_stores.clear()
        
        # Update state
        self.initialized = False
        
        self.app_controller.logger.info("Cookies manager cleaned up.")
        
        return True
    
    def _connect_signals(self):
        """Connect signals."""
        # Connect default cookie store signals
        default_store = self.cookie_stores.get("default")
        if default_store:
            default_store.cookieAdded.connect(self._on_cookie_added)
            default_store.cookieRemoved.connect(self._on_cookie_removed)
        
        # Connect private cookie store signals
        private_store = self.cookie_stores.get("private")
        if private_store:
            private_store.cookieAdded.connect(self._on_cookie_added)
            private_store.cookieRemoved.connect(self._on_cookie_removed)
    
    def _disconnect_signals(self):
        """Disconnect signals."""
        # Disconnect default cookie store signals
        default_store = self.cookie_stores.get("default")
        if default_store:
            try:
                default_store.cookieAdded.disconnect(self._on_cookie_added)
                default_store.cookieRemoved.disconnect(self._on_cookie_removed)
            except:
                pass
        
        # Disconnect private cookie store signals
        private_store = self.cookie_stores.get("private")
        if private_store:
            try:
                private_store.cookieAdded.disconnect(self._on_cookie_added)
                private_store.cookieRemoved.disconnect(self._on_cookie_removed)
            except:
                pass
    
    def _on_cookie_added(self, cookie):
        """Handle cookie added event."""
        # Trigger hook
        self.app_controller.hook_registry.trigger_hook("onCookieAdded", cookie)
    
    def _on_cookie_removed(self, cookie):
        """Handle cookie removed event."""
        # Trigger hook
        self.app_controller.hook_registry.trigger_hook("onCookieRemoved", cookie)
    
    def clear_cookies(self, profile_name="default"):
        """Clear all cookies."""
        try:
            # Get cookie store
            cookie_store = self.cookie_stores.get(profile_name)
            if not cookie_store:
                self.app_controller.logger.warning(f"Cookie store not found: {profile_name}")
                return False
            
            # Clear cookies
            cookie_store.deleteAllCookies()
            
            # Emit signal
            self.cookies_cleared.emit()
            
            # Trigger hook
            self.app_controller.hook_registry.trigger_hook("onCookiesCleared", profile_name)
            
            self.app_controller.logger.info(f"Cookies cleared for profile: {profile_name}")
            
            return True
        
        except Exception as e:
            self.app_controller.logger.error(f"Error clearing cookies: {e}")
            return False
    
    def set_cookie_filter(self, filter_func, profile_name="default"):
        """Set cookie filter."""
        try:
            # Get cookie store
            cookie_store = self.cookie_stores.get(profile_name)
            if not cookie_store:
                self.app_controller.logger.warning(f"Cookie store not found: {profile_name}")
                return False
            
            # Set cookie filter
            cookie_store.setCookieFilter(filter_func)
            
            # Trigger hook
            self.app_controller.hook_registry.trigger_hook("onCookieFilterSet", profile_name)
            
            self.app_controller.logger.info(f"Cookie filter set for profile: {profile_name}")
            
            return True
        
        except Exception as e:
            self.app_controller.logger.error(f"Error setting cookie filter: {e}")
            return False
    
    def block_third_party_cookies(self, block=True, profile_name="default"):
        """Block third-party cookies."""
        try:
            # Get cookie store
            cookie_store = self.cookie_stores.get(profile_name)
            if not cookie_store:
                self.app_controller.logger.warning(f"Cookie store not found: {profile_name}")
                return False
            
            # Set cookie filter
            if block:
                def filter_func(cookie, url):
                    # Allow first-party cookies
                    cookie_domain = cookie.domain()
                    url_domain = url.host()
                    
                    # Remove leading dot from cookie domain
                    if cookie_domain.startswith("."):
                        cookie_domain = cookie_domain[1:]
                    
                    # Check if cookie domain is a subdomain of URL domain
                    return url_domain.endswith(cookie_domain)
                
                cookie_store.setCookieFilter(filter_func)
            else:
                # Allow all cookies
                cookie_store.setCookieFilter(lambda cookie, url: True)
            
            # Trigger hook
            self.app_controller.hook_registry.trigger_hook("onThirdPartyCookiesBlocked", block, profile_name)
            
            self.app_controller.logger.info(f"Third-party cookies {'blocked' if block else 'allowed'} for profile: {profile_name}")
            
            return True
        
        except Exception as e:
            self.app_controller.logger.error(f"Error blocking third-party cookies: {e}")
            return False
    
    def export_cookies(self, file_path, profile_name="default"):
        """Export cookies to a file."""
        try:
            # Get cookie store
            cookie_store = self.cookie_stores.get(profile_name)
            if not cookie_store:
                self.app_controller.logger.warning(f"Cookie store not found: {profile_name}")
                return False
            
            # Create cookies directory
            cookies_dir = os.path.dirname(file_path)
            os.makedirs(cookies_dir, exist_ok=True)
            
            # Export cookies
            # Note: PyQt6 doesn't provide direct access to cookies
            # This is a placeholder for future implementation
            
            # Trigger hook
            self.app_controller.hook_registry.trigger_hook("onCookiesExported", profile_name, file_path)
            
            self.app_controller.logger.info(f"Cookies exported for profile: {profile_name}")
            
            return True
        
        except Exception as e:
            self.app_controller.logger.error(f"Error exporting cookies: {e}")
            return False
    
    def import_cookies(self, file_path, profile_name="default"):
        """Import cookies from a file."""
        try:
            # Get cookie store
            cookie_store = self.cookie_stores.get(profile_name)
            if not cookie_store:
                self.app_controller.logger.warning(f"Cookie store not found: {profile_name}")
                return False
            
            # Import cookies
            # Note: PyQt6 doesn't provide direct access to cookies
            # This is a placeholder for future implementation
            
            # Trigger hook
            self.app_controller.hook_registry.trigger_hook("onCookiesImported", profile_name, file_path)
            
            self.app_controller.logger.info(f"Cookies imported for profile: {profile_name}")
            
            return True
        
        except Exception as e:
            self.app_controller.logger.error(f"Error importing cookies: {e}")
            return False
</file>

<file path="src/core/downloads.py">
#!/usr/bin/env python3
# NebulaFusion Browser - Download Manager

import os
import sys
import json
import sqlite3
import time
from PyQt6.QtCore import QObject, pyqtSignal, QUrl
from PyQt6.QtWebEngineCore import QWebEngineDownloadRequest

class DownloadManager(QObject):
    """
    Manager for browser downloads.
    Handles downloading, tracking, and managing file downloads.
    """
    
    # Signals
    download_started = pyqtSignal(str, str)  # download_id, url
    download_finished = pyqtSignal(str, str)  # download_id, path
    download_failed = pyqtSignal(str, str)  # download_id, error
    download_progress = pyqtSignal(str, int, int)  # download_id, received, total
    download_canceled = pyqtSignal(str)  # download_id
    
    def __init__(self, app_controller):
        """Initialize the download manager."""
        super().__init__()
        self.app_controller = app_controller
        
        # Database connection
        self.db_conn = None
        
        # Active downloads
        self.active_downloads = {}
        
        # Initialize downloads
        self.initialized = False
    
    def initialize(self):
        """Initialize the download manager."""
        self.app_controller.logger.info("Initializing download manager...")
        
        # Create downloads directory
        downloads_dir = os.path.expanduser("~/.nebulafusion/downloads")
        os.makedirs(downloads_dir, exist_ok=True)
        
        # Connect to database
        db_path = os.path.join(downloads_dir, "downloads.db")
        self.db_conn = sqlite3.connect(db_path)
        
        # Create tables
        self._create_tables()
        
        # Update state
        self.initialized = True
        
        self.app_controller.logger.info("Download manager initialized.")
        
        return True
    
    def cleanup(self):
        """Clean up the download manager."""
        self.app_controller.logger.info("Cleaning up download manager...")
        
        # Cancel active downloads
        for download_id in list(self.active_downloads.keys()):
            self.cancel_download(download_id)
        
        # Close database connection
        if self.db_conn:
            self.db_conn.close()
            self.db_conn = None
        
        # Update state
        self.initialized = False
        
        self.app_controller.logger.info("Download manager cleaned up.")
        
        return True
    
    def _create_tables(self):
        """Create database tables."""
        # Create cursor
        cursor = self.db_conn.cursor()
        
        # Create downloads table
        cursor.execute("""
        CREATE TABLE IF NOT EXISTS downloads (
            id TEXT PRIMARY KEY,
            url TEXT,
            path TEXT,
            filename TEXT,
            mime_type TEXT,
            size INTEGER,
            received INTEGER,
            state TEXT,
            start_time INTEGER,
            end_time INTEGER,
            error TEXT
        )
        """)
        
        # Commit changes
        self.db_conn.commit()
    
    def handle_download(self, download):
        """Handle a download request."""
        try:
            # Generate download ID
            download_id = str(int(time.time() * 1000))
            
            # Get download information
            url = download.url().toString()
            suggested_filename = download.suggestedFileName()
            
            # Get download directory
            download_dir = self.app_controller.settings_manager.get_setting("general.download_directory")
            if not download_dir:
                download_dir = os.path.expanduser("~/Downloads")
            
            # Create download directory if it doesn't exist
            os.makedirs(download_dir, exist_ok=True)
            
            # Set download path
            download_path = os.path.join(download_dir, suggested_filename)
            
            # Check if file exists
            if os.path.exists(download_path):
                # Find a unique filename
                base_name, ext = os.path.splitext(suggested_filename)
                i = 1
                while os.path.exists(download_path):
                    new_filename = f"{base_name} ({i}){ext}"
                    download_path = os.path.join(download_dir, new_filename)
                    i += 1
            
            # Set download path
            download.setDownloadDirectory(download_dir)
            download.setDownloadFileName(os.path.basename(download_path))
            
            # Connect signals
            download.isFinishedChanged.connect(lambda: self._on_download_finished(download_id, download))
            download.receivedBytesChanged.connect(lambda: self._on_download_progress(download_id, download))
            download.stateChanged.connect(lambda: self._on_download_state_changed(download_id, download))
            
            # Accept download
            download.accept()
            
            # Store download
            self.active_downloads[download_id] = download
            
            # Add to database
            self._add_download_to_db(
                download_id,
                url,
                download_path,
                os.path.basename(download_path),
                "",  # MIME type
                0,  # Size
                0,  # Received
                "in_progress",
                int(time.time()),
                0,  # End time
                ""  # Error
            )
            
            # Emit signal
            self.download_started.emit(download_id, url)
            
            # Trigger hook
            self.app_controller.hook_registry.trigger_hook("onDownloadStarted", download_id, url, download_path)
            
            self.app_controller.logger.info(f"Download started: {url} to {download_path}")
            
            return download_id
        
        except Exception as e:
            self.app_controller.logger.error(f"Error handling download: {e}")
            return None
    
    def _add_download_to_db(self, download_id, url, path, filename, mime_type, size, received, state, start_time, end_time, error):
        """Add a download to the database."""
        try:
            # Create cursor
            cursor = self.db_conn.cursor()
            
            # Add download
            cursor.execute("""
            INSERT OR REPLACE INTO downloads
            (id, url, path, filename, mime_type, size, received, state, start_time, end_time, error)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """, (download_id, url, path, filename, mime_type, size, received, state, start_time, end_time, error))
            
            # Commit changes
            self.db_conn.commit()
            
            return True
        
        except Exception as e:
            self.app_controller.logger.error(f"Error adding download to database: {e}")
            return False
    
    def _update_download_in_db(self, download_id, **kwargs):
        """Update a download in the database."""
        try:
            # Create cursor
            cursor = self.db_conn.cursor()
            
            # Build update query
            query = "UPDATE downloads SET "
            params = []
            
            for key, value in kwargs.items():
                query += f"{key} = ?, "
                params.append(value)
            
            # Remove trailing comma and space
            query = query[:-2]
            
            # Add where clause
            query += " WHERE id = ?"
            params.append(download_id)
            
            # Update download
            cursor.execute(query, params)
            
            # Commit changes
            self.db_conn.commit()
            
            return True
        
        except Exception as e:
            self.app_controller.logger.error(f"Error updating download in database: {e}")
            return False
    
    def _on_download_finished(self, download_id, download):
        """Handle download finished event."""
        try:
            # Check if download is finished
            if not download.isFinished():
                return
            
            # Get download information
            path = download.downloadDirectory() + "/" + download.downloadFileName()
            
            # Update database
            self._update_download_in_db(
                download_id,
                state="completed" if download.state() == QWebEngineDownloadRequest.DownloadState.DownloadCompleted else "canceled",
                end_time=int(time.time()),
                received=download.receivedBytes(),
                size=download.totalBytes()
            )
            
            # Remove from active downloads
            if download_id in self.active_downloads:
                del self.active_downloads[download_id]
            
            # Emit signal
            self.download_finished.emit(download_id, path)
            
            # Trigger hook
            self.app_controller.hook_registry.trigger_hook("onDownloadFinished", download_id, path)
            
            self.app_controller.logger.info(f"Download finished: {path}")
        
        except Exception as e:
            self.app_controller.logger.error(f"Error handling download finished: {e}")
    
    def _on_download_progress(self, download_id, download):
        """Handle download progress event."""
        try:
            # Get download information
            received = download.receivedBytes()
            total = download.totalBytes()
            
            # Update database
            self._update_download_in_db(
                download_id,
                received=received,
                size=total
            )
            
            # Emit signal
            self.download_progress.emit(download_id, received, total)
            
            # Trigger hook
            self.app_controller.hook_registry.trigger_hook("onDownloadProgress", download_id, received, total)
        
        except Exception as e:
            self.app_controller.logger.error(f"Error handling download progress: {e}")
    
    def _on_download_state_changed(self, download_id, download):
        """Handle download state changed event."""
        try:
            # Get download state
            state = download.state()
            
            # Handle state
            if state == QWebEngineDownloadRequest.DownloadState.DownloadCancelled:
                # Update database
                self._update_download_in_db(
                    download_id,
                    state="canceled",
                    end_time=int(time.time())
                )
                
                # Remove from active downloads
                if download_id in self.active_downloads:
                    del self.active_downloads[download_id]
                
                # Emit signal
                self.download_canceled.emit(download_id)
                
                # Trigger hook
                self.app_controller.hook_registry.trigger_hook("onDownloadCanceled", download_id)
                
                self.app_controller.logger.info(f"Download canceled: {download_id}")
            
            elif state == QWebEngineDownloadRequest.DownloadState.DownloadInterrupted:
                # Get error
                error = "Download interrupted"
                
                # Update database
                self._update_download_in_db(
                    download_id,
                    state="failed",
                    end_time=int(time.time()),
                    error=error
                )
                
                # Remove from active downloads
                if download_id in self.active_downloads:
                    del self.active_downloads[download_id]
                
                # Emit signal
                self.download_failed.emit(download_id, error)
                
                # Trigger hook
                self.app_controller.hook_registry.trigger_hook("onDownloadFailed", download_id, error)
                
                self.app_controller.logger.info(f"Download failed: {download_id} - {error}")
        
        except Exception as e:
            self.app_controller.logger.error(f"Error handling download state changed: {e}")
    
    def cancel_download(self, download_id):
        """Cancel a download."""
        try:
            # Check if download exists
            if download_id not in self.active_downloads:
                self.app_controller.logger.warning(f"Download not found: {download_id}")
                return False
            
            # Get download
            download = self.active_downloads[download_id]
            
            # Cancel download
            download.cancel()
            
            return True
        
        except Exception as e:
            self.app_controller.logger.error(f"Error canceling download: {e}")
            return False
    
    def pause_download(self, download_id):
        """Pause a download."""
        try:
            # Check if download exists
            if download_id not in self.active_downloads:
                self.app_controller.logger.warning(f"Download not found: {download_id}")
                return False
            
            # Get download
            download = self.active_downloads[download_id]
            
            # Pause download
            download.pause()
            
            # Update database
            self._update_download_in_db(
                download_id,
                state="paused"
            )
            
            # Trigger hook
            self.app_controller.hook_registry.trigger_hook("onDownloadPaused", download_id)
            
            self.app_controller.logger.info(f"Download paused: {download_id}")
            
            return True
        
        except Exception as e:
            self.app_controller.logger.error(f"Error pausing download: {e}")
            return False
    
    def resume_download(self, download_id):
        """Resume a download."""
        try:
            # Check if download exists
            if download_id not in self.active_downloads:
                self.app_controller.logger.warning(f"Download not found: {download_id}")
                return False
            
            # Get download
            download = self.active_downloads[download_id]
            
            # Resume download
            download.resume()
            
            # Update database
            self._update_download_in_db(
                download_id,
                state="in_progress"
            )
            
            # Trigger hook
            self.app_controller.hook_registry.trigger_hook("onDownloadResumed", download_id)
            
            self.app_controller.logger.info(f"Download resumed: {download_id}")
            
            return True
        
        except Exception as e:
            self.app_controller.logger.error(f"Error resuming download: {e}")
            return False
    
    def get_download(self, download_id):
        """Get a download."""
        try:
            # Create cursor
            cursor = self.db_conn.cursor()
            
            # Get download
            cursor.execute("""
            SELECT id, url, path, filename, mime_type, size, received, state, start_time, end_time, error
            FROM downloads
            WHERE id = ?
            """, (download_id,))
            
            # Get result
            result = cursor.fetchone()
            
            if not result:
                return None
            
            # Convert to dictionary
            download = {
                "id": result[0],
                "url": result[1],
                "path": result[2],
                "filename": result[3],
                "mime_type": result[4],
                "size": result[5],
                "received": result[6],
                "state": result[7],
                "start_time": result[8],
                "end_time": result[9],
                "error": result[10]
            }
            
            return download
        
        except Exception as e:
            self.app_controller.logger.error(f"Error getting download: {e}")
            return None
    
    def get_downloads(self, limit=100, offset=0, state=None):
        """Get downloads."""
        try:
            # Create cursor
            cursor = self.db_conn.cursor()
            
            # Build query
            query = """
            SELECT id, url, path, filename, mime_type, size, received, state, start_time, end_time, error
            FROM downloads
            """
            
            params = []
            
            if state:
                query += "WHERE state = ? "
                params.append(state)
            
            query += "ORDER BY start_time DESC "
            query += "LIMIT ? OFFSET ?"
            params.extend([limit, offset])
            
            # Get downloads
            cursor.execute(query, params)
            
            # Convert to list of dictionaries
            downloads = []
            for result in cursor.fetchall():
                download = {
                    "id": result[0],
                    "url": result[1],
                    "path": result[2],
                    "filename": result[3],
                    "mime_type": result[4],
                    "size": result[5],
                    "received": result[6],
                    "state": result[7],
                    "start_time": result[8],
                    "end_time": result[9],
                    "error": result[10]
                }
                downloads.append(download)
            
            return downloads
        
        except Exception as e:
            self.app_controller.logger.error(f"Error getting downloads: {e}")
            return []
    
    def clear_downloads(self, state=None):
        """Clear downloads from the database."""
        try:
            # Create cursor
            cursor = self.db_conn.cursor()
            
            # Build query
            query = "DELETE FROM downloads "
            
            params = []
            
            if state:
                query += "WHERE state = ?"
                params.append(state)
            
            # Clear downloads
            cursor.execute(query, params)
            
            # Commit changes
            self.db_conn.commit()
            
            # Trigger hook
            self.app_controller.hook_registry.trigger_hook("onDownloadsCleared", state)
            
            self.app_controller.logger.info(f"Downloads cleared: {state or 'all'}")
            
            return True
        
        except Exception as e:
            self.app_controller.logger.error(f"Error clearing downloads: {e}")
            return False
    
    def remove_download(self, download_id):
        """Remove a download from the database."""
        try:
            # Create cursor
            cursor = self.db_conn.cursor()
            
            # Remove download
            cursor.execute("""
            DELETE FROM downloads
            WHERE id = ?
            """, (download_id,))
            
            # Commit changes
            self.db_conn.commit()
            
            # Trigger hook
            self.app_controller.hook_registry.trigger_hook("onDownloadRemoved", download_id)
            
            self.app_controller.logger.info(f"Download removed: {download_id}")
            
            return True
        
        except Exception as e:
            self.app_controller.logger.error(f"Error removing download: {e}")
            return False
    
    def get_active_downloads(self):
        """Get active downloads."""
        try:
            # Get downloads
            downloads = self.get_downloads(state="in_progress")
            
            return downloads
        
        except Exception as e:
            self.app_controller.logger.error(f"Error getting active downloads: {e}")
            return []
    
    def get_completed_downloads(self):
        """Get completed downloads."""
        try:
            # Get downloads
            downloads = self.get_downloads(state="completed")
            
            return downloads
        
        except Exception as e:
            self.app_controller.logger.error(f"Error getting completed downloads: {e}")
            return []
    
    def get_failed_downloads(self):
        """Get failed downloads."""
        try:
            # Get downloads
            downloads = self.get_downloads(state="failed")
            
            return downloads
        
        except Exception as e:
            self.app_controller.logger.error(f"Error getting failed downloads: {e}")
            return []
    
    def get_canceled_downloads(self):
        """Get canceled downloads."""
        try:
            # Get downloads
            downloads = self.get_downloads(state="canceled")
            
            return downloads
        
        except Exception as e:
            self.app_controller.logger.error(f"Error getting canceled downloads: {e}")
            return []
    
    def get_paused_downloads(self):
        """Get paused downloads."""
        try:
            # Get downloads
            downloads = self.get_downloads(state="paused")
            
            return downloads
        
        except Exception as e:
            self.app_controller.logger.error(f"Error getting paused downloads: {e}")
            return []
</file>

<file path="src/core/history.py">
#!/usr/bin/env python3
# NebulaFusion Browser - History Manager

import os
import sys
import json
import sqlite3
import time
from PyQt6.QtCore import QObject, pyqtSignal, QUrl

class HistoryManager(QObject):
    """
    Manager for browser history.
    Handles storing, retrieving, and managing browsing history.
    """
    
    # Signals
    history_added = pyqtSignal(str, str)  # url, title
    history_removed = pyqtSignal(str)  # url
    history_cleared = pyqtSignal()
    
    def __init__(self, app_controller):
        """Initialize the history manager."""
        super().__init__()
        self.app_controller = app_controller
        
        # Database connection
        self.db_conn = None
        
        # Initialize history
        self.initialized = False
        
        # Private browsing mode
        self.private_mode = False
    
    def initialize(self):
        """Initialize the history manager."""
        self.app_controller.logger.info("Initializing history manager...")
        
        # Create history directory
        history_dir = os.path.expanduser("~/.nebulafusion/history")
        os.makedirs(history_dir, exist_ok=True)
        
        # Connect to database
        db_path = os.path.join(history_dir, "history.db")
        self.db_conn = sqlite3.connect(db_path)
        
        # Create tables
        self._create_tables()
        
        # Update state
        self.initialized = True
        
        self.app_controller.logger.info("History manager initialized.")
        
        return True
    
    def cleanup(self):
        """Clean up the history manager."""
        self.app_controller.logger.info("Cleaning up history manager...")
        
        # Close database connection
        if self.db_conn:
            self.db_conn.close()
            self.db_conn = None
        
        # Update state
        self.initialized = False
        
        self.app_controller.logger.info("History manager cleaned up.")
        
        return True
    
    def _create_tables(self):
        """Create database tables."""
        # Create cursor
        cursor = self.db_conn.cursor()
        
        # Create history table
        cursor.execute("""
        CREATE TABLE IF NOT EXISTS history (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            url TEXT,
            title TEXT,
            visit_time INTEGER,
            visit_count INTEGER DEFAULT 1
        )
        """)
        
        # Create index on url
        cursor.execute("""
        CREATE INDEX IF NOT EXISTS idx_history_url ON history (url)
        """)
        
        # Create index on visit_time
        cursor.execute("""
        CREATE INDEX IF NOT EXISTS idx_history_visit_time ON history (visit_time)
        """)
        
        # Commit changes
        self.db_conn.commit()
    
    def add_history(self, url, title):
        """Add a history entry."""
        # Skip if in private mode
        if self.private_mode:
            return True
        
        try:
            # Create cursor
            cursor = self.db_conn.cursor()
            
            # Get current time
            current_time = int(time.time())
            
            # Check if URL exists
            cursor.execute("""
            SELECT id, visit_count FROM history WHERE url = ?
            """, (url,))
            
            result = cursor.fetchone()
            
            if result:
                # Update existing entry
                entry_id, visit_count = result
                
                cursor.execute("""
                UPDATE history
                SET title = ?, visit_time = ?, visit_count = ?
                WHERE id = ?
                """, (title, current_time, visit_count + 1, entry_id))
            else:
                # Add new entry
                cursor.execute("""
                INSERT INTO history (url, title, visit_time)
                VALUES (?, ?, ?)
                """, (url, title, current_time))
            
            # Commit changes
            self.db_conn.commit()
            
            # Emit signal
            self.history_added.emit(url, title)
            
            # Trigger hook
            self.app_controller.hook_registry.trigger_hook("onHistoryAdded", url, title)
            
            self.app_controller.logger.info(f"History entry added: {url}")
            
            return True
        
        except Exception as e:
            self.app_controller.logger.error(f"Error adding history entry: {e}")
            return False
    
    def remove_history(self, url):
        """Remove a history entry."""
        try:
            # Create cursor
            cursor = self.db_conn.cursor()
            
            # Remove entry
            cursor.execute("""
            DELETE FROM history WHERE url = ?
            """, (url,))
            
            # Commit changes
            self.db_conn.commit()
            
            # Emit signal
            self.history_removed.emit(url)
            
            # Trigger hook
            self.app_controller.hook_registry.trigger_hook("onHistoryRemoved", url)
            
            self.app_controller.logger.info(f"History entry removed: {url}")
            
            return True
        
        except Exception as e:
            self.app_controller.logger.error(f"Error removing history entry: {e}")
            return False
    
    def clear_history(self):
        """Clear all history."""
        try:
            # Create cursor
            cursor = self.db_conn.cursor()
            
            # Clear history
            cursor.execute("""
            DELETE FROM history
            """)
            
            # Commit changes
            self.db_conn.commit()
            
            # Emit signal
            self.history_cleared.emit()
            
            # Trigger hook
            self.app_controller.hook_registry.trigger_hook("onHistoryCleared")
            
            self.app_controller.logger.info("History cleared")
            
            return True
        
        except Exception as e:
            self.app_controller.logger.error(f"Error clearing history: {e}")
            return False
    
    def get_history(self, limit=100, offset=0):
        """Get history entries."""
        try:
            # Create cursor
            cursor = self.db_conn.cursor()
            
            # Get history
            cursor.execute("""
            SELECT url, title, visit_time, visit_count
            FROM history
            ORDER BY visit_time DESC
            LIMIT ? OFFSET ?
            """, (limit, offset))
            
            # Convert to list of dictionaries
            history = []
            for row in cursor.fetchall():
                url, title, visit_time, visit_count = row
                history.append({
                    "url": url,
                    "title": title,
                    "visit_time": visit_time,
                    "visit_count": visit_count
                })
            
            return history
        
        except Exception as e:
            self.app_controller.logger.error(f"Error getting history: {e}")
            return []
    
    def search_history(self, query, limit=100, offset=0):
        """Search history entries."""
        try:
            # Create cursor
            cursor = self.db_conn.cursor()
            
            # Search history
            cursor.execute("""
            SELECT url, title, visit_time, visit_count
            FROM history
            WHERE url LIKE ? OR title LIKE ?
            ORDER BY visit_time DESC
            LIMIT ? OFFSET ?
            """, (f"%{query}%", f"%{query}%", limit, offset))
            
            # Convert to list of dictionaries
            history = []
            for row in cursor.fetchall():
                url, title, visit_time, visit_count = row
                history.append({
                    "url": url,
                    "title": title,
                    "visit_time": visit_time,
                    "visit_count": visit_count
                })
            
            return history
        
        except Exception as e:
            self.app_controller.logger.error(f"Error searching history: {e}")
            return []
    
    def get_most_visited(self, limit=10):
        """Get most visited sites."""
        try:
            # Create cursor
            cursor = self.db_conn.cursor()
            
            # Get most visited sites
            cursor.execute("""
            SELECT url, title, visit_time, visit_count
            FROM history
            ORDER BY visit_count DESC
            LIMIT ?
            """, (limit,))
            
            # Convert to list of dictionaries
            history = []
            for row in cursor.fetchall():
                url, title, visit_time, visit_count = row
                history.append({
                    "url": url,
                    "title": title,
                    "visit_time": visit_time,
                    "visit_count": visit_count
                })
            
            return history
        
        except Exception as e:
            self.app_controller.logger.error(f"Error getting most visited sites: {e}")
            return []
    
    def get_recent(self, limit=10):
        """Get recently visited sites."""
        try:
            # Create cursor
            cursor = self.db_conn.cursor()
            
            # Get recent sites
            cursor.execute("""
            SELECT url, title, visit_time, visit_count
            FROM history
            ORDER BY visit_time DESC
            LIMIT ?
            """, (limit,))
            
            # Convert to list of dictionaries
            history = []
            for row in cursor.fetchall():
                url, title, visit_time, visit_count = row
                history.append({
                    "url": url,
                    "title": title,
                    "visit_time": visit_time,
                    "visit_count": visit_count
                })
            
            return history
        
        except Exception as e:
            self.app_controller.logger.error(f"Error getting recent sites: {e}")
            return []
    
    def export_history(self, file_path):
        """Export history to a file."""
        try:
            # Get all history
            history = self.get_history(limit=0)
            
            # Check file extension
            if file_path.endswith(".json"):
                # Export to JSON
                with open(file_path, "w") as f:
                    json.dump(history, f, indent=4)
            
            elif file_path.endswith(".csv"):
                # Export to CSV
                import csv
                
                with open(file_path, "w", newline="") as f:
                    writer = csv.writer(f)
                    
                    # Write header
                    writer.writerow(["URL", "Title", "Visit Time", "Visit Count"])
                    
                    # Write data
                    for entry in history:
                        writer.writerow([
                            entry["url"],
                            entry["title"],
                            entry["visit_time"],
                            entry["visit_count"]
                        ])
            
            else:
                self.app_controller.logger.error("Unsupported history file format")
                return False
            
            # Trigger hook
            self.app_controller.hook_registry.trigger_hook("onHistoryExported")
            
            self.app_controller.logger.info(f"History exported to {file_path}")
            
            return True
        
        except Exception as e:
            self.app_controller.logger.error(f"Error exporting history: {e}")
            return False
    
    def import_history(self, file_path):
        """Import history from a file."""
        try:
            # Check file extension
            if file_path.endswith(".json"):
                # Import from JSON
                with open(file_path, "r") as f:
                    data = json.load(f)
                
                # Check if data is valid
                if not isinstance(data, list):
                    self.app_controller.logger.error("Invalid history file format")
                    return False
                
                # Import history
                for entry in data:
                    if "url" in entry and "title" in entry:
                        self.add_history(entry["url"], entry["title"])
            
            elif file_path.endswith(".csv"):
                # Import from CSV
                import csv
                
                with open(file_path, "r", newline="") as f:
                    reader = csv.reader(f)
                    
                    # Skip header
                    next(reader)
                    
                    # Import history
                    for row in reader:
                        if len(row) >= 2:
                            url, title = row[0], row[1]
                            self.add_history(url, title)
            
            else:
                self.app_controller.logger.error("Unsupported history file format")
                return False
            
            # Trigger hook
            self.app_controller.hook_registry.trigger_hook("onHistoryImported")
            
            self.app_controller.logger.info(f"History imported from {file_path}")
            
            return True
        
        except Exception as e:
            self.app_controller.logger.error(f"Error importing history: {e}")
            return False
    
    def set_private_mode(self, enabled):
        """Set private browsing mode."""
        self.private_mode = enabled
        
        # Trigger hook
        self.app_controller.hook_registry.trigger_hook("onPrivateModeChanged", enabled)
        
        self.app_controller.logger.info(f"Private browsing mode: {enabled}")
        
        return True
    
    def is_private_mode(self):
        """Check if private browsing mode is enabled."""
        return self.private_mode
</file>

<file path="src/core/security_integration.py">
#!/usr/bin/env python3
# NebulaFusion Browser - Security Integration

import os
import sys
import json
import time
import inspect
import traceback
from PyQt5.QtCore import QObject, pyqtSignal

class SecurityIntegration(QObject):
    """
    Integrates security features across browser modules.
    """
    
    # Signals
    security_violation = pyqtSignal(str, str, str)
    permission_denied = pyqtSignal(str, str, str)
    
    def __init__(self, app_controller):
        """Initialize the security integration."""
        super().__init__()
        self.app_controller = app_controller
        
        # Security hooks
        self.security_hooks = {}
        
        # Permission cache
        self.permission_cache = {}
    
    def initialize(self):
        """Initialize the security integration."""
        # Register security hooks
        self._register_security_hooks()
        
        # Connect signals
        self._connect_signals()
    
    def _register_security_hooks(self):
        """Register security hooks."""
        # Tab hooks
        self.security_hooks["beforeTabCreated"] = self._hook_before_tab_created
        self.security_hooks["beforeTabClosed"] = self._hook_before_tab_closed
        
        # Navigation hooks
        self.security_hooks["beforeNavigation"] = self._hook_before_navigation
        self.security_hooks["beforeResourceLoad"] = self._hook_before_resource_load
        
        # Content hooks
        self.security_hooks["beforeScriptExecution"] = self._hook_before_script_execution
        self.security_hooks["beforeDOMModification"] = self._hook_before_dom_modification
        
        # Cookie hooks
        self.security_hooks["beforeCookieSet"] = self._hook_before_cookie_set
        self.security_hooks["beforeCookieRead"] = self._hook_before_cookie_read
        
        # Download hooks
        self.security_hooks["beforeDownload"] = self._hook_before_download
        
        # Plugin hooks
        self.security_hooks["beforePluginLoad"] = self._hook_before_plugin_load
        self.security_hooks["beforePluginAPICall"] = self._hook_before_plugin_api_call
        self.security_hooks["beforePluginHookExecution"] = self._hook_before_plugin_hook_execution
        
        # Register hooks with hook registry
        for hook_name, callback in self.security_hooks.items():
            self.app_controller.hook_registry.register_hook(hook_name, "security_integration", callback)
    
    def _connect_signals(self):
        """Connect signals."""
        # Connect to plugin loader signals
        self.app_controller.plugin_loader.plugin_loaded.connect(self._on_plugin_loaded)
        self.app_controller.plugin_loader.plugin_load_failed.connect(self._on_plugin_load_failed)
        
        # Connect to plugin API signals
        for plugin_id, plugin_api in self.app_controller.plugin_manager.plugin_apis.items():
            self._connect_plugin_api_signals(plugin_id, plugin_api)
        
        # Connect to sandbox signals
        for plugin_id, sandbox in self.app_controller.plugin_manager.plugin_sandboxes.items():
            self._connect_sandbox_signals(plugin_id, sandbox)
    
    def _connect_plugin_api_signals(self, plugin_id, plugin_api):
        """Connect to plugin API signals."""
        # This would typically connect to plugin API signals
        # For now, just log the connection
        self.app_controller.logger.debug(f"Connected to plugin API signals for {plugin_id}")
    
    def _connect_sandbox_signals(self, plugin_id, sandbox):
        """Connect to sandbox signals."""
        # Connect to sandbox signals
        sandbox.resource_limit_exceeded.connect(
            lambda resource, value: self._on_resource_limit_exceeded(plugin_id, resource, value))
        sandbox.security_violation.connect(
            lambda message: self._on_security_violation(plugin_id, message))
    
    def _on_plugin_loaded(self, plugin_id, plugin_instance):
        """Handle plugin loaded event."""
        # Log plugin loaded
        self.app_controller.logger.info(f"Plugin loaded: {plugin_id}")
        
        # Connect to plugin API signals
        plugin_api = self.app_controller.plugin_manager.get_plugin_api(plugin_id)
        self._connect_plugin_api_signals(plugin_id, plugin_api)
        
        # Connect to sandbox signals
        if plugin_id in self.app_controller.plugin_manager.plugin_sandboxes:
            sandbox = self.app_controller.plugin_manager.plugin_sandboxes[plugin_id]
            self._connect_sandbox_signals(plugin_id, sandbox)
    
    def _on_plugin_load_failed(self, plugin_id, error):
        """Handle plugin load failed event."""
        # Log plugin load failed
        self.app_controller.logger.error(f"Plugin load failed: {plugin_id} - {error}")
    
    def _on_resource_limit_exceeded(self, plugin_id, resource, value):
        """Handle resource limit exceeded event."""
        # Log resource limit exceeded
        self.app_controller.logger.warning(
            f"Plugin {plugin_id} exceeded {resource} limit: {value}")
        
        # Emit signal
        self.security_violation.emit(
            plugin_id,
            "resource_limit_exceeded",
            f"Exceeded {resource} limit: {value}"
        )
        
        # Take action based on resource
        if resource == "cpu_percent" and value > 50:
            # Disable plugin if CPU usage is extremely high
            self.app_controller.plugin_manager.disable_plugin(plugin_id)
            self.app_controller.logger.warning(
                f"Plugin {plugin_id} disabled due to excessive CPU usage: {value}%")
    
    def _on_security_violation(self, plugin_id, message):
        """Handle security violation event."""
        # Log security violation
        self.app_controller.logger.warning(
            f"Plugin {plugin_id} security violation: {message}")
        
        # Emit signal
        self.security_violation.emit(
            plugin_id,
            "security_violation",
            message
        )
    
    def check_permission(self, plugin_id, permission):
        """Check if a plugin has a permission."""
        # Check cache
        cache_key = f"{plugin_id}:{permission}"
        if cache_key in self.permission_cache:
            return self.permission_cache[cache_key]
        
        # Get plugin information
        plugin_info = self.app_controller.plugin_loader.get_plugin(plugin_id)
        if not plugin_info:
            return False
        
        # Get plugin permissions
        permissions = plugin_info["manifest"].get("permissions", [])
        
        # Check permission
        has_permission = permission in permissions or "all" in permissions
        
        # Cache result
        self.permission_cache[cache_key] = has_permission
        
        return has_permission
    
    def request_permission(self, plugin_id, permission, reason=None):
        """Request a permission for a plugin."""
        # Check if plugin already has permission
        if self.check_permission(plugin_id, permission):
            return True
        
        # Get plugin information
        plugin_info = self.app_controller.plugin_loader.get_plugin(plugin_id)
        if not plugin_info:
            return False
        
        # Get plugin name
        plugin_name = plugin_info["manifest"].get("name", plugin_id)
        
        # This would typically show a permission request dialog
        # For now, just log the request and deny it
        self.app_controller.logger.warning(
            f"Plugin {plugin_name} requested permission {permission}: {reason}")
        
        # Emit signal
        self.permission_denied.emit(
            plugin_id,
            permission,
            reason or "Permission not granted"
        )
        
        return False
    
    def _hook_before_tab_created(self, *args, **kwargs):
        """Hook before tab created."""
        # Get plugin ID from context
        plugin_id = kwargs.get("plugin_id")
        if not plugin_id:
            return True
        
        # Check permission
        if not self.check_permission(plugin_id, "tabs"):
            self.permission_denied.emit(
                plugin_id,
                "tabs",
                "Permission denied to create tab"
            )
            return False
        
        return True
    
    def _hook_before_tab_closed(self, *args, **kwargs):
        """Hook before tab closed."""
        # Get plugin ID from context
        plugin_id = kwargs.get("plugin_id")
        if not plugin_id:
            return True
        
        # Check permission
        if not self.check_permission(plugin_id, "tabs"):
            self.permission_denied.emit(
                plugin_id,
                "tabs",
                "Permission denied to close tab"
            )
            return False
        
        return True
    
    def _hook_before_navigation(self, url, *args, **kwargs):
        """Hook before navigation."""
        # Get plugin ID from context
        plugin_id = kwargs.get("plugin_id")
        if not plugin_id:
            return True
        
        # Check permission
        if not self.check_permission(plugin_id, "navigation"):
            self.permission_denied.emit(
                plugin_id,
                "navigation",
                f"Permission denied to navigate to {url}"
            )
            return False
        
        # Check URL security
        security_status = self.app_controller.security_manager.check_url_security(url)
        if not security_status["is_secure"]:
            self.security_violation.emit(
                plugin_id,
                "navigation",
                f"Navigation to insecure URL blocked: {url}"
            )
            return False
        
        return True
    
    def _hook_before_resource_load(self, url, resource_type, *args, **kwargs):
        """Hook before resource load."""
        # Get plugin ID from context
        plugin_id = kwargs.get("plugin_id")
        if not plugin_id:
            return True
        
        # Check permission
        if not self.check_permission(plugin_id, "content"):
            self.permission_denied.emit(
                plugin_id,
                "content",
                f"Permission denied to load resource {url}"
            )
            return False
        
        # Check URL security
        security_status = self.app_controller.security_manager.check_url_security(url)
        if not security_status["is_secure"]:
            self.security_violation.emit(
                plugin_id,
                "resource_load",
                f"Loading insecure resource blocked: {url}"
            )
            return False
        
        return True
    
    def _hook_before_script_execution(self, script, url, *args, **kwargs):
        """Hook before script execution."""
        # Get plugin ID from context
        plugin_id = kwargs.get("plugin_id")
        if not plugin_id:
            return True
        
        # Check permission
        if not self.check_permission(plugin_id, "content"):
            self.permission_denied.emit(
                plugin_id,
                "content",
                f"Permission denied to execute script on {url}"
            )
            return False
        
        # This would typically check script content for malicious code
        # For now, just return True
        return True
    
    def _hook_before_dom_modification(self, element, modification, *args, **kwargs):
        """Hook before DOM modification."""
        # Get plugin ID from context
        plugin_id = kwargs.get("plugin_id")
        if not plugin_id:
            return True
        
        # Check permission
        if not self.check_permission(plugin_id, "content"):
            self.permission_denied.emit(
                plugin_id,
                "content",
                f"Permission denied to modify DOM"
            )
            return False
        
        # This would typically check DOM modification for security issues
        # For now, just return True
        return True
    
    def _hook_before_cookie_set(self, cookie, *args, **kwargs):
        """Hook before cookie set."""
        # Get plugin ID from context
        plugin_id = kwargs.get("plugin_id")
        if not plugin_id:
            return True
        
        # Check permission
        if not self.check_permission(plugin_id, "cookies"):
            self.permission_denied.emit(
                plugin_id,
                "cookies",
                f"Permission denied to set cookie"
            )
            return False
        
        # This would typically check cookie for security issues
        # For now, just return True
        return True
    
    def _hook_before_cookie_read(self, domain, name, *args, **kwargs):
        """Hook before cookie read."""
        # Get plugin ID from context
        plugin_id = kwargs.get("plugin_id")
        if not plugin_id:
            return True
        
        # Check permission
        if not self.check_permission(plugin_id, "cookies"):
            self.permission_denied.emit(
                plugin_id,
                "cookies",
                f"Permission denied to read cookie"
            )
            return False
        
        # This would typically check cookie access for security issues
        # For now, just return True
        return True
    
    def _hook_before_download(self, url, path, *args, **kwargs):
        """Hook before download."""
        # Get plugin ID from context
        plugin_id = kwargs.get("plugin_id")
        if not plugin_id:
            return True
        
        # Check permission
        if not self.check_permission(plugin_id, "downloads"):
            self.permission_denied.emit(
                plugin_id,
                "downloads",
                f"Permission denied to download file"
            )
            return False
        
        # Check URL security
        security_status = self.app_controller.security_manager.check_url_security(url)
        if not security_status["is_secure"]:
            self.security_violation.emit(
                plugin_id,
                "download",
                f"Download from insecure URL blocked: {url}"
            )
            return False
        
        # This would typically check download path for security issues
        # For now, just return True
        return True
    
    def _hook_before_plugin_load(self, plugin_path, *args, **kwargs):
        """Hook before plugin load."""
        # This would typically check plugin for security issues
        # For now, just return True
        return True
    
    def _hook_before_plugin_api_call(self, plugin_id, method_name, *args, **kwargs):
        """Hook before plugin API call."""
        # Get required permission for method
        permission = self._get_permission_for_api_method(method_name)
        if not permission:
            return True
        
        # Check permission
        if not self.check_permission(plugin_id, permission):
            self.permission_denied.emit(
                plugin_id,
                permission,
                f"Permission denied to call API method {method_name}"
            )
            return False
        
        return True
    
    def _hook_before_plugin_hook_execution(self, hook_name, plugin_id, *args, **kwargs):
        """Hook before plugin hook execution."""
        # Get required permission for hook
        permission = self._get_permission_for_hook(hook_name)
        if not permission:
            return True
        
        # Check permission
        if not self.check_permission(plugin_id, permission):
            self.permission_denied.emit(
                plugin_id,
                permission,
                f"Permission denied to execute hook {hook_name}"
            )
            return False
        
        return True
    
    def _get_permission_for_api_method(self, method_name):
        """Get required permission for an API method."""
        # Map API methods to permissions
        method_permissions = {
            # Browser API
            "get_browser_info": "browser",
            "get_version": "browser",
            "restart": "browser",
            "exit": "browser",
            
            # Tab API
            "get_tabs": "tabs",
            "get_current_tab": "tabs",
            "create_tab": "tabs",
            "close_tab": "tabs",
            "select_tab": "tabs",
            "move_tab": "tabs",
            "get_tab_info": "tabs",
            
            # Navigation API
            "navigate": "navigation",
            "go_back": "navigation",
            "go_forward": "navigation",
            "reload": "navigation",
            "stop": "navigation",
            "get_current_url": "navigation",
            
            # Content API
            "get_page_html": "content",
            "get_page_dom": "content",
            "inject_css": "content",
            "inject_js": "content",
            "modify_dom": "content",
            
            # UI API
            "add_toolbar_button": "ui",
            "add_menu_item": "ui",
            "add_context_menu_item": "ui",
            "show_notification": "ui",
            "create_panel": "ui",
            
            # Data API
            "get_bookmarks": "bookmarks",
            "add_bookmark": "bookmarks",
            "remove_bookmark": "bookmarks",
            "get_history": "history",
            "clear_history": "history",
            "get_cookies": "cookies",
            "set_cookie": "cookies",
            "remove_cookie": "cookies",
            
            # Download API
            "download_file": "downloads",
            "pause_download": "downloads",
            "resume_download": "downloads",
            "cancel_download": "downloads",
            "get_downloads": "downloads",
            
            # Settings API
            "get_browser_settings": "settings",
            "register_settings_page": "settings",
            
            # Unique Features API
            "start_reality_augmentation": "reality_augmentation",
            "start_collaborative_session": "collaborative",
            "transform_content": "content_transform",
            "take_time_snapshot": "time_travel",
            "organize_dimensional_tabs": "dimensional_tabs",
            "register_voice_command": "voice_commands"
        }
        
        return method_permissions.get(method_name)
    
    def _get_permission_for_hook(self, hook_name):
        """Get required permission for a hook."""
        # Map hooks to permissions
        hook_permissions = {
            # Browser lifecycle hooks
            "onBrowserStart": "browser",
            "onBrowserExit": "browser",
            "onSettingsChanged": "settings",
            
            # Tab hooks
            "onTabCreated": "tabs",
            "beforeTabClosed": "tabs",
            "onTabClosed": "tabs",
            "onTabSelected": "tabs",
            "onTabMoved": "tabs",
            
            # Navigation hooks
            "beforeNavigation": "navigation",
            "afterNavigation": "navigation",
            "onPageStartLoad": "navigation",
            "onPageLoadProgress": "navigation",
            "onPageFinishLoad": "navigation",
            "onPageError": "navigation",
            
            # Content hooks
            "beforeDOMLoad": "content",
            "afterDOMLoad": "content",
            "onHTMLModify": "content",
            "onCSSModify": "content",
            "onJSExecute": "content",
            
            # UI hooks
            "onToolbarCreated": "ui",
            "onMenuCreated": "ui",
            "onContextMenu": "ui",
            "onStatusBarUpdate": "ui",
            "onAddressBarUpdate": "ui",
            
            # Data hooks
            "onBookmarkAdded": "bookmarks",
            "onBookmarkRemoved": "bookmarks",
            "onHistoryAdded": "history",
            "onHistoryRemoved": "history",
            "onCookieSet": "cookies",
            "onCookieRemoved": "cookies",
            "onCookiesCleared": "cookies",
            
            # Download hooks
            "onDownloadStart": "downloads",
            "onDownloadProgress": "downloads",
            "onDownloadComplete": "downloads",
            "onDownloadError": "downloads",
            "onDownloadCanceled": "downloads",
            
            # Unique feature hooks
            "onRealityAugmentation": "reality_augmentation",
            "onCollaborativeSession": "collaborative",
            "onContentTransform": "content_transform",
            "onTimeTravelSnapshot": "time_travel",
            "onDimensionalTabChange": "dimensional_tabs",
            "onVoiceCommand": "voice_commands"
        }
        
        return hook_permissions.get(hook_name)
    
    def clear_permission_cache(self):
        """Clear permission cache."""
        self.permission_cache.clear()
    
    def clear_permission_cache_for_plugin(self, plugin_id):
        """Clear permission cache for a plugin."""
        keys_to_remove = [key for key in self.permission_cache if key.startswith(f"{plugin_id}:")]
        for key in keys_to_remove:
            del self.permission_cache[key]
</file>

<file path="src/core/security.py">
#!/usr/bin/env python3
# NebulaFusion Browser - Security Manager

import os
import json
import time
import hashlib
import sqlite3
from PyQt6.QtCore import QObject, pyqtSignal


class SecurityManager(QObject):
    """
    Manages browser security features.
    """

    # Signals
    security_alert = pyqtSignal(str, str, int)

    def __init__(self, app_controller):
        """Initialize the security manager."""
        super().__init__()
        self.app_controller = app_controller

        # Set security database path
        self.security_db = os.path.expanduser("~/.nebulafusion/security.db")

        # Initialize database connection
        self.conn = None
        self.cursor = None

        # Security settings
        self.security_settings = {
            "block_malicious_sites": True,
            "warn_on_insecure_forms": True,
            "enable_phishing_protection": True,
            "enable_xss_protection": True,
            "enable_content_verification": True,
            "plugin_sandbox_enabled": True,
            "plugin_resource_limits": {
                "cpu_percent": 10,
                "memory_mb": 100,
                "network_requests_per_minute": 60,
                "file_access_paths": ["~/.nebulafusion/plugins"],
            },
        }

        # Malicious site indicators
        self.malicious_indicators = [
            "phishing",
            "malware",
            "scam",
            "virus",
            "trojan",
            "exploit",
        ]

    def initialize(self):
        """Initialize the security manager."""
        # Create security directory if it doesn't exist
        os.makedirs(os.path.dirname(self.security_db), exist_ok=True)

        # Connect to database
        self.conn = sqlite3.connect(self.security_db)
        self.cursor = self.conn.cursor()

        # Create tables if they don't exist
        self.cursor.execute(
            """
            CREATE TABLE IF NOT EXISTS security_events (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                event_type TEXT NOT NULL,
                url TEXT,
                description TEXT NOT NULL,
                severity INTEGER NOT NULL,
                timestamp REAL NOT NULL
            )
        """
        )

        self.cursor.execute(
            """
            CREATE TABLE IF NOT EXISTS blocked_sites (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                url TEXT NOT NULL UNIQUE,
                reason TEXT NOT NULL,
                timestamp REAL NOT NULL
            )
        """
        )

        # Create indexes
        self.cursor.execute(
            "CREATE INDEX IF NOT EXISTS idx_security_events_type ON security_events (event_type)"
        )
        self.cursor.execute(
            "CREATE INDEX IF NOT EXISTS idx_security_events_timestamp ON security_events (timestamp)"
        )
        self.cursor.execute(
            "CREATE INDEX IF NOT EXISTS idx_blocked_sites_url ON blocked_sites (url)"
        )

        # Commit changes
        self.conn.commit()

        # Load security settings
        self.load_security_settings()

    def load_security_settings(self):
        """Load security settings from settings manager."""
        # Get security settings from settings manager
        for key in self.security_settings.keys():
            if key != "plugin_resource_limits":
                value = self.app_controller.settings_manager.get_setting(
                    f"security_{key}", self.security_settings[key]
                )
                self.security_settings[key] = value

        # Get plugin resource limits
        for key in self.security_settings["plugin_resource_limits"].keys():
            value = self.app_controller.settings_manager.get_setting(
                f"security_plugin_{key}",
                self.security_settings["plugin_resource_limits"][key],
            )
            self.security_settings["plugin_resource_limits"][key] = value

    def check_url_security(self, url):
        """Check if a URL is secure."""
        # Check if URL is HTTPS
        is_https = url.startswith("https://")

        # Check if URL is in blocked sites
        is_blocked = self.is_url_blocked(url)

        # Check for malicious indicators
        has_malicious_indicators = any(
            indicator in url.lower() for indicator in self.malicious_indicators
        )

        # Return security status
        return {
            "is_secure": is_https and not is_blocked and not has_malicious_indicators,
            "is_https": is_https,
            "is_blocked": is_blocked,
            "has_malicious_indicators": has_malicious_indicators,
        }

    def is_url_blocked(self, url):
        """Check if a URL is blocked."""
        try:
            # Check database
            self.cursor.execute("SELECT id FROM blocked_sites WHERE url = ?", (url,))
            result = self.cursor.fetchone()

            return result is not None

        except Exception as e:
            print(f"Error checking blocked URL: {e}")
            return False

    def block_url(self, url, reason):
        """Block a URL."""
        try:
            # Check if URL is already blocked
            if self.is_url_blocked(url):
                return True

            # Add to blocked sites
            self.cursor.execute(
                "INSERT INTO blocked_sites (url, reason, timestamp) VALUES (?, ?, ?)",
                (url, reason, time.time()),
            )

            # Commit changes
            self.conn.commit()

            # Log security event
            self.log_security_event("url_blocked", url, f"URL blocked: {reason}", 2)

            return True

        except Exception as e:
            print(f"Error blocking URL: {e}")
            # Rollback changes
            self.conn.rollback()
            return False

    def unblock_url(self, url):
        """Unblock a URL."""
        try:
            # Remove from blocked sites
            self.cursor.execute("DELETE FROM blocked_sites WHERE url = ?", (url,))

            # Commit changes
            self.conn.commit()

            # Log security event
            self.log_security_event("url_unblocked", url, "URL unblocked", 1)

            return True

        except Exception as e:
            print(f"Error unblocking URL: {e}")
            # Rollback changes
            self.conn.rollback()
            return False

    def get_blocked_urls(self):
        """Get blocked URLs."""
        try:
            # Get blocked sites
            self.cursor.execute(
                "SELECT url, reason, timestamp FROM blocked_sites ORDER BY timestamp DESC"
            )

            # Return results
            return [
                {"url": row[0], "reason": row[1], "timestamp": row[2]}
                for row in self.cursor.fetchall()
            ]

        except Exception as e:
            print(f"Error getting blocked URLs: {e}")
            return []

    def log_security_event(self, event_type, url, description, severity):
        """Log a security event."""
        try:
            # Add to security events
            self.cursor.execute(
                """
                INSERT INTO security_events 
                (event_type, url, description, severity, timestamp)
                VALUES (?, ?, ?, ?, ?)
            """,
                (event_type, url, description, severity, time.time()),
            )

            # Commit changes
            self.conn.commit()

            # Emit signal for high severity events
            if severity >= 2:
                self.security_alert.emit(event_type, description, severity)

            return True

        except Exception as e:
            print(f"Error logging security event: {e}")
            # Rollback changes
            self.conn.rollback()
            return False

    def get_security_events(self, event_type=None, severity=None, limit=100, offset=0):
        """Get security events."""
        try:
            query = "SELECT event_type, url, description, severity, timestamp FROM security_events"
            params = []

            # Add filters
            if event_type or severity is not None:
                query += " WHERE"

                if event_type:
                    query += " event_type = ?"
                    params.append(event_type)

                if severity is not None:
                    if event_type:
                        query += " AND"
                    query += " severity >= ?"
                    params.append(severity)

            # Add order and limit
            query += " ORDER BY timestamp DESC LIMIT ? OFFSET ?"
            params.extend([limit, offset])

            # Execute query
            self.cursor.execute(query, params)

            # Return results
            return [
                {
                    "event_type": row[0],
                    "url": row[1],
                    "description": row[2],
                    "severity": row[3],
                    "timestamp": row[4],
                }
                for row in self.cursor.fetchall()
            ]

        except Exception as e:
            print(f"Error getting security events: {e}")
            return []

    def clear_security_events(self):
        """Clear security events."""
        try:
            # Delete all security events
            self.cursor.execute("DELETE FROM security_events")

            # Commit changes
            self.conn.commit()

            return True

        except Exception as e:
            print(f"Error clearing security events: {e}")
            # Rollback changes
            self.conn.rollback()
            return False

    def verify_plugin_integrity(self, plugin_path):
        """Verify plugin integrity."""
        try:
            # Check if plugin exists
            if not os.path.exists(plugin_path):
                return False, "Plugin does not exist"

            # Check if plugin is a directory
            if not os.path.isdir(plugin_path):
                return False, "Plugin is not a directory"

            # Check if plugin has required files
            required_files = ["__init__.py", "manifest.json"]
            for file in required_files:
                if not os.path.exists(os.path.join(plugin_path, file)):
                    return False, f"Plugin is missing required file: {file}"

            # Check manifest.json
            try:
                with open(os.path.join(plugin_path, "manifest.json"), "r") as f:
                    manifest = json.load(f)

                # Check required fields
                required_fields = ["name", "version", "author", "description"]
                for field in required_fields:
                    if field not in manifest:
                        return (
                            False,
                            f"Plugin manifest is missing required field: {field}",
                        )

            except Exception as e:
                return False, f"Error parsing plugin manifest: {e}"

            # Calculate plugin hash
            plugin_hash = self.calculate_plugin_hash(plugin_path)

            # TODO: Verify plugin hash against trusted repository

            return True, "Plugin integrity verified"

        except Exception as e:
            return False, f"Error verifying plugin integrity: {e}"

    def calculate_plugin_hash(self, plugin_path):
        """Calculate plugin hash."""
        try:
            # Initialize hasher
            hasher = hashlib.sha256()

            # Get all files in plugin directory
            for root, dirs, files in os.walk(plugin_path):
                for file in sorted(files):
                    file_path = os.path.join(root, file)

                    # Skip __pycache__ and other non-source files
                    if "__pycache__" in file_path or file.endswith(".pyc"):
                        continue

                    # Read file and update hash
                    with open(file_path, "rb") as f:
                        hasher.update(f.read())

            # Return hash
            return hasher.hexdigest()

        except Exception as e:
            print(f"Error calculating plugin hash: {e}")
            return None

    def check_plugin_permissions(self, plugin_manifest, requested_permissions):
        """Check plugin permissions."""
        # Get plugin permissions from manifest
        plugin_permissions = plugin_manifest.get("permissions", [])

        # Check if plugin has required permissions
        for permission in requested_permissions:
            if permission not in plugin_permissions:
                return False, f"Plugin does not have required permission: {permission}"

        return True, "Plugin permissions verified"

    def shutdown(self):
        """Shutdown the security manager."""
        # Close database connection
        if self.conn:
            self.conn.close()
</file>

<file path="src/core/settings.py">
#!/usr/bin/env python3
# NebulaFusion Browser - Settings Manager

import os
import sys
import json
import time
from PyQt6.QtCore import QObject, pyqtSignal


class SettingsManager(QObject):
    """
    Manages browser settings and configuration.
    """

    # Signals
    setting_changed = pyqtSignal(str, object)
    settings_loaded = pyqtSignal()
    settings_saved = pyqtSignal()

    def __init__(self, app_controller):
        """Initialize the settings manager."""
        super().__init__()
        self.app_controller = app_controller

        # Settings file
        self.settings_file = os.path.expanduser("~/.nebulafusion/settings.json")

        # Settings
        self.settings = {}

        # Default settings
        self.default_settings = {
            # Browser settings
            "browser_version": "1.0.0",
            "home_page": "https://www.google.com",
            "restore_session": True,
            "default_search_engine": "google",
            "enable_javascript": True,
            "enable_plugins": True,
            "enable_cookies": True,
            "enable_history": True,
            "enable_bookmarks": True,
            "enable_downloads": True,
            "enable_private_browsing": True,
            "enable_reality_augmentation": True,
            "enable_collaborative_browsing": True,
            "enable_content_transformation": True,
            "enable_time_travel": True,
            "enable_dimensional_tabs": True,
            "enable_voice_commands": True,
            # UI settings
            "theme": "default",
            "show_bookmarks_bar": True,
            "show_status_bar": True,
            "show_tab_previews": True,
            "tab_position": "top",
            "toolbar_style": "icon_text",
            # Privacy settings
            "clear_history_on_exit": False,
            "clear_cookies_on_exit": False,
            "do_not_track": False,
            "block_third_party_cookies": False,
            "block_popups": True,
            "block_ads": False,
            "block_trackers": False,
            # Security settings
            "security_block_malicious_sites": True,
            "security_warn_on_insecure_forms": True,
            "security_enable_phishing_protection": True,
            "security_enable_xss_protection": True,
            "security_enable_content_verification": True,
            "security_plugin_sandbox_enabled": True,
            "security_plugin_cpu_percent": 10,
            "security_plugin_memory_mb": 100,
            "security_plugin_network_requests_per_minute": 60,
            "security_plugin_file_access_paths": ["~/.nebulafusion/plugins"],
            # Download settings
            "download_directory": os.path.expanduser("~/Downloads"),
            "ask_before_download": True,
            "open_after_download": False,
            # Advanced settings
            "cache_size_mb": 100,
            "max_tabs": 50,
            "plugin_directory": os.path.expanduser("~/.nebulafusion/plugins"),
            "theme_directory": os.path.expanduser("~/.nebulafusion/themes"),
            "log_level": "info",
            "enable_developer_tools": False,
            "enable_experimental_features": False,
        }

    def initialize(self):
        """Initialize the settings manager."""
        # Create settings directory if it doesn't exist
        os.makedirs(os.path.dirname(self.settings_file), exist_ok=True)

        # Load settings
        self.load_settings()

    def load_settings(self):
        """Load settings from file."""
        try:
            if os.path.exists(self.settings_file):
                with open(self.settings_file, "r") as f:
                    self.settings = json.load(f)
            else:
                # Create default settings
                self.settings = self.default_settings.copy()

                # Save settings
                self.save_settings()

            # Emit signal
            self.settings_loaded.emit()

        except Exception as e:
            self.app_controller.logger.error(f"Error loading settings: {e}")
            self.settings = self.default_settings.copy()

    def save_settings(self):
        """Save settings to file."""
        try:
            with open(self.settings_file, "w") as f:
                json.dump(self.settings, f, indent=4)

            # Emit signal
            self.settings_saved.emit()

        except Exception as e:
            self.app_controller.logger.error(f"Error saving settings: {e}")

    def get_setting(self, key, default=None):
        """Get a setting."""
        return self.settings.get(
            key, default if default is not None else self.default_settings.get(key)
        )

    def set_setting(self, key, value):
        """Set a setting."""
        # Check if value is different
        if key in self.settings and self.settings[key] == value:
            return

        # Update setting
        self.settings[key] = value

        # Save settings
        self.save_settings()

        # Emit signal
        self.setting_changed.emit(key, value)

    def reset_setting(self, key):
        """Reset a setting to default."""
        if key in self.default_settings:
            self.set_setting(key, self.default_settings[key])

    def reset_all_settings(self):
        """Reset all settings to defaults."""
        self.settings = self.default_settings.copy()
        self.save_settings()

        # Emit signals for all settings
        for key, value in self.settings.items():
            self.setting_changed.emit(key, value)

    def get_all_settings(self):
        """Get all settings."""
        return self.settings

    def get_default_settings(self):
        """Get default settings."""
        return self.default_settings

    def import_settings(self, settings_file):
        """Import settings from a file."""
        try:
            with open(settings_file, "r") as f:
                imported_settings = json.load(f)

            # Update settings
            self.settings.update(imported_settings)

            # Save settings
            self.save_settings()

            # Emit signals for all settings
            for key, value in imported_settings.items():
                self.setting_changed.emit(key, value)

            return True

        except Exception as e:
            self.app_controller.logger.error(f"Error importing settings: {e}")
            return False

    def export_settings(self, settings_file):
        """Export settings to a file."""
        try:
            with open(settings_file, "w") as f:
                json.dump(self.settings, f, indent=4)

            return True

        except Exception as e:
            self.app_controller.logger.error(f"Error exporting settings: {e}")
            return False

    def get_settings_by_category(self, category):
        """Get settings by category."""
        if category == "browser":
            return {
                k: v
                for k, v in self.settings.items()
                if k.startswith("browser_")
                or k
                in [
                    "home_page",
                    "restore_session",
                    "default_search_engine",
                    "enable_javascript",
                    "enable_plugins",
                    "enable_cookies",
                    "enable_history",
                    "enable_bookmarks",
                    "enable_downloads",
                    "enable_private_browsing",
                    "enable_reality_augmentation",
                    "enable_collaborative_browsing",
                    "enable_content_transformation",
                    "enable_time_travel",
                    "enable_dimensional_tabs",
                    "enable_voice_commands",
                ]
            }

        elif category == "ui":
            return {
                k: v
                for k, v in self.settings.items()
                if k.startswith("ui_")
                or k
                in [
                    "theme",
                    "show_bookmarks_bar",
                    "show_status_bar",
                    "show_tab_previews",
                    "tab_position",
                    "toolbar_style",
                ]
            }

        elif category == "privacy":
            return {
                k: v
                for k, v in self.settings.items()
                if k.startswith("privacy_")
                or k
                in [
                    "clear_history_on_exit",
                    "clear_cookies_on_exit",
                    "do_not_track",
                    "block_third_party_cookies",
                    "block_popups",
                    "block_ads",
                    "block_trackers",
                ]
            }

        elif category == "security":
            return {k: v for k, v in self.settings.items() if k.startswith("security_")}

        elif category == "download":
            return {k: v for k, v in self.settings.items() if k.startswith("download_")}

        elif category == "advanced":
            return {
                k: v
                for k, v in self.settings.items()
                if k.startswith("advanced_")
                or k
                in [
                    "cache_size_mb",
                    "max_tabs",
                    "plugin_directory",
                    "theme_directory",
                    "log_level",
                    "enable_developer_tools",
                    "enable_experimental_features",
                ]
            }

        else:
            return {}
</file>

<file path="src/core/tab_manager.py">
#!/usr/bin/env python3
# NebulaFusion Browser - Tab Manager

import os
import sys
from PyQt6.QtCore import QObject, pyqtSignal, QUrl
from PyQt6.QtWebEngineCore import QWebEnginePage
from PyQt6.QtWebEngineWidgets import QWebEngineView

class TabManager(QObject):
    """
    Manager for browser tabs.
    Handles tab creation, deletion, and navigation.
    """
    
    # Signals
    tab_created = pyqtSignal(int, object)  # tab_index, tab
    tab_closed = pyqtSignal(int)  # tab_index
    tab_selected = pyqtSignal(int)  # tab_index
    tab_url_changed = pyqtSignal(int, QUrl)  # tab_index, url
    tab_title_changed = pyqtSignal(int, str)  # tab_index, title
    tab_icon_changed = pyqtSignal(int, object)  # tab_index, icon
    tab_security_changed = pyqtSignal(int, dict)  # tab_index, security_status
    page_loading = pyqtSignal(int)  # tab_index
    page_loaded = pyqtSignal(int, bool)  # tab_index, success
    page_load_progress = pyqtSignal(int, int)  # tab_index, progress
    
    def __init__(self, app_controller):
        """Initialize the tab manager."""
        super().__init__()
        self.app_controller = app_controller
        
        # Tabs
        self.tabs = []
        
        # Current tab index
        self.current_tab_index = -1
    
    def initialize(self):
        """Initialize the tab manager."""
        self.app_controller.logger.info("Initializing tab manager...")
        
        # Connect to settings manager
        self.app_controller.settings_manager.setting_changed.connect(self._on_setting_changed)
        
        self.app_controller.logger.info("Tab manager initialized.")
    
    def new_tab(self, url=None, private=False):
        """Create a new tab."""
        # Create tab
        from src.ui.browser_tabs import BrowserTab
        tab = BrowserTab(self.app_controller, private)
        
        # Add tab to list
        self.tabs.append(tab)
        tab_index = len(self.tabs) - 1
        
        # Connect tab signals
        self._connect_tab_signals(tab, tab_index)
        
        # Emit signal
        self.tab_created.emit(tab_index, tab)
        
        # Select tab
        self.select_tab(tab_index)
        
        # Navigate to URL
        if url:
            tab.navigate(url)
        else:
            # Navigate to home page
            home_page = self.app_controller.settings_manager.get_setting("home_page", "https://www.google.com")
            tab.navigate(home_page)
        
        # Trigger hook
        self.app_controller.hook_registry.trigger_hook("onTabCreated", tab_index, tab.url().toString())
        
        return tab_index
    
    def close_tab(self, tab_index):
        """Close a tab."""
        # Check if tab exists
        if tab_index < 0 or tab_index >= len(self.tabs):
            return False
        
        # Get tab
        tab = self.tabs[tab_index]
        
        # Trigger hook
        self.app_controller.hook_registry.trigger_hook("onTabClosed", tab_index, tab.url().toString())
        
        # Remove tab from list
        self.tabs.pop(tab_index)
        
        # Emit signal
        self.tab_closed.emit(tab_index)
        
        # Update current tab index
        if self.current_tab_index == tab_index:
            # Select another tab
            if len(self.tabs) > 0:
                # Select the tab to the left, or the first tab if this was the first tab
                new_index = max(0, tab_index - 1)
                self.select_tab(new_index)
            else:
                # No tabs left
                self.current_tab_index = -1
        elif self.current_tab_index > tab_index:
            # Adjust current tab index
            self.current_tab_index -= 1
        
        # Delete tab
        tab.deleteLater()
        
        return True
    
    def close_all_tabs(self):
        """Close all tabs."""
        # Close tabs in reverse order
        for i in range(len(self.tabs) - 1, -1, -1):
            self.close_tab(i)
    
    def select_tab(self, tab_index):
        """Select a tab."""
        # Check if tab exists
        if tab_index < 0 or tab_index >= len(self.tabs):
            return False
        
        # Update current tab index
        self.current_tab_index = tab_index
        
        # Emit signal
        self.tab_selected.emit(tab_index)
        
        # Trigger hook
        self.app_controller.hook_registry.trigger_hook("onTabSelected", tab_index, self.tabs[tab_index].url().toString())
        
        return True
    
    def get_current_tab(self):
        """Get the current tab."""
        if self.current_tab_index >= 0 and self.current_tab_index < len(self.tabs):
            return self.tabs[self.current_tab_index]
        return None
    
    def get_tab(self, tab_index):
        """Get a tab by index."""
        if tab_index >= 0 and tab_index < len(self.tabs):
            return self.tabs[tab_index]
        return None
    
    def get_tab_count(self):
        """Get the number of tabs."""
        return len(self.tabs)
    
    def navigate_current_tab(self, url):
        """Navigate the current tab to a URL."""
        current_tab = self.get_current_tab()
        if current_tab:
            current_tab.navigate(url)
            return True
        return False
    
    def navigate_tab(self, tab_index, url):
        """Navigate a tab to a URL."""
        tab = self.get_tab(tab_index)
        if tab:
            tab.navigate(url)
            return True
        return False
    
    def reload_current_tab(self):
        """Reload the current tab."""
        current_tab = self.get_current_tab()
        if current_tab:
            current_tab.reload()
            return True
        return False
    
    def reload_tab(self, tab_index):
        """Reload a tab."""
        tab = self.get_tab(tab_index)
        if tab:
            tab.reload()
            return True
        return False
    
    def stop_current_tab(self):
        """Stop loading the current tab."""
        current_tab = self.get_current_tab()
        if current_tab:
            current_tab.stop()
            return True
        return False
    
    def stop_tab(self, tab_index):
        """Stop loading a tab."""
        tab = self.get_tab(tab_index)
        if tab:
            tab.stop()
            return True
        return False
    
    def back_current_tab(self):
        """Go back in the current tab."""
        current_tab = self.get_current_tab()
        if current_tab:
            current_tab.back()
            return True
        return False
    
    def back_tab(self, tab_index):
        """Go back in a tab."""
        tab = self.get_tab(tab_index)
        if tab:
            tab.back()
            return True
        return False
    
    def forward_current_tab(self):
        """Go forward in the current tab."""
        current_tab = self.get_current_tab()
        if current_tab:
            current_tab.forward()
            return True
        return False
    
    def forward_tab(self, tab_index):
        """Go forward in a tab."""
        tab = self.get_tab(tab_index)
        if tab:
            tab.forward()
            return True
        return False
    
    def _connect_tab_signals(self, tab, tab_index):
        """Connect tab signals."""
        # Title changed
        tab.title_changed.connect(lambda title: self._on_tab_title_changed(tab_index, title))
        
        # URL changed
        tab.url_changed.connect(lambda url: self._on_tab_url_changed(tab_index, url))
        
        # Icon changed
        tab.icon_changed.connect(lambda icon: self._on_tab_icon_changed(tab_index, icon))
        
        # Loading started
        tab.loading_started.connect(lambda: self._on_tab_loading_started(tab_index))
        
        # Loading finished
        tab.loading_finished.connect(lambda success: self._on_tab_loading_finished(tab_index, success))
        
        # Loading progress
        tab.loading_progress.connect(lambda progress: self._on_tab_loading_progress(tab_index, progress))
    
    def _on_tab_title_changed(self, tab_index, title):
        """Handle tab title changed event."""
        # Emit signal
        self.tab_title_changed.emit(tab_index, title)
        
        # Trigger hook
        self.app_controller.hook_registry.trigger_hook("onTabTitleChanged", tab_index, title)
    
    def _on_tab_url_changed(self, tab_index, url):
        """Handle tab URL changed event."""
        # Emit signal
        self.tab_url_changed.emit(tab_index, url)
        
        # Check security
        self._check_url_security(tab_index, url)
        
        # Add to history
        tab = self.get_tab(tab_index)
        if tab and not tab.private:
            self.app_controller.history_manager.add_history(url.toString(), tab.title())
        
        # Trigger hook
        self.app_controller.hook_registry.trigger_hook("onTabUrlChanged", tab_index, url.toString())
    
    def _on_tab_icon_changed(self, tab_index, icon):
        """Handle tab icon changed event."""
        # Emit signal
        self.tab_icon_changed.emit(tab_index, icon)
    
    def _on_tab_loading_started(self, tab_index):
        """Handle tab loading started event."""
        # Emit signal
        self.page_loading.emit(tab_index)
        
        # Trigger hook
        tab = self.get_tab(tab_index)
        if tab:
            self.app_controller.hook_registry.trigger_hook("onPageLoading", tab_index, tab.url().toString())
    
    def _on_tab_loading_finished(self, tab_index, success):
        """Handle tab loading finished event."""
        # Emit signal
        self.page_loaded.emit(tab_index, success)
        
        # Trigger hook
        tab = self.get_tab(tab_index)
        if tab:
            self.app_controller.hook_registry.trigger_hook("onPageLoaded", tab_index, tab.url().toString(), success)
    
    def _on_tab_loading_progress(self, tab_index, progress):
        """Handle tab loading progress event."""
        # Emit signal
        self.page_load_progress.emit(tab_index, progress)
    
    def _check_url_security(self, tab_index, url):
        """Check URL security and update tab security status."""
        # Get security status
        security_status = self.app_controller.security_manager.check_url_security(url.toString())
        
        # Emit signal
        self.tab_security_changed.emit(tab_index, security_status)
    
    def _on_setting_changed(self, key, value):
        """Handle setting changed event."""
        # Check if setting affects tabs
        if key == "enable_javascript":
            # Update JavaScript setting for all tabs
            for tab in self.tabs:
                tab.page().settings().setAttribute(QWebEnginePage.WebAttribute.JavascriptEnabled, value)
        
        elif key == "enable_plugins":
            # Update plugins setting for all tabs
            for tab in self.tabs:
                tab.page().settings().setAttribute(QWebEnginePage.WebAttribute.PluginsEnabled, value)
        
        elif key == "security_enable_xss_protection":
            # Update XSS protection setting for all tabs
            for tab in self.tabs:
                tab.page().settings().setAttribute(QWebEnginePage.WebAttribute.XSSAuditingEnabled, value)
        
        elif key == "enable_developer_tools":
            # Update developer tools setting for all tabs
            for tab in self.tabs:
                tab.page().settings().setAttribute(QWebEnginePage.WebAttribute.DeveloperExtrasEnabled, value)
</file>

<file path="src/core/web_engine.py">
#!/usr/bin/env python3
# NebulaFusion Browser - Web Engine Manager

import os
import sys
import logging
from PyQt6.QtCore import QObject, pyqtSignal, QUrl
from PyQt6.QtWebEngineCore import (
    QWebEngineProfile,
    QWebEnginePage,
    QWebEngineSettings,
    QWebEngineCookieStore,
)
from PyQt6.QtWebEngineWidgets import QWebEngineView


class WebEngineManager(QObject):
    """
    Manager for web engine functionality.
    Handles profiles, settings, and web engine configuration.
    """

    # Signals
    profile_created = pyqtSignal(str)  # profile_name
    profile_removed = pyqtSignal(str)  # profile_name

    def __init__(self, app_controller):
        """Initialize the web engine manager."""
        super().__init__()
        self.app_controller = app_controller

        # Profiles
        self.profiles = {}

        # Default profile
        self.default_profile = None

        # Private profile
        self.private_profile = None

        # Initialize web engine
        self.initialized = False

    def initialize(self):
        """Initialize the web engine manager."""
        self.app_controller.logger.info("Initializing web engine manager...")

        # Create default profile
        self.default_profile = self.create_profile("default", is_private=False)

        # Create private profile
        self.private_profile = self.create_profile("private", is_private=True)

        # Configure default profile
        self._configure_default_profile()

        # Configure private profile
        self._configure_private_profile()

        # Update state
        self.initialized = True

        self.app_controller.logger.info("Web engine manager initialized.")

        return True

    def cleanup(self):
        """Clean up the web engine manager."""
        self.app_controller.logger.info("Cleaning up web engine manager...")

        # Clear profiles
        self.profiles.clear()

        # Update state
        self.initialized = False

        self.app_controller.logger.info("Web engine manager cleaned up.")

        return True

    def _configure_default_profile(self):
        """Configure default profile."""
        # Get profile
        profile = self.default_profile

        # Configure settings
        settings = profile.settings()

        # Enable JavaScript
        settings.setAttribute(QWebEngineSettings.WebAttribute.JavascriptEnabled, True)

        # Enable plugins
        settings.setAttribute(QWebEngineSettings.WebAttribute.PluginsEnabled, True)

        # Enable local storage
        settings.setAttribute(QWebEngineSettings.WebAttribute.LocalStorageEnabled, True)

        # Enable developer tools
        settings.setAttribute(
            QWebEngineSettings.WebAttribute.JavascriptCanOpenWindows, True
        )

        # Enable fullscreen
        settings.setAttribute(
            QWebEngineSettings.WebAttribute.FullScreenSupportEnabled, True
        )

        # Enable PDF viewer
        settings.setAttribute(QWebEngineSettings.WebAttribute.PdfViewerEnabled, True)

        # Enable autoload images
        settings.setAttribute(QWebEngineSettings.WebAttribute.AutoLoadImages, True)

        # Enable WebGL
        settings.setAttribute(QWebEngineSettings.WebAttribute.WebGLEnabled, True)

        # Enable WebRTC
        settings.setAttribute(
            QWebEngineSettings.WebAttribute.WebRTCPublicInterfacesOnly, False
        )

        # Set default font sizes
        settings.setFontSize(QWebEngineSettings.FontSize.DefaultFontSize, 16)
        settings.setFontSize(QWebEngineSettings.FontSize.DefaultFixedFontSize, 13)
        settings.setFontSize(QWebEngineSettings.FontSize.MinimumFontSize, 10)
        settings.setFontSize(QWebEngineSettings.FontSize.MinimumLogicalFontSize, 10)

        # Set default font families
        settings.setFontFamily(QWebEngineSettings.FontFamily.StandardFont, "Arial")
        settings.setFontFamily(QWebEngineSettings.FontFamily.FixedFont, "Courier New")
        settings.setFontFamily(
            QWebEngineSettings.FontFamily.SerifFont, "Times New Roman"
        )
        settings.setFontFamily(QWebEngineSettings.FontFamily.SansSerifFont, "Arial")
        settings.setFontFamily(
            QWebEngineSettings.FontFamily.CursiveFont, "Comic Sans MS"
        )
        settings.setFontFamily(QWebEngineSettings.FontFamily.FantasyFont, "Impact")

        # Configure HTTP cache
        cache_dir = os.path.expanduser("~/.nebulafusion/cache")
        os.makedirs(cache_dir, exist_ok=True)
        profile.setCachePath(cache_dir)
        profile.setHttpCacheType(QWebEngineProfile.HttpCacheType.DiskHttpCache)
        profile.setHttpCacheMaximumSize(100 * 1024 * 1024)  # 100 MB

        # Configure persistent storage
        data_dir = os.path.expanduser("~/.nebulafusion/data")
        os.makedirs(data_dir, exist_ok=True)
        profile.setPersistentStoragePath(data_dir)

        # Configure user agent
        user_agent = profile.httpUserAgent()
        user_agent += " NebulaFusion/1.0"
        profile.setHttpUserAgent(user_agent)

        # Configure cookies
        cookie_store = profile.cookieStore()
        cookie_store.setCookieFilter(lambda cookie, url: True)

    def _configure_private_profile(self):
        """Configure private profile."""
        # Get profile
        profile = self.private_profile

        # Configure settings
        settings = profile.settings()

        # Enable JavaScript
        settings.setAttribute(QWebEngineSettings.WebAttribute.JavascriptEnabled, True)

        # Enable plugins
        settings.setAttribute(QWebEngineSettings.WebAttribute.PluginsEnabled, True)

        # Enable local storage
        settings.setAttribute(QWebEngineSettings.WebAttribute.LocalStorageEnabled, True)

        # Enable developer tools
        settings.setAttribute(
            QWebEngineSettings.WebAttribute.JavascriptCanOpenWindows, True
        )

        # Enable fullscreen
        settings.setAttribute(
            QWebEngineSettings.WebAttribute.FullScreenSupportEnabled, True
        )

        # Enable PDF viewer
        settings.setAttribute(QWebEngineSettings.WebAttribute.PdfViewerEnabled, True)

        # Enable autoload images
        settings.setAttribute(QWebEngineSettings.WebAttribute.AutoLoadImages, True)

        # Enable WebGL
        settings.setAttribute(QWebEngineSettings.WebAttribute.WebGLEnabled, True)

        # Enable WebRTC
        settings.setAttribute(
            QWebEngineSettings.WebAttribute.WebRTCPublicInterfacesOnly, True
        )

        # Set default font sizes
        settings.setFontSize(QWebEngineSettings.FontSize.DefaultFontSize, 16)
        settings.setFontSize(QWebEngineSettings.FontSize.DefaultFixedFontSize, 13)
        settings.setFontSize(QWebEngineSettings.FontSize.MinimumFontSize, 10)
        settings.setFontSize(QWebEngineSettings.FontSize.MinimumLogicalFontSize, 10)

        # Set default font families
        settings.setFontFamily(QWebEngineSettings.FontFamily.StandardFont, "Arial")
        settings.setFontFamily(QWebEngineSettings.FontFamily.FixedFont, "Courier New")
        settings.setFontFamily(
            QWebEngineSettings.FontFamily.SerifFont, "Times New Roman"
        )
        settings.setFontFamily(QWebEngineSettings.FontFamily.SansSerifFont, "Arial")
        settings.setFontFamily(
            QWebEngineSettings.FontFamily.CursiveFont, "Comic Sans MS"
        )
        settings.setFontFamily(QWebEngineSettings.FontFamily.FantasyFont, "Impact")

        # Configure HTTP cache
        profile.setHttpCacheType(QWebEngineProfile.HttpCacheType.MemoryHttpCache)

        # Configure user agent
        user_agent = profile.httpUserAgent()
        user_agent += " NebulaFusion/1.0 (Private)"
        profile.setHttpUserAgent(user_agent)

        # Configure cookies
        cookie_store = profile.cookieStore()
        cookie_store.setCookieFilter(lambda cookie, url: True)

    def create_profile(self, name, is_private=False):
        """Create a web engine profile."""
        try:
            # Check if profile already exists (for named profiles)
            if not is_private and name in self.profiles:
                self.app_controller.logger.warning(f"Profile already exists: {name}")
                return self.profiles[name]

            if is_private:
                # Off-the-record profiles are typically not named for persistence.
                # If you need to refer to it, you might store it under a generic key.
                # Let's assume "private" is just a logical name for our manager.
                profile = QWebEngineProfile(
                    parent=self.app_controller
                )  # No storageName means off-the-record
                self.profiles["private_instance"] = (
                    profile  # Store it if needed for later reference
                )
            else:
                profile = QWebEngineProfile(name, parent=self.app_controller)
                self.profiles[name] = profile

            # Emit signal (use the logical name for private profiles if needed)
            profile_key_for_signal = "private" if is_private else name
            self.profile_created.emit(profile_key_for_signal)

            # Trigger hook
            self.app_controller.hook_registry.trigger_hook(
                "onProfileCreated", profile_key_for_signal, is_private
            )

            self.app_controller.logger.info(
                f"Profile created: {profile_key_for_signal} (private: {is_private})"
            )

            return profile

        except Exception as e:
            self.app_controller.logger.error(f"Error creating profile: {e}")
            return None

    def remove_profile(self, name):
        """Remove a web engine profile."""
        try:
            # Check if profile exists
            if name not in self.profiles:
                self.app_controller.logger.warning(f"Profile not found: {name}")
                return False

            # Check if profile is default or private
            if name == "default" or name == "private":
                self.app_controller.logger.warning(
                    f"Cannot remove built-in profile: {name}"
                )
                return False

            # Remove profile
            del self.profiles[name]

            # Emit signal
            self.profile_removed.emit(name)

            # Trigger hook
            self.app_controller.hook_registry.trigger_hook("onProfileRemoved", name)

            self.app_controller.logger.info(f"Profile removed: {name}")

            return True

        except Exception as e:
            self.app_controller.logger.error(f"Error removing profile: {e}")
            return False

    def get_profile(self, name):
        """Get a web engine profile."""
        # Check if profile exists
        if name not in self.profiles:
            self.app_controller.logger.warning(f"Profile not found: {name}")
            return None

        return self.profiles[name]

    def get_default_profile(self):
        """Get the default web engine profile."""
        return self.default_profile

    def get_private_profile(self):
        """Get the private web engine profile."""
        return self.private_profile

    def create_page(self, profile_name=None):
        """Create a web engine page."""
        try:
            # Get profile
            if profile_name:
                profile = self.get_profile(profile_name)
                if not profile:
                    self.app_controller.logger.warning(
                        f"Profile not found: {profile_name}"
                    )
                    profile = self.default_profile
            else:
                profile = self.default_profile

            # Create page
            page = QWebEnginePage(profile)

            # Configure page
            self._configure_page(page)

            return page

        except Exception as e:
            self.app_controller.logger.error(f"Error creating page: {e}")
            return None

    def _configure_page(self, page):
        """Configure a web engine page."""
        # Connect signals
        page.loadStarted.connect(lambda: self._on_load_started(page))
        page.loadProgress.connect(
            lambda progress: self._on_load_progress(page, progress)
        )
        page.loadFinished.connect(lambda success: self._on_load_finished(page, success))
        page.urlChanged.connect(lambda url: self._on_url_changed(page, url))
        page.titleChanged.connect(lambda title: self._on_title_changed(page, title))
        page.iconChanged.connect(lambda icon: self._on_icon_changed(page, icon))
        page.fullScreenRequested.connect(
            lambda request: self._on_fullscreen_requested(page, request)
        )
        page.featurePermissionRequested.connect(
            lambda url, feature: self._on_feature_permission_requested(
                page, url, feature
            )
        )
        page.certificateError.connect(
            lambda error: self._on_certificate_error(page, error)
        )
        page.authenticationRequired.connect(
            lambda url, authenticator: self._on_authentication_required(
                page, url, authenticator
            )
        )
        page.proxyAuthenticationRequired.connect(
            lambda url, authenticator, proxy_host: self._on_proxy_authentication_required(
                page, url, authenticator, proxy_host
            )
        )
        page.renderProcessTerminated.connect(
            lambda status, exit_code: self._on_render_process_terminated(
                page, status, exit_code
            )
        )

    def _on_load_started(self, page):
        """Handle load started event."""
        # Trigger hook
        self.app_controller.hook_registry.trigger_hook("onPageLoadStarted", page)

    def _on_load_progress(self, page, progress):
        """Handle load progress event."""
        # Trigger hook
        self.app_controller.hook_registry.trigger_hook(
            "onPageLoadProgress", page, progress
        )

    def _on_load_finished(self, page, success):
        """Handle load finished event."""
        # Get URL
        url = page.url().toString()

        # Get title
        title = page.title()

        # Add to history
        if success and url and not url.startswith("about:"):
            self.app_controller.history_manager.add_history(url, title)

        # Trigger hook
        self.app_controller.hook_registry.trigger_hook(
            "onPageLoadFinished", page, success
        )

    def _on_url_changed(self, page, url):
        """Handle URL changed event."""
        # Trigger hook
        self.app_controller.hook_registry.trigger_hook("onPageUrlChanged", page, url)

    def _on_title_changed(self, page, title):
        """Handle title changed event."""
        # Trigger hook
        self.app_controller.hook_registry.trigger_hook(
            "onPageTitleChanged", page, title
        )

    def _on_icon_changed(self, page, icon):
        """Handle icon changed event."""
        # Trigger hook
        self.app_controller.hook_registry.trigger_hook("onPageIconChanged", page, icon)

    def _on_fullscreen_requested(self, page, request):
        """Handle fullscreen requested event."""
        # Accept request
        request.accept()

        # Trigger hook
        self.app_controller.hook_registry.trigger_hook(
            "onPageFullscreenRequested", page, request.toggleOn()
        )

    def _on_feature_permission_requested(self, page, url, feature):
        """Handle feature permission requested event."""
        # Accept all permissions for now
        page.setFeaturePermission(
            url, feature, QWebEnginePage.PermissionPolicy.PermissionGrantedByUser
        )

        # Trigger hook
        self.app_controller.hook_registry.trigger_hook(
            "onPageFeaturePermissionRequested", page, url, feature
        )

    def _on_certificate_error(self, page, error):
        """Handle certificate error event."""
        # Reject certificate
        error.rejectCertificate()

        # Trigger hook
        self.app_controller.hook_registry.trigger_hook(
            "onPageCertificateError", page, error
        )

    def _on_authentication_required(self, page, url, authenticator):
        """Handle authentication required event."""
        # Trigger hook
        self.app_controller.hook_registry.trigger_hook(
            "onPageAuthenticationRequired", page, url, authenticator
        )

    def _on_proxy_authentication_required(self, page, url, authenticator, proxy_host):
        """Handle proxy authentication required event."""
        # Trigger hook
        self.app_controller.hook_registry.trigger_hook(
            "onPageProxyAuthenticationRequired", page, url, authenticator, proxy_host
        )

    def _on_render_process_terminated(self, page, status, exit_code):
        """Handle render process terminated event."""
        # Trigger hook
        self.app_controller.hook_registry.trigger_hook(
            "onPageRenderProcessTerminated", page, status, exit_code
        )

    def create_view(self, profile_name=None):
        """Create a web engine view."""
        try:
            # Create page
            page = self.create_page(profile_name)

            # Create view
            view = QWebEngineView()
            view.setPage(page)

            # Configure view
            self._configure_view(view)

            return view

        except Exception as e:
            self.app_controller.logger.error(f"Error creating view: {e}")
            return None

    def _configure_view(self, view):
        """Configure a web engine view."""
        # Connect signals
        view.loadStarted.connect(lambda: self._on_view_load_started(view))
        view.loadProgress.connect(
            lambda progress: self._on_view_load_progress(view, progress)
        )
        view.loadFinished.connect(
            lambda success: self._on_view_load_finished(view, success)
        )
        view.urlChanged.connect(lambda url: self._on_view_url_changed(view, url))
        view.titleChanged.connect(
            lambda title: self._on_view_title_changed(view, title)
        )
        view.iconChanged.connect(lambda icon: self._on_view_icon_changed(view, icon))

    def _on_view_load_started(self, view):
        """Handle view load started event."""
        # Trigger hook
        self.app_controller.hook_registry.trigger_hook("onViewLoadStarted", view)

    def _on_view_load_progress(self, view, progress):
        """Handle view load progress event."""
        # Trigger hook
        self.app_controller.hook_registry.trigger_hook(
            "onViewLoadProgress", view, progress
        )

    def _on_view_load_finished(self, view, success):
        """Handle view load finished event."""
        # Trigger hook
        self.app_controller.hook_registry.trigger_hook(
            "onViewLoadFinished", view, success
        )

    def _on_view_url_changed(self, view, url):
        """Handle view URL changed event."""
        # Trigger hook
        self.app_controller.hook_registry.trigger_hook("onViewUrlChanged", view, url)

    def _on_view_title_changed(self, view, title):
        """Handle view title changed event."""
        # Trigger hook
        self.app_controller.hook_registry.trigger_hook(
            "onViewTitleChanged", view, title
        )

    def _on_view_icon_changed(self, view, icon):
        """Handle view icon changed event."""
        # Trigger hook
        self.app_controller.hook_registry.trigger_hook("onViewIconChanged", view, icon)
</file>

<file path="src/main.py">
#!/usr/bin/env python3
# NebulaFusion Browser - Main Entry Point

import os
import sys
import logging
import traceback
from PyQt6.QtWidgets import QApplication, QMessageBox
from PyQt6.QtCore import QUrl

# Add parent directory to path
project_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.append(project_root)

# Import browser modules
from src.core.application import Application


def setup_logging():
    """Set up logging configuration."""
    # Define the log directory and file path, consistent with Application class
    log_dir = os.path.expanduser("~/.nebulafusion/logs")
    # Create the log directory if it doesn't exist
    os.makedirs(log_dir, exist_ok=True)
    log_file_path = os.path.join(log_dir, "nebulafusion.log")

    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
        handlers=[
            logging.StreamHandler(),
            logging.FileHandler(log_file_path),  # Use the full path
        ],
    )


def global_exception_hook(exctype, value, tb):
    """Global exception handler to log uncaught exceptions and show a dialog."""
    error_msg = ''.join(traceback.format_exception(exctype, value, tb))
    logging.critical(f"Uncaught exception:\n{error_msg}")
    try:
        # Show a user-friendly error dialog if possible
        QMessageBox.critical(None, "Critical Error", f"An unexpected error occurred. See log for details.\n\n{value}")
    except Exception:
        pass  # In case QApplication is not available
    # Call the default excepthook
    sys.__excepthook__(exctype, value, tb)


def main():
    """Main entry point."""
    # Set up logging
    setup_logging()

    # Set global exception hook
    sys.excepthook = global_exception_hook

    # Create application
    app = QApplication(sys.argv)
    app.setApplicationName("NebulaFusion")
    app.setApplicationVersion("1.0.0")
    app.setOrganizationName("NebulaFusion")
    app.setOrganizationDomain("nebulafusion.io")

    # Create application controller
    app_controller = Application()

    # Initialize application
    app_controller.initialize()

    # Show main window
    app_controller.show()

    # Start application
    sys.exit(app.exec())


if __name__ == "__main__":
    main()
</file>

<file path="src/plugins/__init__.py">
#!/usr/bin/env python3
# NebulaFusion Plugin Template

from src.plugins.plugin_base import PluginBase

class Plugin(PluginBase):
    """
    Template plugin for NebulaFusion browser.
    """
    
    def __init__(self, api):
        """Initialize the plugin."""
        super().__init__(api)
        
        # Plugin state
        self.initialized = False
    
    def activate(self):
        """Activate the plugin."""
        # Register hooks
        self.api.hooks.register_hook("onBrowserStart", self.plugin_id, self.on_browser_start)
        self.api.hooks.register_hook("onBrowserExit", self.plugin_id, self.on_browser_exit)
        
        # Initialize plugin
        self.initialized = True
        
        return True
    
    def deactivate(self):
        """Deactivate the plugin."""
        # Unregister hooks
        self.api.hooks.unregister_all_hooks(self.plugin_id)
        
        # Clean up
        self.initialized = False
        
        return True
    
    def configure(self):
        """Configure the plugin."""
        # Show configuration dialog
        self.api.ui.show_message("Plugin Configuration", "This is a template plugin.")
    
    def on_browser_start(self):
        """Handle browser start event."""
        self.api.logger.info("Browser started")
    
    def on_browser_exit(self):
        """Handle browser exit event."""
        self.api.logger.info("Browser exiting")
</file>

<file path="src/plugins/hook_registry.py">
#!/usr/bin/env python3
# NebulaFusion Browser - Hook Registry

import os
import sys
from PyQt6.QtCore import QObject, pyqtSignal


class HookRegistry(QObject):
    """
    Registry for browser hooks.
    Handles registering, unregistering, and triggering hooks.
    """

    # Signals
    hook_registered = pyqtSignal(str, str)  # hook_name, plugin_id
    hook_unregistered = pyqtSignal(str, str)  # hook_name, plugin_id
    hook_triggered = pyqtSignal(str, list)  # hook_name, args

    def __init__(self, app_controller):
        """Initialize the hook registry."""
        super().__init__()
        self.app_controller = app_controller

        # Hooks
        self._hooks = {}

        # Available hooks
        self.available_hooks = [
            # Browser lifecycle hooks
            "onBrowserStart",
            "onBrowserExit",
            "onProfileCreated",
            # Tab hooks
            "onTabCreated",
            "onTabClosed",
            "onTabSelected",
            "onTabTitleChanged",
            "onTabUrlChanged",
            # Page hooks
            "onPageLoading",
            "onPageLoaded",
            # Navigation hooks
            "onUrlChanged",
            # Download hooks
            "onDownloadStarted",
            "onDownloadFinished",
            # Bookmark hooks
            "onBookmarkAdded",
            "onBookmarkRemoved",
            "onBookmarkUpdated",
            "onBookmarkFolderAdded",
            "onBookmarkFolderRemoved",
            "onBookmarkFolderRenamed",
            "onBookmarksImported",
            "onBookmarksExported",
            # History hooks
            "onHistoryAdded",
            "onHistoryRemoved",
            "onHistoryCleared",
            # Cookie hooks
            "onCookieAdded",
            "onCookieRemoved",
            "onCookiesCleared",
            # Context menu hooks
            "onContextMenu",
            # UI hooks
            "onToolbarCreated",
            "onStatusBarCreated",
            "onAddressBarCreated",
            # Settings hooks
            "onSettingsChanged",
            "onThemeChanged",  # <--- ADD THIS LINE
            # Unique feature hooks
            "onRealityAugmentation",
            "onCollaborativeSession",
            "onContentTransform",
            "onTimeTravelSnapshot",
            "onDimensionalTabChange",
            "onVoiceCommand",
        ]

    def initialize(self):
        """Initialize the hook registry."""
        self.app_controller.logger.info("Initializing hook registry...")

        # Initialize hooks
        for hook_name in self.available_hooks:
            self._hooks[hook_name] = {}

        self.app_controller.logger.info("Hook registry initialized.")

    def register_hook(self, hook_name, plugin_id, callback):
        """Register a hook."""
        # Check if hook exists
        if hook_name not in self.hooks:
            self.app_controller.logger.warning(f"Hook not found: {hook_name}")
            return False

        # Register hook
        self.hooks[hook_name][plugin_id] = callback

        # Emit signal
        self.hook_registered.emit(hook_name, plugin_id)

        self.app_controller.logger.info(f"Hook registered: {hook_name} by {plugin_id}")

        return True

    def unregister_hook(self, hook_name, plugin_id):
        """Unregister a hook."""
        # Check if hook exists
        if hook_name not in self.hooks:
            self.app_controller.logger.warning(f"Hook not found: {hook_name}")
            return False

        # Check if plugin has registered this hook
        if plugin_id not in self.hooks[hook_name]:
            self.app_controller.logger.warning(
                f"Plugin has not registered hook: {hook_name}"
            )
            return False

        # Unregister hook
        del self.hooks[hook_name][plugin_id]

        # Emit signal
        self.hook_unregistered.emit(hook_name, plugin_id)

        self.app_controller.logger.info(
            f"Hook unregistered: {hook_name} by {plugin_id}"
        )

        return True

    def unregister_all_hooks(self, plugin_id):
        """Unregister all hooks for a plugin."""
        # Unregister hooks
        for hook_name in self.hooks:
            if plugin_id in self.hooks[hook_name]:
                self.unregister_hook(hook_name, plugin_id)

    def trigger_hook(self, hook_name, *args, **kwargs):
        if hook_name not in self._hooks:
            self.app_controller.logger.warning(f"Hook not found: {hook_name}")
            return

        self.app_controller.logger.info(f"Triggering hook: {hook_name}")

        for plugin_id, callback in list(self._hooks[hook_name].items()):
            try:
                callback(*args, **kwargs)
            except Exception as e:
                import traceback

                tb = traceback.format_exc()
                self.app_controller.logger.error(
                    f"Error in hook {hook_name} from plugin {plugin_id}: {e}\n{tb}"
                )
                # Disable the faulty plugin
                try:
                    self.app_controller.plugin_manager.disable_plugin(plugin_id)
                    self.app_controller.logger.warning(
                        f"Plugin {plugin_id} disabled due to hook error."
                    )
                except Exception as disable_err:
                    self.app_controller.logger.error(
                        f"Failed to disable plugin {plugin_id}: {disable_err}"
                    )

    def get_registered_hooks(self, plugin_id=None):
        """Get registered hooks."""
        if plugin_id:
            # Get hooks for plugin
            registered_hooks = {}
            for hook_name in self.hooks:
                if plugin_id in self.hooks[hook_name]:
                    registered_hooks[hook_name] = True
            return registered_hooks
        else:
            # Get all registered hooks
            registered_hooks = {}
            for hook_name in self.hooks:
                if self.hooks[hook_name]:
                    registered_hooks[hook_name] = list(self.hooks[hook_name].keys())
            return registered_hooks

    def get_available_hooks(self):
        """Get available hooks."""
        return self.available_hooks
</file>

<file path="src/plugins/my_toolbar_button_plugin/__init__.py">
#!/usr/bin/env python3
# NebulaFusion Browser - My Toolbar Button Plugin

from src.plugins.plugin_base import PluginBase


class Plugin(PluginBase):
    """
    My Toolbar Button Plugin for NebulaFusion browser.
    Adds a button to the toolbar that displays a message when clicked.
    """

    def __init__(self, api):
        """Initialize the plugin."""
        super().__init__(api)

    def activate(self):
        """Activate the plugin."""
        return True

    def deactivate(self):
        """Deactivate the plugin."""
        return True

    def onToolbarCreated(self):
        """Called when the browser's toolbar is created."""
        try:
            # Add a button to the toolbar
            self.api.ui.add_toolbar_button(
                button_id="my_button",  # It's good practice to add a unique ID
                text="My Button",
                tooltip="Click me!",
                callback=self.on_button_clicked,
            )

            self.api.logger.info("My Toolbar Button added.")
        except Exception as e:
            self.api.logger.error(f"Error adding toolbar button: {e}")

    def on_button_clicked(self):
        """Called when the button is clicked."""
        self.api.ui.show_message("My Button", "Hello from my toolbar button plugin!")
</file>

<file path="src/plugins/my_toolbar_button_plugin/manifest.json">
{
    "id": "my_toolbar_button_plugin",
    "name": "My Toolbar Button Plugin",
    "version": "1.0.0",
    "author": "Roo",
    "description": "Adds a button to the toolbar that displays a message when clicked.",
    "permissions": [
        "tabs",
        "bookmarks",
        "history"
    ],
    "hooks": [
        "onToolbarCreated"
    ]
}
</file>

<file path="src/plugins/plugin_api.py">
#!/usr/bin/env python3
# NebulaFusion Browser - Plugin API

import os
import sys
from PyQt6.QtCore import QObject


class PluginAPI(QObject):
    """
    API for browser plugins.
    Provides access to browser functionality for plugins.
    """

    def __init__(self, app_controller, plugin_id, manifest):
        """Initialize the plugin API."""
        super().__init__()
        self.app_controller = app_controller
        self.plugin_id = plugin_id
        self.manifest = manifest

        # Initialize API components
        self._initialize_api()

    def _initialize_api(self):
        """Initialize API components."""
        # Logger
        self.logger = PluginLogger(self.app_controller, self.plugin_id)

        # Hooks
        self.hooks = PluginHooks(self.app_controller, self.plugin_id)

        # Tabs
        self.tabs = PluginTabs(self.app_controller, self.plugin_id)

        # Bookmarks
        self.bookmarks = PluginBookmarks(self.app_controller, self.plugin_id)

        # History
        self.history = PluginHistory(self.app_controller, self.plugin_id)

        # Downloads
        self.downloads = PluginDownloads(self.app_controller, self.plugin_id)

        # Cookies
        self.cookies = PluginCookies(self.app_controller, self.plugin_id)

        # Storage
        self.storage = PluginStorage(self.app_controller, self.plugin_id)

        # UI
        self.ui = PluginUI(self.app_controller, self.plugin_id)

        # Network
        self.network = PluginNetwork(self.app_controller, self.plugin_id)

        # Filesystem
        self.filesystem = PluginFilesystem(self.app_controller, self.plugin_id)

        # Settings
        self.settings = PluginSettings(self.app_controller, self.plugin_id)

        # Unique features
        self.reality = PluginReality(self.app_controller, self.plugin_id)
        self.collaboration = PluginCollaboration(self.app_controller, self.plugin_id)
        self.transformation = PluginTransformation(self.app_controller, self.plugin_id)
        self.timetravel = PluginTimeTravel(self.app_controller, self.plugin_id)
        self.dimensions = PluginDimensions(self.app_controller, self.plugin_id)
        self.voice = PluginVoice(self.app_controller, self.plugin_id)

    def has_permission(self, permission):
        """Check if the plugin has a permission."""
        return permission in self.manifest.get("permissions", [])


class PluginLogger:
    """Logger for plugins."""

    def __init__(self, app_controller, plugin_id):
        """Initialize the plugin logger."""
        self.app_controller = app_controller
        self.plugin_id = plugin_id

    def debug(self, message):
        """Log a debug message."""
        self.app_controller.logger.debug(f"[Plugin: {self.plugin_id}] {message}")

    def info(self, message):
        """Log an info message."""
        self.app_controller.logger.info(f"[Plugin: {self.plugin_id}] {message}")

    def warning(self, message):
        """Log a warning message."""
        self.app_controller.logger.warning(f"[Plugin: {self.plugin_id}] {message}")

    def error(self, message):
        """Log an error message."""
        self.app_controller.logger.error(f"[Plugin: {self.plugin_id}] {message}")


class PluginHooks:
    """Hooks for plugins."""

    def __init__(self, app_controller, plugin_id):
        """Initialize the plugin hooks."""
        self.app_controller = app_controller
        self.plugin_id = plugin_id

    def register_hook(self, hook_name, plugin_id, callback):
        """Register a hook."""
        return self.app_controller.hook_registry.register_hook(
            hook_name, plugin_id, callback
        )

    def unregister_hook(self, hook_name, plugin_id):
        """Unregister a hook."""
        return self.app_controller.hook_registry.unregister_hook(hook_name, plugin_id)

    def unregister_all_hooks(self, plugin_id):
        """Unregister all hooks for a plugin."""
        return self.app_controller.hook_registry.unregister_all_hooks(plugin_id)

    def get_registered_hooks(self, plugin_id=None):
        """Get registered hooks."""
        return self.app_controller.hook_registry.get_registered_hooks(plugin_id)

    def get_available_hooks(self):
        """Get available hooks."""
        return self.app_controller.hook_registry.get_available_hooks()


class PluginTabs:
    """Tabs API for plugins."""

    def __init__(self, app_controller, plugin_id):
        """Initialize the plugin tabs API."""
        self.app_controller = app_controller
        self.plugin_id = plugin_id

    def get_current_tab(self):
        """Get the current tab."""
        return self.app_controller.tab_manager.get_current_tab()

    def get_tab(self, tab_index):
        """Get a tab by index."""
        return self.app_controller.tab_manager.get_tab(tab_index)

    def get_tab_count(self):
        """Get the number of tabs."""
        return self.app_controller.tab_manager.get_tab_count()

    def new_tab(self, url=None, private=False):
        """Create a new tab."""
        return self.app_controller.tab_manager.new_tab(url, private)

    def close_tab(self, tab_index):
        """Close a tab."""
        return self.app_controller.tab_manager.close_tab(tab_index)

    def select_tab(self, tab_index):
        """Select a tab."""
        return self.app_controller.tab_manager.select_tab(tab_index)

    def navigate(self, url, tab_index=None):
        """Navigate a tab to a URL."""
        if tab_index is None:
            return self.app_controller.tab_manager.navigate_current_tab(url)
        else:
            return self.app_controller.tab_manager.navigate_tab(tab_index, url)

    def reload(self, tab_index=None):
        """Reload a tab."""
        if tab_index is None:
            return self.app_controller.tab_manager.reload_current_tab()
        else:
            return self.app_controller.tab_manager.reload_tab(tab_index)

    def stop(self, tab_index=None):
        """Stop loading a tab."""
        if tab_index is None:
            return self.app_controller.tab_manager.stop_current_tab()
        else:
            return self.app_controller.tab_manager.stop_tab(tab_index)

    def back(self, tab_index=None):
        """Go back in a tab."""
        if tab_index is None:
            return self.app_controller.tab_manager.back_current_tab()
        else:
            return self.app_controller.tab_manager.back_tab(tab_index)

    def forward(self, tab_index=None):
        """Go forward in a tab."""
        if tab_index is None:
            return self.app_controller.tab_manager.forward_current_tab()
        else:
            return self.app_controller.tab_manager.forward_tab(tab_index)


class PluginBookmarks:
    """Bookmarks API for plugins."""

    def __init__(self, app_controller, plugin_id):
        """Initialize the plugin bookmarks API."""
        self.app_controller = app_controller
        self.plugin_id = plugin_id

    def add_bookmark(self, url, title, folder="Bookmarks Bar"):
        """Add a bookmark."""
        return self.app_controller.bookmarks_manager.add_bookmark(url, title, folder)

    def remove_bookmark(self, url, folder=None):
        """Remove a bookmark."""
        return self.app_controller.bookmarks_manager.remove_bookmark(url, folder)

    def update_bookmark(self, url, new_url=None, new_title=None, new_folder=None):
        """Update a bookmark."""
        return self.app_controller.bookmarks_manager.update_bookmark(
            url, new_url, new_title, new_folder
        )

    def add_folder(self, folder_name):
        """Add a bookmark folder."""
        return self.app_controller.bookmarks_manager.add_folder(folder_name)

    def remove_folder(self, folder_name):
        """Remove a bookmark folder."""
        return self.app_controller.bookmarks_manager.remove_folder(folder_name)

    def rename_folder(self, old_name, new_name):
        """Rename a bookmark folder."""
        return self.app_controller.bookmarks_manager.rename_folder(old_name, new_name)

    def get_bookmarks(self, folder=None):
        """Get bookmarks."""
        return self.app_controller.bookmarks_manager.get_bookmarks(folder)

    def get_folders(self):
        """Get bookmark folders."""
        return self.app_controller.bookmarks_manager.get_folders()

    def search_bookmarks(self, query):
        """Search bookmarks."""
        return self.app_controller.bookmarks_manager.search_bookmarks(query)


class PluginHistory:
    """History API for plugins."""

    def __init__(self, app_controller, plugin_id):
        """Initialize the plugin history API."""
        self.app_controller = app_controller
        self.plugin_id = plugin_id

    def add_history(self, url, title):
        """Add a URL to history."""
        return self.app_controller.history_manager.add_history(url, title)

    def remove_history(self, url):
        """Remove a URL from history."""
        return self.app_controller.history_manager.remove_history(url)

    def clear_history(self):
        """Clear all history."""
        return self.app_controller.history_manager.clear_history()

    def get_history(self, limit=100, offset=0):
        """Get history entries."""
        return self.app_controller.history_manager.get_history(limit, offset)

    def search_history(self, query, limit=100, offset=0):
        """Search history entries."""
        return self.app_controller.history_manager.search_history(query, limit, offset)

    def get_history_by_date(self, date, limit=100, offset=0):
        """Get history entries for a specific date."""
        return self.app_controller.history_manager.get_history_by_date(
            date, limit, offset
        )

    def get_history_by_domain(self, domain, limit=100, offset=0):
        """Get history entries for a specific domain."""
        return self.app_controller.history_manager.get_history_by_domain(
            domain, limit, offset
        )

    def get_most_visited(self, limit=10):
        """Get most visited URLs."""
        return self.app_controller.history_manager.get_most_visited(limit)

    def get_recent(self, limit=10):
        """Get recent URLs."""
        return self.app_controller.history_manager.get_recent(limit)


class PluginDownloads:
    """Downloads API for plugins."""

    def __init__(self, app_controller, plugin_id):
        """Initialize the plugin downloads API."""
        self.app_controller = app_controller
        self.plugin_id = plugin_id

    def download_url(self, url, path=None):
        """Download a URL."""
        return self.app_controller.download_manager.download_url(url, path)

    def cancel_download(self, download_id):
        """Cancel a download."""
        return self.app_controller.download_manager.cancel_download(download_id)

    def pause_download(self, download_id):
        """Pause a download."""
        return self.app_controller.download_manager.pause_download(download_id)

    def resume_download(self, download_id):
        """Resume a download."""
        return self.app_controller.download_manager.resume_download(download_id)

    def get_download(self, download_id):
        """Get a download by ID."""
        return self.app_controller.download_manager.get_download(download_id)

    def get_downloads(self):
        """Get all downloads."""
        return self.app_controller.download_manager.get_downloads()

    def clear_completed_downloads(self):
        """Clear completed downloads."""
        return self.app_controller.download_manager.clear_completed_downloads()


class PluginCookies:
    """Cookies API for plugins."""

    def __init__(self, app_controller, plugin_id):
        """Initialize the plugin cookies API."""
        self.app_controller = app_controller
        self.plugin_id = plugin_id

    def get_cookies_for_url(self, url):
        """Get cookies for a URL."""
        return self.app_controller.cookies_manager.get_cookies_for_url(url)

    def set_cookie(self, cookie):
        """Set a cookie."""
        return self.app_controller.cookies_manager.set_cookie(cookie)

    def delete_cookie(self, cookie):
        """Delete a cookie."""
        return self.app_controller.cookies_manager.delete_cookie(cookie)

    def delete_cookies_for_url(self, url, name=None):
        """Delete cookies for a URL."""
        return self.app_controller.cookies_manager.delete_cookies_for_url(url, name)

    def delete_all_cookies(self):
        """Delete all cookies."""
        return self.app_controller.cookies_manager.delete_all_cookies()

    def delete_session_cookies(self):
        """Delete session cookies."""
        return self.app_controller.cookies_manager.delete_session_cookies()

    def block_cookies(self, block=True):
        """Block or unblock cookies."""
        return self.app_controller.cookies_manager.block_cookies(block)


class PluginStorage:
    """Storage API for plugins."""

    def __init__(self, app_controller, plugin_id):
        """Initialize the plugin storage API."""
        self.app_controller = app_controller
        self.plugin_id = plugin_id

        # Create storage directory
        self.storage_dir = os.path.expanduser(
            f"~/.nebulafusion/plugins/{plugin_id}/storage"
        )
        os.makedirs(self.storage_dir, exist_ok=True)

    def get(self, key, default=None):
        """Get a value from storage."""
        try:
            # Get storage file path
            storage_file = os.path.join(self.storage_dir, "storage.json")

            # Check if file exists
            if not os.path.exists(storage_file):
                return default

            # Load storage
            import json

            with open(storage_file, "r") as f:
                storage = json.load(f)

            # Get value
            return storage.get(key, default)
        except Exception as e:
            self.app_controller.logger.error(
                f"[Plugin: {self.plugin_id}] Error getting value from storage: {e}"
            )
            return default

    def set(self, key, value):
        """Set a value in storage."""
        try:
            # Get storage file path
            storage_file = os.path.join(self.storage_dir, "storage.json")

            # Load storage
            import json

            storage = {}
            if os.path.exists(storage_file):
                with open(storage_file, "r") as f:
                    storage = json.load(f)

            # Set value
            storage[key] = value

            # Save storage
            with open(storage_file, "w") as f:
                json.dump(storage, f, indent=4)

            return True
        except Exception as e:
            self.app_controller.logger.error(
                f"[Plugin: {self.plugin_id}] Error setting value in storage: {e}"
            )
            return False

    def remove(self, key):
        """Remove a value from storage."""
        try:
            # Get storage file path
            storage_file = os.path.join(self.storage_dir, "storage.json")

            # Check if file exists
            if not os.path.exists(storage_file):
                return True

            # Load storage
            import json

            with open(storage_file, "r") as f:
                storage = json.load(f)

            # Remove value
            if key in storage:
                del storage[key]

            # Save storage
            with open(storage_file, "w") as f:
                json.dump(storage, f, indent=4)

            return True
        except Exception as e:
            self.app_controller.logger.error(
                f"[Plugin: {self.plugin_id}] Error removing value from storage: {e}"
            )
            return False

    def clear(self):
        """Clear all storage."""
        try:
            # Get storage file path
            storage_file = os.path.join(self.storage_dir, "storage.json")

            # Check if file exists
            if not os.path.exists(storage_file):
                return True

            # Save empty storage
            import json

            with open(storage_file, "w") as f:
                json.dump({}, f, indent=4)

            return True
        except Exception as e:
            self.app_controller.logger.error(
                f"[Plugin: {self.plugin_id}] Error clearing storage: {e}"
            )
            return False


class PluginUI:
    """
    UI API for plugins.
    Provides methods for creating and managing UI elements from plugins.
    """

    def __init__(self, app_controller, plugin_id):
        """Initialize the plugin UI API."""
        self.app_controller = app_controller
        self.plugin_id = plugin_id

        # Set up logging
        self.logger = getattr(app_controller, "logger", None)
        if not self.logger:
            import logging

            self.logger = logging.getLogger(f"PluginUI-{plugin_id}")
            self.logger.setLevel(logging.INFO)
            if not self.logger.handlers:
                handler = logging.StreamHandler()
                formatter = logging.Formatter(
                    "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
                )
                handler.setFormatter(formatter)
                self.logger.addHandler(handler)

        # Store references to created UI elements
        self._toolbar_buttons = {}
        self._menu_items = {}
        self._context_menu_items = {}

    def _on_toolbar_created(self, toolbar):
        """Handle toolbar creation event."""
        self.logger.info("Toolbar created, processing queued buttons")
        if hasattr(self, "_queued_buttons"):
            queued_buttons = getattr(self, "_queued_buttons", {})
            for button_id, button_info in list(queued_buttons.items()):
                try:
                    self.logger.info(f"Processing queued button: {button_id}")
                    self.add_toolbar_button(button_id=button_id, **button_info)
                    # Remove from queue if successfully added
                    if button_id in self._queued_buttons:
                        del self._queued_buttons[button_id]
                except Exception as e:
                    self.logger.error(
                        f"Error processing queued button {button_id}: {str(e)}",
                        exc_info=True,
                    )
            # Clear the queue after processing
            self._queued_buttons.clear()

    def add_toolbar_button(
        self, button_id, text, icon=None, tooltip=None, callback=None
    ):
        """
        Add a button to the main toolbar. Relies on onToolbarCreated hook.
        """
        try:
            main_window = self.app_controller.main_window
            if not main_window or not hasattr(main_window, "toolbar"):
                self.logger.error(
                    f"Cannot add button '{button_id}': Toolbar not ready."
                )
                return False

            if button_id in self._toolbar_buttons:
                self.logger.warning(f"Button with ID '{button_id}' already exists.")
                return False

            from PyQt6.QtGui import QAction, QIcon

            action = QAction(text, main_window)
            action.setObjectName(f"{self.plugin_id}_{button_id}")

            if icon:
                if isinstance(icon, str) and os.path.exists(icon):
                    action.setIcon(QIcon(icon))
                elif not isinstance(icon, str):  # Assume it's a QIcon object
                    action.setIcon(icon)
                else:
                    self.logger.warning(
                        f"Icon file not found for button '{button_id}': {icon}"
                    )

            if tooltip:
                action.setToolTip(tooltip)
                action.setStatusTip(tooltip)

            if callback and callable(callback):
                action.triggered.connect(lambda: self._safe_callback(callback))

            main_window.toolbar.add_plugin_button(action)
            self._toolbar_buttons[button_id] = action

            self.logger.info(f"Successfully added toolbar button: {button_id}")
            return True

        except Exception as e:
            self.logger.error(
                f"Error adding toolbar button '{button_id}': {str(e)}", exc_info=True
            )
            return False

    def _safe_callback(self, callback):
        """Safely execute a callback with error handling."""
        try:
            self.logger.debug(
                f"Executing callback: {callback.__name__ if hasattr(callback, '__name__') else 'anonymous'}"
            )
            return callback()
        except Exception as e:
            self.logger.error(f"Error in callback: {str(e)}", exc_info=True)

    def remove_toolbar_button(self, button_id):
        """
        Remove a toolbar button.

        Args:
            button_id (str): ID of the button to remove

        Returns:
            bool: True if button was removed, False otherwise
        """
        try:
            if button_id in self._toolbar_buttons:
                button = self._toolbar_buttons[button_id]
                button.setParent(None)
                button.deleteLater()
                del self._toolbar_buttons[button_id]
                self.logger.info(f"Removed toolbar button: {button_id}")
                return True

            # Check if button is in queue
            if hasattr(self, "_queued_buttons") and button_id in self._queued_buttons:
                del self._queued_buttons[button_id]
                self.logger.info(f"Removed queued toolbar button: {button_id}")
                return True

            self.logger.warning(f"Button not found: {button_id}")
            return False

        except Exception as e:
            self.logger.error(
                f"Error removing toolbar button '{button_id}': {str(e)}", exc_info=True
            )
            return False

    def show_message(self, title, message):
        """Show a message dialog."""
        try:
            from PyQt6.QtWidgets import QMessageBox

            QMessageBox.information(None, title, message)
        except Exception as e:
            self.logger.error(f"Error showing message dialog: {str(e)}", exc_info=True)

    def show_error(self, title, message):
        """Show an error dialog."""
        try:
            from PyQt6.QtWidgets import QMessageBox

            QMessageBox.critical(None, title, message)
        except Exception as e:
            self.logger.error(f"Error showing error dialog: {str(e)}", exc_info=True)

    def show_warning(self, title, message):
        """Show a warning dialog."""
        try:
            from PyQt6.QtWidgets import QMessageBox

            QMessageBox.warning(None, title, message)
        except Exception as e:
            self.logger.error(f"Error showing warning dialog: {str(e)}", exc_info=True)

    def show_question(self, title, message):
        """Show a question dialog."""
        try:
            from PyQt6.QtWidgets import QMessageBox

            return (
                QMessageBox.question(None, title, message)
                == QMessageBox.StandardButton.Yes
            )
        except Exception as e:
            self.logger.error(f"Error showing question dialog: {str(e)}", exc_info=True)
            return False

    def show_input_dialog(self, title, message, default=""):
        """Show an input dialog."""
        try:
            from PyQt6.QtWidgets import QInputDialog

            text, ok = QInputDialog.getText(None, title, message, text=default)
            return text if ok else None
        except Exception as e:
            self.logger.error(f"Error showing input dialog: {str(e)}", exc_info=True)
            return None

    def show_file_dialog(self, title, directory="", filter=""):
        """Show a file dialog."""
        try:
            from PyQt6.QtWidgets import QFileDialog

            return QFileDialog.getOpenFileName(None, title, directory, filter)[0]
        except Exception as e:
            self.logger.error(f"Error showing file dialog: {str(e)}", exc_info=True)
            return ""

    def show_save_dialog(self, title, directory="", filter=""):
        """Show a save dialog."""
        try:
            from PyQt6.QtWidgets import QFileDialog

            return QFileDialog.getSaveFileName(None, title, directory, filter)[0]
        except Exception as e:
            self.logger.error(f"Error showing save dialog: {str(e)}", exc_info=True)
            return ""

    def show_directory_dialog(self, title, directory=""):
        """Show a directory dialog."""
        try:
            from PyQt6.QtWidgets import QFileDialog

            return QFileDialog.getExistingDirectory(None, title, directory)
        except Exception as e:
            self.logger.error(
                f"Error showing directory dialog: {str(e)}", exc_info=True
            )
            return ""

    def add_menu_item(self, menu, text, icon=None, tooltip=None, callback=None):
        """
        Add an item to a menu.

        Args:
            menu: The menu to add the item to
            text (str): The text of the menu item
            icon (QIcon or str, optional): The icon for the menu item
            tooltip (str, optional): Tooltip text
            callback (callable, optional): Function to call when the menu item is triggered

        Returns:
            QAction: The created menu item action, or None if failed
        """
        try:
            from PyQt6.QtGui import QAction, QIcon

            action = QAction(text, None)
            if icon:
                if isinstance(icon, str):
                    if os.path.exists(icon):
                        action.setIcon(QIcon(icon))
                else:
                    action.setIcon(icon)

            if tooltip:
                action.setToolTip(tooltip)

            if callback and callable(callback):
                action.triggered.connect(
                    lambda checked, cb=callback: self._safe_callback(cb)
                )

            menu.addAction(action)

            # Store reference
            if not hasattr(self, "_menu_items"):
                self._menu_items = {}
            self._menu_items[id(action)] = action

            return action

        except Exception as e:
            self.logger.error(f"Error adding menu item: {str(e)}", exc_info=True)
            return None

    def add_context_menu_item(self, text, icon=None, tooltip=None, callback=None):
        """
        Add an item to the browser's context menu.

        Args:
            text (str): The text of the menu item
            icon (QIcon or str, optional): The icon for the menu item
            tooltip (str, optional): Tooltip text
            callback (callable, optional): Function to call when the menu item is triggered

        Returns:
            QAction: The created menu item action, or None if failed
        """
        try:
            main_window = getattr(self.app_controller, "main_window", None)
            if not main_window or not hasattr(main_window, "add_context_menu_action"):
                self.logger.error("Main window or context menu not available")
                return None

            action = self.add_menu_item(None, text, icon, tooltip, callback)
            if action:
                main_window.add_context_menu_action(action)

                # Store reference
                if not hasattr(self, "_context_menu_items"):
                    self._context_menu_items = {}
                self._context_menu_items[id(action)] = action

            return action

        except Exception as e:
            self.logger.error(
                f"Error adding context menu item: {str(e)}", exc_info=True
            )
            return None


class PluginNetwork:
    """Network API for plugins."""

    def __init__(self, app_controller, plugin_id):
        """Initialize the plugin network API."""
        self.app_controller = app_controller
        self.plugin_id = plugin_id

    def get(self, url, headers=None, params=None, timeout=30):
        """Send a GET request."""
        import requests

        try:
            response = requests.get(
                url, headers=headers, params=params, timeout=timeout
            )
            return {
                "status_code": response.status_code,
                "headers": dict(response.headers),
                "content": response.content,
                "text": response.text,
                "json": (
                    response.json()
                    if response.headers.get("content-type", "").startswith(
                        "application/json"
                    )
                    else None
                ),
            }
        except Exception as e:
            self.app_controller.logger.error(
                f"[Plugin: {self.plugin_id}] Error sending GET request: {e}"
            )
            return None

    def post(self, url, data=None, json=None, headers=None, timeout=30):
        """Send a POST request."""
        import requests

        try:
            response = requests.post(
                url, data=data, json=json, headers=headers, timeout=timeout
            )
            return {
                "status_code": response.status_code,
                "headers": dict(response.headers),
                "content": response.content,
                "text": response.text,
                "json": (
                    response.json()
                    if response.headers.get("content-type", "").startswith(
                        "application/json"
                    )
                    else None
                ),
            }
        except Exception as e:
            self.app_controller.logger.error(
                f"[Plugin: {self.plugin_id}] Error sending POST request: {e}"
            )
            return None

    def put(self, url, data=None, json=None, headers=None, timeout=30):
        """Send a PUT request."""
        import requests

        try:
            response = requests.put(
                url, data=data, json=json, headers=headers, timeout=timeout
            )
            return {
                "status_code": response.status_code,
                "headers": dict(response.headers),
                "content": response.content,
                "text": response.text,
                "json": (
                    response.json()
                    if response.headers.get("content-type", "").startswith(
                        "application/json"
                    )
                    else None
                ),
            }
        except Exception as e:
            self.app_controller.logger.error(
                f"[Plugin: {self.plugin_id}] Error sending PUT request: {e}"
            )
            return None

    def delete(self, url, headers=None, timeout=30):
        """Send a DELETE request."""
        import requests

        try:
            response = requests.delete(url, headers=headers, timeout=timeout)
            return {
                "status_code": response.status_code,
                "headers": dict(response.headers),
                "content": response.content,
                "text": response.text,
                "json": (
                    response.json()
                    if response.headers.get("content-type", "").startswith(
                        "application/json"
                    )
                    else None
                ),
            }
        except Exception as e:
            self.app_controller.logger.error(
                f"[Plugin: {self.plugin_id}] Error sending DELETE request: {e}"
            )
            return None

    def download_file(self, url, path, headers=None, timeout=30):
        """Download a file."""
        import requests

        try:
            response = requests.get(url, headers=headers, timeout=timeout, stream=True)
            with open(path, "wb") as f:
                for chunk in response.iter_content(chunk_size=8192):
                    f.write(chunk)
            return True
        except Exception as e:
            self.app_controller.logger.error(
                f"[Plugin: {self.plugin_id}] Error downloading file: {e}"
            )
            return False


class PluginFilesystem:
    """Filesystem API for plugins."""

    def __init__(self, app_controller, plugin_id):
        """Initialize the plugin filesystem API."""
        self.app_controller = app_controller
        self.plugin_id = plugin_id

        # Create plugin directory
        self.plugin_dir = os.path.expanduser(f"~/.nebulafusion/plugins/{plugin_id}")
        os.makedirs(self.plugin_dir, exist_ok=True)

    def read_file(self, path, binary=False):
        """Read a file."""
        try:
            # Check if path is absolute
            if not os.path.isabs(path):
                # Make path relative to plugin directory
                path = os.path.join(self.plugin_dir, path)

            # Check if path is within plugin directory
            if not path.startswith(self.plugin_dir):
                raise ValueError("Path must be within plugin directory")

            # Read file
            mode = "rb" if binary else "r"
            with open(path, mode) as f:
                return f.read()
        except Exception as e:
            self.app_controller.logger.error(
                f"[Plugin: {self.plugin_id}] Error reading file: {e}"
            )
            return None

    def write_file(self, path, content, binary=False):
        """Write a file."""
        try:
            # Check if path is absolute
            if not os.path.isabs(path):
                # Make path relative to plugin directory
                path = os.path.join(self.plugin_dir, path)

            # Check if path is within plugin directory
            if not path.startswith(self.plugin_dir):
                raise ValueError("Path must be within plugin directory")

            # Create directory if it doesn't exist
            os.makedirs(os.path.dirname(path), exist_ok=True)

            # Write file
            mode = "wb" if binary else "w"
            with open(path, mode) as f:
                f.write(content)

            return True
        except Exception as e:
            self.app_controller.logger.error(
                f"[Plugin: {self.plugin_id}] Error writing file: {e}"
            )
            return False

    def append_file(self, path, content, binary=False):
        """Append to a file."""
        try:
            # Check if path is absolute
            if not os.path.isabs(path):
                # Make path relative to plugin directory
                path = os.path.join(self.plugin_dir, path)

            # Check if path is within plugin directory
            if not path.startswith(self.plugin_dir):
                raise ValueError("Path must be within plugin directory")

            # Create directory if it doesn't exist
            os.makedirs(os.path.dirname(path), exist_ok=True)

            # Append to file
            mode = "ab" if binary else "a"
            with open(path, mode) as f:
                f.write(content)

            return True
        except Exception as e:
            self.app_controller.logger.error(
                f"[Plugin: {self.plugin_id}] Error appending to file: {e}"
            )
            return False

    def delete_file(self, path):
        """Delete a file."""
        try:
            # Check if path is absolute
            if not os.path.isabs(path):
                # Make path relative to plugin directory
                path = os.path.join(self.plugin_dir, path)

            # Check if path is within plugin directory
            if not path.startswith(self.plugin_dir):
                raise ValueError("Path must be within plugin directory")

            # Delete file
            os.remove(path)

            return True
        except Exception as e:
            self.app_controller.logger.error(
                f"[Plugin: {self.plugin_id}] Error deleting file: {e}"
            )
            return False

    def create_directory(self, path):
        """Create a directory."""
        try:
            # Check if path is absolute
            if not os.path.isabs(path):
                # Make path relative to plugin directory
                path = os.path.join(self.plugin_dir, path)

            # Check if path is within plugin directory
            if not path.startswith(self.plugin_dir):
                raise ValueError("Path must be within plugin directory")

            # Create directory
            os.makedirs(path, exist_ok=True)

            return True
        except Exception as e:
            self.app_controller.logger.error(
                f"[Plugin: {self.plugin_id}] Error creating directory: {e}"
            )
            return False

    def delete_directory(self, path):
        """Delete a directory."""
        try:
            # Check if path is absolute
            if not os.path.isabs(path):
                # Make path relative to plugin directory
                path = os.path.join(self.plugin_dir, path)

            # Check if path is within plugin directory
            if not path.startswith(self.plugin_dir):
                raise ValueError("Path must be within plugin directory")

            # Delete directory
            import shutil

            shutil.rmtree(path)

            return True
        except Exception as e:
            self.app_controller.logger.error(
                f"[Plugin: {self.plugin_id}] Error deleting directory: {e}"
            )
            return False

    def list_directory(self, path):
        """List a directory."""
        try:
            # Check if path is absolute
            if not os.path.isabs(path):
                # Make path relative to plugin directory
                path = os.path.join(self.plugin_dir, path)

            # Check if path is within plugin directory
            if not path.startswith(self.plugin_dir):
                raise ValueError("Path must be within plugin directory")

            # List directory
            return os.listdir(path)
        except Exception as e:
            self.app_controller.logger.error(
                f"[Plugin: {self.plugin_id}] Error listing directory: {e}"
            )
            return None

    def file_exists(self, path):
        """Check if a file exists."""
        try:
            # Check if path is absolute
            if not os.path.isabs(path):
                # Make path relative to plugin directory
                path = os.path.join(self.plugin_dir, path)

            # Check if path is within plugin directory
            if not path.startswith(self.plugin_dir):
                raise ValueError("Path must be within plugin directory")

            # Check if file exists
            return os.path.isfile(path)
        except Exception as e:
            self.app_controller.logger.error(
                f"[Plugin: {self.plugin_id}] Error checking if file exists: {e}"
            )
            return False

    def directory_exists(self, path):
        """Check if a directory exists."""
        try:
            # Check if path is absolute
            if not os.path.isabs(path):
                # Make path relative to plugin directory
                path = os.path.join(self.plugin_dir, path)

            # Check if path is within plugin directory
            if not path.startswith(self.plugin_dir):
                raise ValueError("Path must be within plugin directory")

            # Check if directory exists
            return os.path.isdir(path)
        except Exception as e:
            self.app_controller.logger.error(
                f"[Plugin: {self.plugin_id}] Error checking if directory exists: {e}"
            )
            return False


class PluginSettings:
    """Settings API for plugins."""

    def __init__(self, app_controller, plugin_id):
        """Initialize the plugin settings API."""
        self.app_controller = app_controller
        self.plugin_id = plugin_id

    def get_setting(self, key, default=None):
        """Get a setting."""
        return self.app_controller.settings_manager.get_setting(key, default)

    def set_setting(self, key, value):
        """Set a setting."""
        return self.app_controller.settings_manager.set_setting(key, value)

    def get_plugin_setting(self, key, default=None):
        """Get a plugin setting."""
        plugin_key = f"plugin.{self.plugin_id}.{key}"
        return self.app_controller.settings_manager.get_setting(plugin_key, default)

    def set_plugin_setting(self, key, value):
        """Set a plugin setting."""
        plugin_key = f"plugin.{self.plugin_id}.{key}"
        return self.app_controller.settings_manager.set_setting(plugin_key, value)


class PluginReality:
    """Reality augmentation API for plugins."""

    def __init__(self, app_controller, plugin_id):
        """Initialize the plugin reality augmentation API."""
        self.app_controller = app_controller
        self.plugin_id = plugin_id

    def augment_page(self, tab_index, augmentation_data):
        """Augment a page with reality augmentation."""
        # TODO: Implement reality augmentation
        pass

    def remove_augmentation(self, tab_index):
        """Remove reality augmentation from a page."""
        # TODO: Implement reality augmentation
        pass


class PluginCollaboration:
    """Collaboration API for plugins."""

    def __init__(self, app_controller, plugin_id):
        """Initialize the plugin collaboration API."""
        self.app_controller = app_controller
        self.plugin_id = plugin_id

    def start_session(self, session_id=None):
        """Start a collaborative session."""
        # TODO: Implement collaborative browsing
        pass

    def join_session(self, session_id):
        """Join a collaborative session."""
        # TODO: Implement collaborative browsing
        pass

    def leave_session(self):
        """Leave a collaborative session."""
        # TODO: Implement collaborative browsing
        pass

    def send_message(self, message):
        """Send a message to the collaborative session."""
        # TODO: Implement collaborative browsing
        pass


class PluginTransformation:
    """Content transformation API for plugins."""

    def __init__(self, app_controller, plugin_id):
        """Initialize the plugin content transformation API."""
        self.app_controller = app_controller
        self.plugin_id = plugin_id

    def transform_page(self, tab_index, transformation_type, options=None):
        """Transform a page."""
        # TODO: Implement content transformation
        pass

    def reset_transformation(self, tab_index):
        """Reset page transformation."""
        # TODO: Implement content transformation
        pass


class PluginTimeTravel:
    """Time-travel browsing API for plugins."""

    def __init__(self, app_controller, plugin_id):
        """Initialize the plugin time-travel browsing API."""
        self.app_controller = app_controller
        self.plugin_id = plugin_id

    def create_snapshot(self, tab_index, name=None):
        """Create a time-travel snapshot."""
        # TODO: Implement time-travel browsing
        pass

    def get_snapshots(self, tab_index):
        """Get time-travel snapshots."""
        # TODO: Implement time-travel browsing
        pass

    def restore_snapshot(self, tab_index, snapshot_id):
        """Restore a time-travel snapshot."""
        # TODO: Implement time-travel browsing
        pass

    def delete_snapshot(self, tab_index, snapshot_id):
        """Delete a time-travel snapshot."""
        # TODO: Implement time-travel browsing
        pass


class PluginDimensions:
    """Dimensional tabs API for plugins."""

    def __init__(self, app_controller, plugin_id):
        """Initialize the plugin dimensional tabs API."""
        self.app_controller = app_controller
        self.plugin_id = plugin_id

    def create_dimension(self, tab_index, name=None):
        """Create a dimensional tab."""
        # TODO: Implement dimensional tabs
        pass

    def get_dimensions(self, tab_index):
        """Get dimensional tabs."""
        # TODO: Implement dimensional tabs
        pass

    def switch_dimension(self, tab_index, dimension_id):
        """Switch to a dimensional tab."""
        # TODO: Implement dimensional tabs
        pass

    def delete_dimension(self, tab_index, dimension_id):
        """Delete a dimensional tab."""
        # TODO: Implement dimensional tabs
        pass


class PluginVoice:
    """Voice command API for plugins."""

    def __init__(self, app_controller, plugin_id):
        """Initialize the plugin voice command API."""
        self.app_controller = app_controller
        self.plugin_id = plugin_id

    def register_command(self, command, callback):
        """Register a voice command."""
        # TODO: Implement voice commands
        pass

    def unregister_command(self, command):
        """Unregister a voice command."""
        # TODO: Implement voice commands
        pass

    def get_commands(self):
        """Get registered voice commands."""
        # TODO: Implement voice commands
        pass
</file>

<file path="src/plugins/plugin_base.py">
#!/usr/bin/env python3
# NebulaFusion Browser - Plugin Base

import os
import sys
from PyQt6.QtCore import QObject

class PluginBase(QObject):
    """
    Base class for browser plugins.
    All plugins must inherit from this class.
    """
    
    def __init__(self, api):
        """Initialize the plugin."""
        super().__init__()
        self.api = api
        self.plugin_id = api.plugin_id
        self.manifest = api.manifest
    
    def activate(self):
        """
        Activate the plugin.
        Called when the plugin is enabled.
        
        Returns:
            bool: True if activation was successful, False otherwise.
        """
        return True
    
    def deactivate(self):
        """
        Deactivate the plugin.
        Called when the plugin is disabled.
        
        Returns:
            bool: True if deactivation was successful, False otherwise.
        """
        return True
    
    def configure(self):
        """
        Configure the plugin.
        Called when the user wants to configure the plugin.
        """
        pass
    
    def get_name(self):
        """Get the plugin name."""
        return self.manifest.get("name", "Unknown Plugin")
    
    def get_version(self):
        """Get the plugin version."""
        return self.manifest.get("version", "0.0.0")
    
    def get_author(self):
        """Get the plugin author."""
        return self.manifest.get("author", "Unknown Author")
    
    def get_description(self):
        """Get the plugin description."""
        return self.manifest.get("description", "No description available.")
    
    def get_permissions(self):
        """Get the plugin permissions."""
        return self.manifest.get("permissions", [])
    
    def has_permission(self, permission):
        """Check if the plugin has a permission."""
        return permission in self.get_permissions()
</file>

<file path="src/plugins/plugin_loader.py">
#!/usr/bin/env python3
# NebulaFusion Browser - Plugin Loader

import os
import sys
import importlib.util
import json
import inspect
from PyQt6.QtCore import QObject, pyqtSignal

class PluginLoader(QObject):
    """
    Loader for browser plugins.
    Handles loading, validating, and initializing plugins.
    """
    
    # Signals
    plugin_loaded = pyqtSignal(str, object)  # plugin_id, plugin_instance
    plugin_unloaded = pyqtSignal(str)  # plugin_id
    plugin_error = pyqtSignal(str, str)  # plugin_id, error_message
    
    def __init__(self, app_controller):
        """Initialize the plugin loader."""
        super().__init__()
        self.app_controller = app_controller
        
        # Loaded plugins
        self.loaded_plugins = {}
        
        # Plugin base class
        self.plugin_base_class = None
    
    def initialize(self):
        """Initialize the plugin loader."""
        self.app_controller.logger.info("Initializing plugin loader...")
        
        # Import plugin base class
        from src.plugins.plugin_base import PluginBase
        self.plugin_base_class = PluginBase
        
        self.app_controller.logger.info("Plugin loader initialized.")
    
    def load_plugin(self, plugin_path):
        """Load a plugin from a path."""
        plugin_id = None
        try:
            self.app_controller.logger.info(f"Loading plugin from: {plugin_path}")
            
            # Check if path exists
            if not os.path.exists(plugin_path):
                raise FileNotFoundError(f"Plugin path not found: {plugin_path}")
            
            # Check if path is a directory
            if not os.path.isdir(plugin_path):
                raise NotADirectoryError(f"Plugin path is not a directory: {plugin_path}")
            
            # Check if __init__.py exists
            init_path = os.path.join(plugin_path, "__init__.py")
            if not os.path.exists(init_path):
                raise FileNotFoundError(f"Plugin __init__.py not found: {init_path}")
            
            # Check if manifest.json exists
            manifest_path = os.path.join(plugin_path, "manifest.json")
            if not os.path.exists(manifest_path):
                raise FileNotFoundError(f"Plugin manifest.json not found: {manifest_path}")
            
            # Load and validate manifest
            self.app_controller.logger.info(f"Loading manifest from: {manifest_path}")
            with open(manifest_path, "r", encoding='utf-8') as f:
                manifest = json.load(f)
            
            self._validate_manifest(manifest)
            plugin_id = manifest["id"]
            self.app_controller.logger.info(f"Plugin ID: {plugin_id}")
            
            # Check if plugin is already loaded
            if plugin_id in self.loaded_plugins:
                self.app_controller.logger.warning(f"Plugin already loaded: {plugin_id}")
                return plugin_id
            
            # Add plugin directory to Python path
            plugin_dir = os.path.dirname(plugin_path)
            if plugin_dir not in sys.path:
                sys.path.insert(0, plugin_dir)
            
            # Load plugin module
            plugin_name = os.path.basename(plugin_path)
            self.app_controller.logger.info(f"Importing plugin module: {plugin_name}")
            
            spec = importlib.util.spec_from_file_location(plugin_name, init_path)
            if spec is None:
                raise ImportError(f"Could not load spec for plugin: {plugin_name}")
                
            module = importlib.util.module_from_spec(spec)
            sys.modules[plugin_name] = module
            
            try:
                spec.loader.exec_module(module)
            except Exception as e:
                raise ImportError(f"Error executing module {plugin_name}: {str(e)}")
            
            # Find plugin class
            plugin_class = None
            for name, obj in inspect.getmembers(module):
                if (inspect.isclass(obj) and 
                    issubclass(obj, self.plugin_base_class) and 
                    obj != self.plugin_base_class):
                    plugin_class = obj
                    break
            
            if not plugin_class:
                raise ValueError(f"No plugin class found in {plugin_name}")
            
            # Create plugin API
            from src.plugins.plugin_api import PluginAPI
            plugin_api = PluginAPI(self.app_controller, plugin_id, manifest)
            
            # Create plugin instance
            self.app_controller.logger.info(f"Creating instance of plugin: {plugin_id}")
            plugin_instance = plugin_class(plugin_api)
            
            # Store plugin
            self.loaded_plugins[plugin_id] = {
                "id": plugin_id,
                "name": manifest.get("name", "Unnamed Plugin"),
                "version": manifest.get("version", "1.0.0"),
                "author": manifest.get("author", "Unknown"),
                "description": manifest.get("description", "No description provided"),
                "permissions": manifest.get("permissions", []),
                "path": plugin_path,
                "manifest": manifest,
                "instance": plugin_instance,
                "api": plugin_api,
                "enabled": False
            }
            
            # Emit signal
            self.plugin_loaded.emit(plugin_id, plugin_instance)
            self.app_controller.logger.info(f"Successfully loaded plugin: {plugin_id}")
            
            return plugin_id
            
        except json.JSONDecodeError as e:
            error_msg = f"Invalid JSON in manifest: {str(e)}"
            self.app_controller.logger.error(error_msg, exc_info=True)
            if plugin_id:
                self.plugin_error.emit(plugin_id, error_msg)
            return None
            
        except ImportError as e:
            error_msg = f"Import error loading plugin: {str(e)}"
            self.app_controller.logger.error(error_msg, exc_info=True)
            if plugin_id:
                self.plugin_error.emit(plugin_id, error_msg)
            return None
            
        except Exception as e:
            error_msg = f"Error loading plugin: {str(e)}"
            self.app_controller.logger.error(error_msg, exc_info=True)
            if plugin_id:
                self.plugin_error.emit(plugin_id, error_msg)
            return None
    
    def unload_plugin(self, plugin_id):
        """Unload a plugin."""
        try:
            # Check if plugin is loaded
            if plugin_id not in self.loaded_plugins:
                raise ValueError(f"Plugin not loaded: {plugin_id}")
            
            # Get plugin
            plugin = self.loaded_plugins[plugin_id]
            
            # Deactivate plugin if enabled
            if plugin["enabled"]:
                self.deactivate_plugin(plugin_id)
            
            # Remove plugin
            del self.loaded_plugins[plugin_id]
            
            # Emit signal
            self.plugin_unloaded.emit(plugin_id)
            
            self.app_controller.logger.info(f"Plugin unloaded: {plugin_id}")
            
            return True
        
        except Exception as e:
            error_message = f"Error unloading plugin: {str(e)}"
            self.app_controller.logger.error(error_message)
            
            # Emit signal
            self.plugin_error.emit(plugin_id, error_message)
            
            return False
    
    def activate_plugin(self, plugin_id):
        """Activate a plugin."""
        try:
            # Check if plugin is loaded
            if plugin_id not in self.loaded_plugins:
                raise ValueError(f"Plugin not loaded: {plugin_id}")
            
            # Get plugin
            plugin = self.loaded_plugins[plugin_id]
            
            # Check if plugin is already enabled
            if plugin["enabled"]:
                return True
            
            # Activate plugin
            success = plugin["instance"].activate()
            
            if success:
                # Update plugin status
                plugin["enabled"] = True
                
                self.app_controller.logger.info(f"Plugin activated: {plugin_id}")
            else:
                error_message = f"Plugin activation failed: {plugin_id}"
                self.app_controller.logger.error(error_message)
                
                # Emit signal
                self.plugin_error.emit(plugin_id, error_message)
            
            return success
        
        except Exception as e:
            error_message = f"Error activating plugin: {str(e)}"
            self.app_controller.logger.error(error_message)
            
            # Emit signal
            self.plugin_error.emit(plugin_id, error_message)
            
            return False
    
    def deactivate_plugin(self, plugin_id):
        """Deactivate a plugin."""
        try:
            # Check if plugin is loaded
            if plugin_id not in self.loaded_plugins:
                raise ValueError(f"Plugin not loaded: {plugin_id}")
            
            # Get plugin
            plugin = self.loaded_plugins[plugin_id]
            
            # Check if plugin is enabled
            if not plugin["enabled"]:
                return True
            
            # Deactivate plugin
            success = plugin["instance"].deactivate()
            
            if success:
                # Update plugin status
                plugin["enabled"] = False
                
                self.app_controller.logger.info(f"Plugin deactivated: {plugin_id}")
            else:
                error_message = f"Plugin deactivation failed: {plugin_id}"
                self.app_controller.logger.error(error_message)
                
                # Emit signal
                self.plugin_error.emit(plugin_id, error_message)
            
            return success
        
        except Exception as e:
            error_message = f"Error deactivating plugin: {str(e)}"
            self.app_controller.logger.error(error_message)
            
            # Emit signal
            self.plugin_error.emit(plugin_id, error_message)
            
            return False
    
    def reload_plugin(self, plugin_id):
        """Reload a plugin."""
        try:
            # Check if plugin is loaded
            if plugin_id not in self.loaded_plugins:
                raise ValueError(f"Plugin not loaded: {plugin_id}")
            
            # Get plugin
            plugin = self.loaded_plugins[plugin_id]
            
            # Get plugin path
            plugin_path = plugin["path"]
            
            # Check if plugin is enabled
            was_enabled = plugin["enabled"]
            
            # Unload plugin
            self.unload_plugin(plugin_id)
            
            # Load plugin
            new_plugin_id = self.load_plugin(plugin_path)
            
            if new_plugin_id and was_enabled:
                # Activate plugin
                self.activate_plugin(new_plugin_id)
            
            self.app_controller.logger.info(f"Plugin reloaded: {plugin_id}")
            
            return new_plugin_id is not None
        
        except Exception as e:
            error_message = f"Error reloading plugin: {str(e)}"
            self.app_controller.logger.error(error_message)
            
            # Emit signal
            self.plugin_error.emit(plugin_id, error_message)
            
            return False
    
    def get_plugin(self, plugin_id):
        """Get a plugin by ID."""
        return self.loaded_plugins.get(plugin_id)
    
    def get_plugins(self):
        """Get all loaded plugins."""
        return self.loaded_plugins
    
    def _validate_manifest(self, manifest):
        """
        Validate a plugin manifest.
        
        Args:
            manifest (dict): The plugin manifest to validate
            
        Raises:
            ValueError: If the manifest is invalid
        """
        # Check required fields
        required_fields = ["id", "name", "version", "author", "description"]
        for field in required_fields:
            if field not in manifest:
                raise ValueError(f"Missing required field in manifest: {field}")
        
        # Validate ID
        if not isinstance(manifest["id"], str) or not manifest["id"]:
            raise ValueError("Plugin ID must be a non-empty string")
            
        # Validate name
        if not isinstance(manifest["name"], str) or not manifest["name"]:
            raise ValueError("Plugin name must be a non-empty string")
            
        # Validate version
        if not isinstance(manifest["version"], str) or not manifest["version"]:
            raise ValueError("Plugin version must be a non-empty string")
            
        # Validate author
        if not isinstance(manifest["author"], str) or not manifest["author"]:
            raise ValueError("Plugin author must be a non-empty string")
            
        # Validate description
        if not isinstance(manifest["description"], str):
            raise ValueError("Plugin description must be a string")
        
        # Validate permissions if present
        if "permissions" in manifest:
            if not isinstance(manifest["permissions"], list):
                raise ValueError("Plugin permissions must be a list")
            
            # Define valid permissions
            valid_permissions = [
                "tabs", "bookmarks", "history", "downloads", "cookies", "storage",
                "webRequest", "notifications", "contextMenus", "clipboardRead", 
                "clipboardWrite", "toolbar"  # Added toolbar permission
            ]
            
            for permission in manifest["permissions"]:
                if not isinstance(permission, str):
                    raise ValueError("Permission must be a string")
                if permission not in valid_permissions:
                    raise ValueError(f"Invalid permission: {permission}")
</file>

<file path="src/plugins/plugin_manager.py">
#!/usr/bin/env python3
# NebulaFusion Browser - Plugin Manager

import os
import sys
import shutil
import zipfile
import tempfile
from PyQt6.QtCore import QObject, pyqtSignal
import json


class PluginManager(QObject):
    """
    Manager for browser plugins.
    Handles plugin installation, removal, and management.
    """

    # Signals
    plugin_enabled = pyqtSignal(str)  # plugin_id
    plugin_disabled = pyqtSignal(str)  # plugin_id
    plugin_installed = pyqtSignal(str)  # plugin_id
    plugin_uninstalled = pyqtSignal(str)  # plugin_id
    plugin_configured = pyqtSignal(str)  # plugin_id

    def __init__(self, app_controller):
        """Initialize the plugin manager."""
        super().__init__()
        self.app_controller = app_controller

        # Plugin directories
        self.plugin_dirs = []

        # Default plugin directory
        self.default_plugin_dir = os.path.expanduser("~/.nebulafusion/plugins")

        # Store plugins
        self.store_plugins = []

        # Track loaded plugins
        self._loaded_plugins = {}

    def initialize(self):
        """Initialize the plugin manager."""
        self.app_controller.logger.info("Initializing plugin manager...")

        # Create default plugin directory if it doesn't exist
        os.makedirs(self.default_plugin_dir, exist_ok=True)

        # Add default plugin directory
        self.plugin_dirs.append(self.default_plugin_dir)

        # Add built-in plugin directory
        built_in_plugin_dir = os.path.join(
            os.path.dirname(os.path.dirname(os.path.abspath(__file__))),
            "plugins",
            "sample_plugins",
        )
        if os.path.exists(built_in_plugin_dir):
            self.plugin_dirs.append(built_in_plugin_dir)

        # Add src/plugins directory
        src_plugins_dir = os.path.join(
            os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "plugins"
        )
        self.plugin_dirs.append(src_plugins_dir)

        # Load plugins
        self._load_plugins()

        # Load store plugins
        self._load_store_plugins()

        self.app_controller.logger.info("Plugin manager initialized.")

    def _load_plugins(self):
        """Load plugins from plugin directories."""
        self.app_controller.logger.info("Loading plugins...")
        plugin_loader = self.app_controller.plugin_loader
        loaded_plugin_ids = (
            set()
        )  # Keep track of IDs loaded in this session to avoid conflicts

        for plugin_dir_root in self.plugin_dirs:
            if not os.path.exists(plugin_dir_root):
                self.app_controller.logger.warning(
                    f"Plugin directory root not found: {plugin_dir_root}"
                )
                continue

            self.app_controller.logger.info(
                f"Scanning plugin directory: {plugin_dir_root}"
            )

            # Get all subdirectories that might be plugins
            potential_plugins = [
                os.path.join(plugin_dir_root, d)
                for d in os.listdir(plugin_dir_root)
                if os.path.isdir(os.path.join(plugin_dir_root, d))
            ]

            # Also check the root directory for direct plugin files
            potential_plugins.append(plugin_dir_root)

            for potential_plugin_path in potential_plugins:
                # Check for manifest.json to get plugin_id
                manifest_path = os.path.join(potential_plugin_path, "manifest.json")
                init_path = os.path.join(potential_plugin_path, "__init__.py")

                self.app_controller.logger.debug(
                    f"Checking potential plugin at: {potential_plugin_path}"
                )

                if os.path.exists(manifest_path) and os.path.exists(init_path):
                    try:
                        with open(manifest_path, "r", encoding="utf-8") as f:
                            manifest = json.load(f)
                        plugin_id = manifest.get("id")

                        if not plugin_id:
                            self.app_controller.logger.warning(
                                f"Plugin at {potential_plugin_path} has no ID in manifest"
                            )
                            continue

                        self.app_controller.logger.info(
                            f"Found plugin: {plugin_id} at {potential_plugin_path}"
                        )

                        if plugin_id not in loaded_plugin_ids:
                            actual_plugin_id_loaded = plugin_loader.load_plugin(
                                potential_plugin_path
                            )
                            if (
                                actual_plugin_id_loaded
                            ):  # load_plugin returns ID on success
                                loaded_plugin_ids.add(actual_plugin_id_loaded)
                                self.app_controller.logger.info(
                                    f"Successfully loaded plugin: {plugin_id}"
                                )
                            else:
                                self.app_controller.logger.error(
                                    f"Failed to load plugin: {plugin_id}"
                                )
                        else:
                            self.app_controller.logger.info(
                                f"Plugin '{plugin_id}' already processed in this session. Skipping {potential_plugin_path}"
                            )

                    except json.JSONDecodeError as e:
                        self.app_controller.logger.error(
                            f"Could not decode manifest.json in {potential_plugin_path}: {str(e)}"
                        )
                    except Exception as e:
                        self.app_controller.logger.error(
                            f"Error loading plugin at {potential_plugin_path}: {str(e)}",
                            exc_info=True,
                        )

    def _load_store_plugins(self):
        """Load store plugins."""
        # TODO: Implement loading store plugins from a remote source
        # For now, we'll just use a hardcoded list
        self.store_plugins = []

    def get_plugin(self, plugin_id):
        """Get a plugin by ID."""
        return self.app_controller.plugin_loader.get_plugin(plugin_id)

    def get_plugins(self):
        """
        Get all loaded plugins.

        Returns:
            dict: A dictionary of all loaded plugins with plugin IDs as keys
        """
        return self.app_controller.plugin_loader.get_plugins()

    def get_available_plugins(self):
        """
        Get all available plugins (loaded and not loaded).

        Returns:
            dict: A dictionary of all available plugins with plugin IDs as keys
        """
        # For now, return the same as get_plugins
        return self.get_plugins()

    def get_store_plugins(self):
        """
        Get all available plugins from the store.

        Returns:
            list: A list of available plugins from the store
        """
        return self.store_plugins

    def configure_plugin(self, plugin_id):
        """
        Configure a plugin.

        Args:
            plugin_id (str): The ID of the plugin to configure

        Returns:
            bool: True if configuration was successful, False otherwise
        """
        try:
            # Get the plugin
            plugin = self.get_plugin(plugin_id)
            if not plugin:
                self.app_controller.logger.error(f"Plugin not found: {plugin_id}")
                return False

            # Check if plugin has a configuration dialog
            if hasattr(plugin, "show_config_dialog"):
                plugin.show_config_dialog()
                return True
            else:
                # Show a message that the plugin has no configuration
                from PyQt6.QtWidgets import QMessageBox

                QMessageBox.information(
                    None,
                    "Plugin Configuration",
                    f"The plugin '{plugin_id}' has no configuration options.",
                )
                return True

        except Exception as e:
            self.app_controller.logger.error(
                f"Error configuring plugin {plugin_id}: {str(e)}"
            )
            return False

    def enable_plugin(self, plugin_id):
        """Enable a plugin."""
        try:
            plugin_loader = self.app_controller.plugin_loader
            success = plugin_loader.activate_plugin(plugin_id)
            if success:
                self.plugin_enabled.emit(plugin_id)
            return success
        except Exception as e:
            import traceback

            tb = traceback.format_exc()
            self.app_controller.logger.error(
                f"Error enabling plugin {plugin_id}: {e}\n{tb}"
            )
            return False

    def disable_plugin(self, plugin_id):
        """Disable a plugin."""
        try:
            plugin_loader = self.app_controller.plugin_loader
            success = plugin_loader.deactivate_plugin(plugin_id)
            if success:
                self.plugin_disabled.emit(plugin_id)
            return success
        except Exception as e:
            import traceback

            tb = traceback.format_exc()
            self.app_controller.logger.error(
                f"Error disabling plugin {plugin_id}: {e}\n{tb}"
            )
            return False

    def install_plugin(self, plugin_path):
        """Install a plugin from a file."""
        try:
            # Check if file exists
            if not os.path.exists(plugin_path):
                raise FileNotFoundError(f"Plugin file not found: {plugin_path}")

            # Create temporary directory
            temp_dir = tempfile.mkdtemp()

            # Extract plugin
            if plugin_path.endswith(".zip"):
                # Extract ZIP file
                with zipfile.ZipFile(plugin_path, "r") as zip_ref:
                    zip_ref.extractall(temp_dir)
            else:
                # Copy file
                shutil.copy(plugin_path, temp_dir)

            # Find plugin directory
            plugin_dir = None
            for item in os.listdir(temp_dir):
                item_path = os.path.join(temp_dir, item)

                # Check if item is a directory
                if os.path.isdir(item_path):
                    # Check if directory contains manifest.json
                    manifest_path = os.path.join(item_path, "manifest.json")
                    if os.path.exists(manifest_path):
                        plugin_dir = item_path
                        break

            if not plugin_dir:
                # Check if temp_dir itself contains manifest.json
                manifest_path = os.path.join(temp_dir, "manifest.json")
                if os.path.exists(manifest_path):
                    plugin_dir = temp_dir

            if not plugin_dir:
                raise FileNotFoundError("Plugin manifest.json not found in archive")

            # Load plugin
            plugin_id = self.app_controller.plugin_loader.load_plugin(plugin_dir)

            if not plugin_id:
                raise ValueError("Failed to load plugin")

            # Get plugin
            plugin = self.app_controller.plugin_loader.get_plugin(plugin_id)

            # Install plugin to default plugin directory
            plugin_install_dir = os.path.join(self.default_plugin_dir, plugin_id)

            # Remove existing plugin if it exists
            if os.path.exists(plugin_install_dir):
                shutil.rmtree(plugin_install_dir)

            # Create plugin directory
            os.makedirs(plugin_install_dir, exist_ok=True)

            # Copy plugin files
            for item in os.listdir(plugin_dir):
                item_path = os.path.join(plugin_dir, item)
                dest_path = os.path.join(plugin_install_dir, item)

                if os.path.isdir(item_path):
                    shutil.copytree(item_path, dest_path)
                else:
                    shutil.copy2(item_path, dest_path)

            # Clean up
            shutil.rmtree(temp_dir)

            # Emit signal
            self.plugin_installed.emit(plugin_id)

            self.app_controller.logger.info(f"Plugin installed: {plugin_id}")

            return True

        except Exception as e:
            error_message = f"Error installing plugin: {str(e)}"
            self.app_controller.logger.error(error_message)
            return False

    def uninstall_plugin(self, plugin_id):
        """Uninstall a plugin."""
        try:
            # Get plugin
            plugin = self.app_controller.plugin_loader.get_plugin(plugin_id)
            if not plugin:
                raise ValueError(f"Plugin not found: {plugin_id}")

            # Get plugin path
            plugin_path = plugin.get("path")
            if not plugin_path:
                raise ValueError(f"Plugin path not found for: {plugin_id}")

            # Check if plugin is in default plugin directory
            if not plugin_path.startswith(self.default_plugin_dir):
                raise ValueError(f"Cannot uninstall built-in plugin: {plugin_id}")

            # Unload plugin first
            self.app_controller.logger.info(f"Unloading plugin: {plugin_id}")
            self.app_controller.plugin_loader.unload_plugin(plugin_id)

            # Remove plugin directory
            self.app_controller.logger.info(f"Removing plugin directory: {plugin_path}")
            if os.path.exists(plugin_path):
                import shutil

                shutil.rmtree(plugin_path)

            self.app_controller.logger.info(
                f"Successfully uninstalled plugin: {plugin_id}"
            )
            self.plugin_uninstalled.emit(plugin_id)
            return True

        except Exception as e:
            self.app_controller.logger.error(
                f"Error uninstalling plugin {plugin_id}: {str(e)}", exc_info=True
            )
            return False

        # TODO: Implement downloading and installing store plugins
        # For now, we'll just pretend it worked
        self.app_controller.logger.info(f"Plugin installed from store: {plugin_id}")

        # Emit signal
        self.plugin_installed.emit(plugin_id)

        return True

    def create_plugin_template(self, directory):
        """Create a plugin template in a directory."""
        try:
            # Create plugin directory
            os.makedirs(directory, exist_ok=True)

            # Create __init__.py
            with open(os.path.join(directory, "__init__.py"), "w") as f:
                f.write(
                    """#!/usr/bin/env python3
# NebulaFusion Plugin Template

from src.plugins.plugin_base import PluginBase

class Plugin(PluginBase):
    \"\"\"
    Template plugin for NebulaFusion browser.
    \"\"\"
    
    def __init__(self, api):
        \"\"\"Initialize the plugin.\"\"\"
        super().__init__(api)
        
        # Plugin state
        self.initialized = False
    
    def activate(self):
        \"\"\"Activate the plugin.\"\"\"
        # Register hooks
        self.api.hooks.register_hook("onBrowserStart", self.plugin_id, self.on_browser_start)
        self.api.hooks.register_hook("onBrowserExit", self.plugin_id, self.on_browser_exit)
        
        # Initialize plugin
        self.initialized = True
        
        return True
    
    def deactivate(self):
        \"\"\"Deactivate the plugin.\"\"\"
        # Unregister hooks
        self.api.hooks.unregister_all_hooks(self.plugin_id)
        
        # Clean up
        self.initialized = False
        
        return True
    
    def configure(self):
        \"\"\"Configure the plugin.\"\"\"
        # Show configuration dialog
        self.api.ui.show_message("Plugin Configuration", "This is a template plugin.")
    
    def on_browser_start(self):
        \"\"\"Handle browser start event.\"\"\"
        self.api.logger.info("Browser started")
    
    def on_browser_exit(self):
        \"\"\"Handle browser exit event.\"\"\"
        self.api.logger.info("Browser exiting")
"""
                )

            # Create manifest.json
            with open(os.path.join(directory, "manifest.json"), "w") as f:
                f.write(
                    """{
    "id": "template_plugin",
    "name": "Template Plugin",
    "version": "1.0.0",
    "author": "Your Name",
    "description": "A template plugin for NebulaFusion browser.",
    "permissions": [
        "tabs",
        "bookmarks",
        "history"
    ]
}"""
                )

            # Create README.md
            with open(os.path.join(directory, "README.md"), "w") as f:
                f.write(
                    """# Template Plugin

A template plugin for NebulaFusion browser.

## Features

- Basic plugin structure
- Hook registration
- Plugin lifecycle management

## Installation

1. Copy this directory to the NebulaFusion plugins directory
2. Enable the plugin in the browser settings

## Development

This template provides a starting point for developing NebulaFusion plugins.
Customize it to add your own features and functionality.

## License

MIT
"""
                )

            self.app_controller.logger.info(f"Plugin template created in {directory}")

            return True

        except Exception as e:
            error_message = f"Error creating plugin template: {str(e)}"
            self.app_controller.logger.error(error_message)
            return False
</file>

<file path="src/plugins/quick_search_plugin/__init__.py">
#!/usr/bin/env python3
# NebulaFusion Browser - Quick Search Plugin

from src.plugins.plugin_base import PluginBase


class Plugin(PluginBase):
    """
    Quick Search Plugin for NebulaFusion browser.
    Adds a toolbar button that opens a quick search dialog and navigates to the result.
    """

    def __init__(self, api):
        """Initialize the plugin."""
        super().__init__(api)
        self.search_action = None

    def activate(self):
        return True

    def deactivate(self):
        return True

    def onBrowserStart(self):
        try:
            self.api.ui.add_toolbar_button(
                text="Quick Search",
                tooltip="Search the web",
                callback=self.on_quick_search_clicked,
            )
            self.api.logger.info("Quick Search toolbar button added on browser start.")
        except Exception as e:
            self.api.logger.error(f"Error adding Quick Search toolbar button: {e}")

    def on_quick_search_clicked(self):
        from PyQt6.QtWidgets import QInputDialog

        query, ok = QInputDialog.getText(None, "Quick Search", "Enter search query:")
        if ok and query:
            search_url = self.api.app_controller.settings_manager.get_setting(
                "general.search_engine", "https://www.google.com/search?q="
            )
            url = f"{search_url}{query}"
            self.api.tabs.new_tab(url)
            self.api.ui.show_message("Quick Search", f"Searching: {query}")
</file>

<file path="src/plugins/quick_search_plugin/manifest.json">
{
    "id": "quick_search_plugin",
    "name": "Quick Search Plugin",
    "version": "1.0.0",
    "author": "NebulaFusion Team",
    "description": "Adds a toolbar button for quick web search.",
    "permissions": [
        "tabs"
    ],
    "hooks": [
        "onBrowserStart"
    ]
}
</file>

<file path="src/plugins/README.md">
# Template Plugin

A template plugin for NebulaFusion browser.

## Features

- Basic plugin structure
- Hook registration
- Plugin lifecycle management

## Installation

1. Copy this directory to the NebulaFusion plugins directory
2. Enable the plugin in the browser settings

## Development

This template provides a starting point for developing NebulaFusion plugins.
Customize it to add your own features and functionality.

## License

MIT
</file>

<file path="src/plugins/sample_plugins/__init__.py">
#!/usr/bin/env python3
# Sample Plugin for NebulaFusion Browser

from PyQt6.QtGui import QIcon, QPixmap, QPainter, QColor, QPainterPath, QAction
from PyQt6.QtCore import Qt, QPointF, QSize
from src.plugins.plugin_base import PluginBase  # <-- ADD THIS IMPORT
import os
import sys


class Plugin(PluginBase):  # <-- ADD THE INHERITANCE
    """
    Sample plugin that demonstrates adding a button to the toolbar.
    """

    def __init__(self, api):
        """Initialize the plugin."""
        super().__init__(api)  # <-- ADD THIS SUPER CALL FOR ROBUSTNESS
        self.button = None

        # Log initialization
        if hasattr(api, "logger"):
            self.api.logger.info(f"Initializing plugin: {self.plugin_id}")

    def activate(self):
        """Activate the plugin."""
        try:
            # Log activation
            if hasattr(self.api, "logger"):
                self.api.logger.info(f"Activating plugin: {self.plugin_id}")

            # Register hooks
            if hasattr(self.api, "hooks"):
                self.api.hooks.register_hook(
                    "onToolbarCreated", self.plugin_id, self.on_toolbar_created
                )

            # Try to add the button immediately if toolbar exists
            main_window = getattr(self.api.app_controller, "main_window", None)
            if main_window and hasattr(main_window, "toolbar"):
                self.add_toolbar_button()

            if hasattr(self.api, "logger"):
                self.api.logger.info(f"Plugin activated: {self.plugin_id}")

            return True

        except Exception as e:
            if hasattr(self.api, "logger"):
                self.api.logger.error(
                    f"Error activating plugin {self.plugin_id}: {str(e)}"
                )
            return False

    def deactivate(self):
        """Deactivate the plugin."""
        try:
            # Remove the button if it exists
            if self.button:
                main_window = getattr(self.api.app_controller, "main_window", None)
                if main_window and hasattr(main_window, "toolbar"):
                    main_window.toolbar.removeAction(self.button)
                    self.button = None

            # Unregister hooks
            if hasattr(self.api, "hooks"):
                self.api.hooks.unregister_all_hooks(self.plugin_id)

            if hasattr(self.api, "logger"):
                self.api.logger.info(f"Plugin deactivated: {self.plugin_id}")

            return True

        except Exception as e:
            if hasattr(self.api, "logger"):
                self.api.logger.error(
                    f"Error deactivating plugin {self.plugin_id}: {str(e)}"
                )
            return False

    def create_star_icon(self):
        """Create a star icon programmatically."""
        try:
            # Create a 24x24 pixmap
            pixmap = QPixmap(24, 24)
            pixmap.fill(Qt.GlobalColor.transparent)

            # Create a painter
            painter = QPainter(pixmap)
            painter.setRenderHint(QPainter.RenderHint.Antialiasing)

            # Draw a star
            painter.setPen(Qt.PenStyle.NoPen)
            painter.setBrush(QColor(255, 215, 0))  # Gold color

            # Draw a simple star using drawPolygon
            points = [
                QPointF(12, 2),  # Top point
                QPointF(15, 9),  # Right middle outer
                QPointF(22, 9),  # Right middle
                QPointF(16, 14),  # Bottom right outer
                QPointF(19, 21),  # Bottom right
                QPointF(12, 17),  # Bottom point
                QPointF(5, 21),  # Bottom left
                QPointF(8, 14),  # Bottom left outer
                QPointF(2, 9),  # Left middle
                QPointF(9, 9),  # Left middle outer
            ]

            # Draw the star
            painter.drawPolygon(points)
            painter.end()
            return QIcon(pixmap)

        except Exception as e:
            if hasattr(self.api, "logger"):
                self.api.logger.error(f"Error creating icon: {str(e)}")
            return QIcon()

    def on_toolbar_created(self):
        """Handle toolbar created event."""
        if hasattr(self.api, "logger"):
            self.api.logger.info("Toolbar created, adding button...")
        self.add_toolbar_button()

    def add_toolbar_button(self):
        """Add a button to the toolbar."""
        try:
            if self.button is not None:  # Button already added
                return

            # Create a star icon
            star_icon = self.create_star_icon()

            if hasattr(self.api, "logger"):
                self.api.logger.info("Adding toolbar button...")

            # Add the button to the toolbar
            self.button = self.api.ui.add_toolbar_button(
                button_id="sample_button",
                text="Sample",
                icon=star_icon,
                tooltip="Click me! I'm a sample plugin button.",
                callback=self.on_button_clicked,
            )

            if hasattr(self.api, "logger"):
                if self.button:
                    self.api.logger.info("Successfully added toolbar button")
                else:
                    self.api.logger.error("Failed to add toolbar button")

        except Exception as e:
            if hasattr(self.api, "logger"):
                self.api.logger.error(f"Error adding toolbar button: {str(e)}")

    def on_button_clicked(self):
        """Handle button click."""
        try:
            if hasattr(self.api, "ui"):
                self.api.ui.show_message(
                    "Sample Plugin",
                    "Hello from the sample plugin!\n\n"
                    "This button was added by a plugin.",
                )
        except Exception as e:
            if hasattr(self.api, "logger"):
                self.api.logger.error(f"Error in button click handler: {str(e)}")
</file>

<file path="src/plugins/sample_plugins/create_icon.py">
from PyQt6.QtWidgets import QApplication
from PyQt6.QtGui import QIcon, QPixmap, QPainter, QColor
from PyQt6.QtCore import Qt, QRect
import sys

def create_icon():
    # Create a 24x24 pixmap
    pixmap = QPixmap(24, 24)
    pixmap.fill(Qt.GlobalColor.transparent)
    
    # Create a painter
    painter = QPainter(pixmap)
    painter.setRenderHint(QPainter.RenderHint.Antialiasing)
    
    # Draw a star
    painter.setPen(Qt.PenStyle.NoPen)
    painter.setBrush(QColor(255, 215, 0))  # Gold color
    
    # Draw a simple star
    points = [
        (12, 2), (15, 9), (23, 9), (16, 14), 
        (19, 21), (12, 17), (5, 21), (8, 14),
        (1, 9), (9, 9)
    ]
    
    # Draw the star
    painter.drawPolygon(*[points[0], points[1], points[2], points[3], points[4], 
                         points[5], points[6], points[7], points[8], points[9]])
    
    painter.end()
    return QIcon(pixmap)

if __name__ == "__main__":
    app = QApplication(sys.argv)
    icon = create_icon()
    
    # Save the icon
    pixmap = icon.pixmap(24, 24)
    pixmap.save("icon.png")
    
    print("Icon created as icon.png")
</file>

<file path="src/plugins/sample_plugins/generate_icon.py">
#!/usr/bin/env python3
# Generate a simple star icon for the sample plugin

from PyQt6.QtWidgets import QApplication
from PyQt6.QtGui import QPainter, QColor, QPixmap, QIcon
from PyQt6.QtCore import Qt, QPointF
import sys

def create_star_icon():
    # Create a 128x128 pixmap (will be scaled down for smaller sizes)
    size = 128
    pixmap = QPixmap(size, size)
    pixmap.fill(Qt.GlobalColor.transparent)
    
    # Create a painter
    painter = QPainter(pixmap)
    painter.setRenderHint(QPainter.RenderHint.Antialiasing)
    
    # Draw a star
    painter.setPen(Qt.PenStyle.NoPen)
    painter.setBrush(QColor(255, 215, 0))  # Gold color
    
    # Draw a simple star using drawPolygon
    points = []
    for i in range(5):
        # Outer point
        angle = i * 4 * 3.14159 / 5 - 3.14159 / 2  # Offset to start from top
        x = size // 2 + (size // 2 - 10) * 0.9 * math.cos(angle)
        y = size // 2 + (size // 2 - 10) * 0.9 * math.sin(angle)
        points.append(QPointF(x, y))
        
        # Inner point (for star shape)
        angle = (i + 0.5) * 4 * 3.14159 / 5 - 3.14159 / 2
        x = size // 2 + (size // 2 - 10) * 0.4 * math.cos(angle)
        y = size // 2 + (size // 2 - 10) * 0.4 * math.sin(angle)
        points.append(QPointF(x, y))
    
    # Draw the star
    if points:
        painter.drawPolygon(points)
    
    painter.end()
    return pixmap

if __name__ == "__main__":
    import math
    
    # Create the application
    app = QApplication(sys.argv)
    
    # Create the icon
    icon_pixmap = create_star_icon()
    
    # Save the icon in multiple sizes
    sizes = [16, 32, 48, 128]
    for size in sizes:
        scaled_pixmap = icon_pixmap.scaled(size, size, 
                                         Qt.AspectRatioMode.KeepAspectRatio,
                                         Qt.TransformationMode.SmoothTransformation)
        scaled_pixmap.save(f"icon_{size}.png")
        print(f"Saved icon_{size}.png")
    
    # Also save as icon.png (default size 48x48)
    icon_pixmap.scaled(48, 48, 
                      Qt.AspectRatioMode.KeepAspectRatio,
                      Qt.TransformationMode.SmoothTransformation).save("icon.png")
    print("Saved icon.png")
    
    print("Icons generated successfully.")
</file>

<file path="src/plugins/sample_plugins/manifest.json">
{
    "id": "sample_plugin",
    "name": "Sample Plugin",
    "version": "1.0.0",
    "author": "NebulaFusion Team",
    "description": "A sample plugin that demonstrates adding a button to the toolbar.",
    "homepage": "https://github.com/nebulafusion/browser",
    "license": "MIT",
    "permissions": [
        "toolbar"
    ],
    "minimum_browser_version": "1.0.0",
    "api_version": "1.0",
    "icons": {
        "16": "icon.png",
        "32": "icon.png",
        "48": "icon.png",
        "128": "icon.png"
    },
    "background": {
        "scripts": [],
        "persistent": false
    },
    "content_scripts": [],
    "web_accessible_resources": [
        "icon.png"
    ],
    "browser_action": {
        "default_icon": "icon.png",
        "default_title": "Sample Plugin",
        "default_popup": ""
    },
    "options_ui": {
        "page": "options.html",
        "open_in_tab": false
    }
}
</file>

<file path="src/plugins/sandbox.py">
#!/usr/bin/env python3
# NebulaFusion Browser - Plugin Sandbox

import os
import sys
import json
import time
import threading
import resource
import traceback
from PyQt5.QtCore import QObject, pyqtSignal

class PluginSandbox(QObject):
    """
    Enforces security boundaries for plugin execution.
    """
    
    # Signals
    resource_limit_exceeded = pyqtSignal(str, str, float)
    security_violation = pyqtSignal(str, str)
    
    def __init__(self, app_controller, plugin_id):
        """Initialize the plugin sandbox."""
        super().__init__()
        self.app_controller = app_controller
        self.plugin_id = plugin_id
        
        # Resource usage tracking
        self.resource_usage = {
            "cpu_time": 0,
            "memory": 0,
            "api_calls": 0,
            "network_requests": 0,
            "file_access": 0
        }
        
        # Resource limits
        self.resource_limits = {
            "cpu_percent": self.app_controller.settings_manager.get_setting(
                "security_plugin_cpu_percent", 10),
            "memory_mb": self.app_controller.settings_manager.get_setting(
                "security_plugin_memory_mb", 100),
            "network_requests_per_minute": self.app_controller.settings_manager.get_setting(
                "security_plugin_network_requests_per_minute", 60),
            "file_access_paths": self.app_controller.settings_manager.get_setting(
                "security_plugin_file_access_paths", ["~/.nebulafusion/plugins"])
        }
        
        # API call log
        self.api_call_log = []
        
        # Network request log
        self.network_request_log = []
        
        # File access log
        self.file_access_log = []
        
        # Start monitoring thread
        self.monitoring_active = True
        self.monitoring_thread = threading.Thread(target=self._monitor_resources)
        self.monitoring_thread.daemon = True
        self.monitoring_thread.start()
    
    def log_api_call(self, method_name, args, kwargs):
        """Log an API call."""
        # Record API call
        self.api_call_log.append({
            "method": method_name,
            "timestamp": time.time(),
            "args_count": len(args),
            "kwargs_count": len(kwargs)
        })
        
        # Update resource usage
        self.resource_usage["api_calls"] += 1
    
    def log_network_request(self, url, method="GET"):
        """Log a network request."""
        # Record network request
        self.network_request_log.append({
            "url": url,
            "method": method,
            "timestamp": time.time()
        })
        
        # Update resource usage
        self.resource_usage["network_requests"] += 1
        
        # Check network request limit
        self._check_network_request_limit()
    
    def log_file_access(self, path, mode="r"):
        """Log a file access."""
        # Record file access
        self.file_access_log.append({
            "path": path,
            "mode": mode,
            "timestamp": time.time()
        })
        
        # Update resource usage
        self.resource_usage["file_access"] += 1
        
        # Check file access permission
        return self._check_file_access_permission(path, mode)
    
    def _check_network_request_limit(self):
        """Check if network request limit is exceeded."""
        # Get requests in the last minute
        current_time = time.time()
        requests_last_minute = [
            req for req in self.network_request_log
            if req["timestamp"] > current_time - 60
        ]
        
        # Check limit
        if len(requests_last_minute) > self.resource_limits["network_requests_per_minute"]:
            # Log violation
            self.app_controller.logger.warning(
                f"Plugin {self.plugin_id} exceeded network request limit: "
                f"{len(requests_last_minute)} requests in the last minute"
            )
            
            # Emit signal
            self.resource_limit_exceeded.emit(
                self.plugin_id,
                "network_requests_per_minute",
                len(requests_last_minute)
            )
            
            return False
        
        return True
    
    def _check_file_access_permission(self, path, mode):
        """Check if file access is permitted."""
        # Normalize path
        path = os.path.abspath(os.path.expanduser(path))
        
        # Check if path is in allowed paths
        allowed = False
        for allowed_path in self.resource_limits["file_access_paths"]:
            allowed_path = os.path.abspath(os.path.expanduser(allowed_path))
            if path.startswith(allowed_path):
                allowed = True
                break
        
        # Check write permission
        if mode in ("w", "a", "w+", "a+") and not allowed:
            # Log violation
            self.app_controller.logger.warning(
                f"Plugin {self.plugin_id} attempted unauthorized file write: {path}"
            )
            
            # Emit signal
            self.security_violation.emit(
                self.plugin_id,
                f"Unauthorized file write: {path}"
            )
            
            return False
        
        # Check read permission for sensitive files
        sensitive_paths = [
            "/etc/passwd",
            "/etc/shadow",
            "~/.ssh",
            "~/.nebulafusion/settings.json"
        ]
        
        for sensitive_path in sensitive_paths:
            sensitive_path = os.path.abspath(os.path.expanduser(sensitive_path))
            if path.startswith(sensitive_path) and not allowed:
                # Log violation
                self.app_controller.logger.warning(
                    f"Plugin {self.plugin_id} attempted unauthorized access to sensitive file: {path}"
                )
                
                # Emit signal
                self.security_violation.emit(
                    self.plugin_id,
                    f"Unauthorized access to sensitive file: {path}"
                )
                
                return False
        
        return True
    
    def _monitor_resources(self):
        """Monitor plugin resource usage."""
        while self.monitoring_active:
            try:
                # Get plugin process info
                # In a real implementation, we would get the actual process info
                # For now, we'll just simulate resource usage
                
                # Update CPU usage (simulated)
                self.resource_usage["cpu_time"] += 0.1
                
                # Update memory usage (simulated)
                self.resource_usage["memory"] = 50  # MB
                
                # Check CPU limit
                if self.resource_usage["cpu_time"] > self.resource_limits["cpu_percent"]:
                    # Log violation
                    self.app_controller.logger.warning(
                        f"Plugin {self.plugin_id} exceeded CPU limit: "
                        f"{self.resource_usage['cpu_time']}% (limit: {self.resource_limits['cpu_percent']}%)"
                    )
                    
                    # Emit signal
                    self.resource_limit_exceeded.emit(
                        self.plugin_id,
                        "cpu_percent",
                        self.resource_usage["cpu_time"]
                    )
                
                # Check memory limit
                if self.resource_usage["memory"] > self.resource_limits["memory_mb"]:
                    # Log violation
                    self.app_controller.logger.warning(
                        f"Plugin {self.plugin_id} exceeded memory limit: "
                        f"{self.resource_usage['memory']}MB (limit: {self.resource_limits['memory_mb']}MB)"
                    )
                    
                    # Emit signal
                    self.resource_limit_exceeded.emit(
                        self.plugin_id,
                        "memory_mb",
                        self.resource_usage["memory"]
                    )
                
                # Sleep for a bit
                time.sleep(1)
            
            except Exception as e:
                self.app_controller.logger.error(f"Error monitoring plugin resources: {e}")
                self.app_controller.logger.error(traceback.format_exc())
    
    def get_resource_usage(self):
        """Get resource usage."""
        return self.resource_usage
    
    def get_api_call_log(self):
        """Get API call log."""
        return self.api_call_log
    
    def get_network_request_log(self):
        """Get network request log."""
        return self.network_request_log
    
    def get_file_access_log(self):
        """Get file access log."""
        return self.file_access_log
    
    def shutdown(self):
        """Shutdown the sandbox."""
        # Stop monitoring thread
        self.monitoring_active = False
        if self.monitoring_thread.is_alive():
            self.monitoring_thread.join(timeout=1)
        
        # Clear logs
        self.api_call_log.clear()
        self.network_request_log.clear()
        self.file_access_log.clear()
</file>

<file path="src/themes/default_themes.py">
#!/usr/bin/env python3
# NebulaFusion Browser - Default Themes

import os
import sys
import json
import shutil
from PyQt5.QtCore import QObject, pyqtSignal


class DefaultThemes(QObject):
    """
    Provides default themes for the browser.
    """

    # Signals
    theme_created = pyqtSignal(str)

    def __init__(self, app_controller):
        """Initialize the default themes."""
        super().__init__()
        self.app_controller = app_controller

        # Default themes
        self.default_themes = {
            "default": {
                "name": "Default",
                "version": "1.0.0",
                "author": "NebulaFusion",
                "description": "Default theme for NebulaFusion browser.",
                "type": "light",
                "color_scheme": {
                    "primary": "#4a86e8",
                    "secondary": "#f1c232",
                    "background": "#ffffff",
                    "text": "#333333",
                    "accent": "#6aa84f",
                },
            },
            "dark": {
                "name": "Dark",
                "version": "1.0.0",
                "author": "NebulaFusion",
                "description": "Dark theme for NebulaFusion browser.",
                "type": "dark",
                "color_scheme": {
                    "primary": "#4a86e8",
                    "secondary": "#f1c232",
                    "background": "#2d2d2d",
                    "text": "#ffffff",
                    "accent": "#6aa84f",
                },
            },
            "light": {
                "name": "Light",
                "version": "1.0.0",
                "author": "NebulaFusion",
                "description": "Light theme for NebulaFusion browser.",
                "type": "light",
                "color_scheme": {
                    "primary": "#4a86e8",
                    "secondary": "#f1c232",
                    "background": "#ffffff",
                    "text": "#333333",
                    "accent": "#6aa84f",
                },
            },
            "neon": {
                "name": "Neon",
                "version": "1.0.0",
                "author": "NebulaFusion",
                "description": "Neon theme for NebulaFusion browser.",
                "type": "dark",
                "color_scheme": {
                    "primary": "#ff00ff",
                    "secondary": "#00ffff",
                    "background": "#2d2d2d",
                    "text": "#ffffff",
                    "accent": "#ff00ff",
                },
            },
            "minimal": {
                "name": "Minimal",
                "version": "1.0.0",
                "author": "NebulaFusion",
                "description": "Minimal theme for NebulaFusion browser.",
                "type": "light",
                "color_scheme": {
                    "primary": "#4a86e8",
                    "secondary": "#f1c232",
                    "background": "#ffffff",
                    "text": "#333333",
                    "accent": "#6aa84f",
                },
            },
        }

    def create_default_themes(self, themes_dir):
        """Create default themes in the specified directory."""
        # Create themes directory if it doesn't exist
        os.makedirs(themes_dir, exist_ok=True)

        # Create each default theme
        for theme_name, theme_info in self.default_themes.items():
            theme_dir = os.path.join(themes_dir, theme_name)
            if not os.path.exists(theme_dir):
                os.makedirs(theme_dir, exist_ok=True)

                # Create theme.json
                with open(os.path.join(theme_dir, "theme.json"), "w") as f:
                    json.dump(theme_info, f, indent=4)

                # Create style.qss
                style_content = self._generate_style(theme_name, theme_info)
                with open(os.path.join(theme_dir, "style.qss"), "w") as f:
                    f.write(style_content)

                # Create preview.png placeholder
                # In a real implementation, we would create an actual preview image
                with open(os.path.join(theme_dir, "preview.png"), "w") as f:
                    f.write("Preview image placeholder")

                # Emit signal
                self.theme_created.emit(theme_name)

    def _generate_style(self, theme_name, theme_info):
        """Generate style for a theme."""
        # Get color scheme
        colors = theme_info["color_scheme"]

        # Generate style based on theme name
        if theme_name == "default":
            return self._generate_default_style(colors)
        elif theme_name == "dark":
            return self._generate_dark_style(colors)
        elif theme_name == "light":
            return self._generate_light_style(colors)
        elif theme_name == "neon":
            return self._generate_neon_style(colors)
        elif theme_name == "minimal":
            return self._generate_minimal_style(colors)
        else:
            return self._generate_default_style(colors)

    def _generate_default_style(self, colors):
        """Generate default style."""
        return f"""
/* Default Theme */
QMainWindow, QDialog {{
    background-color: {colors["background"]};
    color: {colors["text"]};
}}

QTabWidget::pane {{
    border: 1px solid #cccccc;
    background-color: {colors["background"]};
}}

QTabBar::tab {{
    background-color: #e6e6e6;
    color: #333333;
    padding: 6px 12px;
    border: 1px solid #cccccc;
    border-bottom: none;
    border-top-left-radius: 4px;
    border-top-right-radius: 4px;
}}

QTabBar::tab:selected {{
    background-color: {colors["background"]};
    border-bottom: 1px solid {colors["background"]};
}}

QTabBar::tab:hover {{
    background-color: #f0f0f0;
}}

QLineEdit {{
    padding: 6px;
    border: 1px solid #cccccc;
    border-radius: 4px;
    background-color: {colors["background"]};
    color: {colors["text"]};
}}

QPushButton {{
    background-color: {colors["primary"]};
    color: white;
    padding: 6px 12px;
    border: none;
    border-radius: 4px;
}}

QPushButton:hover {{
    background-color: #3a76d8;
}}

QPushButton:pressed {{
    background-color: #2a66c8;
}}

QToolBar {{
    background-color: #f5f5f5;
    border-bottom: 1px solid #cccccc;
    spacing: 6px;
    padding: 3px;
}}

QMenuBar {{
    background-color: #f5f5f5; /* Light grey background for menu bar */
    color: #333333; /* Dark text for menu bar */
}}

QMenuBar::item {{
    spacing: 3px;
    padding: 6px 12px;
    background: transparent;
}}

QMenuBar::item:selected {{
    background: #e0e0e0; /* Highlight on hover/selection */
}}

QToolButton {{
    background-color: transparent;
    border: none;
    padding: 4px;
    border-radius: 4px;
    color: #333333; /* Ensure readability against light backgrounds */
}}

QToolButton:hover {{
    background-color: #e0e0e0;
}}

QToolButton:pressed {{
    background-color: #d0d0d0;
}}

QMenu {{
    background-color: {colors["background"]};
    color: #333333; /* Ensure readability against light backgrounds */
    border: 1px solid #cccccc;
}}

QMenu::item {{
    padding: 6px 24px 6px 12px;
}}

QMenu::item:selected {{
    background-color: {colors["primary"]};
    color: white;
}}

QStatusBar {{
    background-color: #f5f5f5;
    color: #666666;
    border-top: 1px solid #cccccc;
}}

QProgressBar {{
    border: 1px solid #cccccc;
    border-radius: 4px;
    text-align: center;
}}

QProgressBar::chunk {{
    background-color: {colors["primary"]};
}}
"""

    def _generate_dark_style(self, colors):
        """Generate dark style."""
        return f"""
/* Dark Theme */
QMainWindow, QDialog {{
    background-color: {colors["background"]};
    color: {colors["text"]};
}}

QTabWidget::pane {{
    border: 1px solid #444444;
    background-color: {colors["background"]};
}}

QTabBar::tab {{
    background-color: #3d3d3d;
    color: #e0e0e0;
    padding: 6px 12px;
    border: 1px solid #444444;
    border-bottom: none;
    border-top-left-radius: 4px;
    border-top-right-radius: 4px;
}}

QTabBar::tab:selected {{
    background-color: {colors["background"]};
    border-bottom: 1px solid {colors["background"]};
}}

QTabBar::tab:hover {{
    background-color: #4d4d4d;
}}

QLineEdit {{
    padding: 6px;
    border: 1px solid #444444;
    border-radius: 4px;
    background-color: #3d3d3d;
    color: {colors["text"]};
}}

QPushButton {{
    background-color: {colors["primary"]};
    color: white;
    padding: 6px 12px;
    border: none;
    border-radius: 4px;
}}

QPushButton:hover {{
    background-color: #3a76d8;
}}

QPushButton:pressed {{
    background-color: #2a66c8;
}}

QToolBar {{
    background-color: #3d3d3d;
    border-bottom: 1px solid #444444;
    spacing: 6px;
    padding: 3px;
}}

QMenuBar {{
    background-color: #3d3d3d; /* Dark grey background for menu bar */
   
}}

QMenuBar::item {{
    spacing: 3px;
    padding: 6px 12px;
    background: transparent;
}}

QMenuBar::item:selected {{
    background: #4d4d4d; /* Highlight on hover/selection */
}}

QToolButton {{
    background-color: transparent;
    border: none;
    padding: 4px;
    border-radius: 4px;
    color: #333333; /* Ensure readability against light backgrounds */
}}

QToolButton:hover {{
    background-color: #4d4d4d;
}}

QToolButton:pressed {{
    background-color: #5d5d5d;
}}

QMenu {{
    background-color: {colors["background"]};
    color: #ffffff; /* Ensure readability against dark backgrounds */
    border: 1px solid #444444;
}}

QMenu::item {{
    padding: 6px 24px 6px 12px;
}}

QMenu::item:selected {{
    background-color: {colors["primary"]};
    color: white;
}}

QStatusBar {{
    background-color: #3d3d3d;
    color: #b0b0b0;
    border-top: 1px solid #444444;
}}

QProgressBar {{
    border: 1px solid #444444;
    border-radius: 4px;
    text-align: center;
}}

QProgressBar::chunk {{
    background-color: {colors["primary"]};
}}
"""

    def _generate_light_style(self, colors):
        """Generate light style."""
        return f"""
/* Light Theme */
QMainWindow, QDialog {{
    background-color: {colors["background"]};
    color: {colors["text"]};
}}

QTabWidget::pane {{
    border: 1px solid #e0e0e0;
    background-color: {colors["background"]};
}}

QTabBar::tab {{
    background-color: #f0f0f0;
    color: #333333;
    padding: 6px 12px;
    border: 1px solid #e0e0e0;
    border-bottom: none;
    border-top-left-radius: 4px;
    border-top-right-radius: 4px;
}}

QTabBar::tab:selected {{
    background-color: {colors["background"]};
    border-bottom: 1px solid {colors["background"]};
}}

QTabBar::tab:hover {{
    background-color: #f8f8f8;
}}

QLineEdit {{
    padding: 6px;
    border: 1px solid #e0e0e0;
    border-radius: 4px;
    background-color: {colors["background"]};
    color: {colors["text"]};
}}

QPushButton {{
    background-color: {colors["primary"]};
    color: white;
    padding: 6px 12px;
    border: none;
    border-radius: 4px;
}}

QPushButton:hover {{
    background-color: #3a76d8;
}}

QPushButton:pressed {{
    background-color: #2a66c8;
}}

QToolBar {{
    background-color: #f8f8f8;
    border-bottom: 1px solid #e0e0e0;
    spacing: 6px;
    padding: 3px;
}}

QMenuBar {{
    background-color: #f8f8f8; /* Light grey background for menu bar */
    color: #333333; /* Dark text for menu bar */
}}

QMenuBar::item {{
    spacing: 3px;
    padding: 6px 12px;
    background: transparent;
}}

QMenuBar::item:selected {{
    background: #f0f0f0; /* Highlight on hover/selection */
}}

QToolButton {{
    background-color: transparent;
    border: none;
    padding: 4px;
    border-radius: 4px;
}}

QToolButton:hover {{
    background-color: #f0f0f0;
}}

QToolButton:pressed {{
    background-color: #e8e8e8;
}}

QMenu {{
    background-color: {colors["background"]};
    color: #333333; /* Ensure readability against light backgrounds */
    border: 1px solid #e0e0e0;
}}

QMenu::item {{
    padding: 6px 24px 6px 12px;
}}

QMenu::item:selected {{
    background-color: {colors["primary"]};
    color: white;
}}

QStatusBar {{
    background-color: #f8f8f8;
    color: #666666;
    border-top: 1px solid #e0e0e0;
}}

QProgressBar {{
    border: 1px solid #e0e0e0;
    border-radius: 4px;
    text-align: center;
}}

QProgressBar::chunk {{
    background-color: {colors["primary"]};
}}
"""

    def _generate_neon_style(self, colors):
        """Generate neon style."""
        return f"""
/* Neon Theme */
QMainWindow, QDialog {{
    background-color: {colors["background"]};
    color: {colors["text"]};
}}

QTabWidget::pane {{
    border: 1px solid #444444;
    background-color: {colors["background"]};
}}

QTabBar::tab {{
    background-color: #3d3d3d;
    color: #00ffff;
    padding: 6px 12px;
    border: 1px solid #444444;
    border-bottom: none;
    border-top-left-radius: 4px;
    border-top-right-radius: 4px;
}}

QTabBar::tab:selected {{
    background-color: {colors["background"]};
    border-bottom: 1px solid {colors["background"]};
    color: #ff00ff;
}}

QTabBar::tab:hover {{
    background-color: #4d4d4d;
    color: #ff00ff;
}}

QLineEdit {{
    padding: 6px;
    border: 1px solid #ff00ff;
    border-radius: 4px;
    background-color: #3d3d3d;
    color: #00ffff;
}}

QPushButton {{
    background-color: {colors["primary"]};
    color: #00ffff;
    padding: 6px 12px;
    border: none;
    border-radius: 4px;
}}

QPushButton:hover {{
    background-color: #ff00aa;
}}

QPushButton:pressed {{
    background-color: #cc0088;
}}

QToolBar {{
    background-color: #3d3d3d;
    border-bottom: 1px solid #ff00ff;
    spacing: 6px;
    padding: 3px;
}}

QMenuBar {{
    background-color: #3d3d3d; /* Dark grey background for menu bar */
    color: #00ffff; /* Neon text for menu bar */
}}

QMenuBar::item {{
    spacing: 3px;
    padding: 6px 12px;
    background: transparent;
}}

QMenuBar::item:selected {{
    background: #4d4d4d; /* Highlight on hover/selection */
}}

QToolButton {{
    background-color: transparent;
    border: none;
    padding: 4px;
    border-radius: 4px;
}}

QToolButton:hover {{
    background-color: #4d4d4d;
}}

QToolButton:pressed {{
    background-color: #5d5d5d;
}}

QMenu {{
    background-color: {colors["background"]};
    color: #ffffff; /* Ensure readability against dark backgrounds */
    border: 1px solid #ff00ff;
}}

QMenu::item {{
    padding: 6px 24px 6px 12px;
}}

QMenu::item:selected {{
    background-color: {colors["primary"]};
    color: #00ffff;
}}

QStatusBar {{
    background-color: #3d3d3d;
    color: #00ffff;
    border-top: 1px solid #ff00ff;
}}

QProgressBar {{
    border: 1px solid #ff00ff;
    border-radius: 4px;
    text-align: center;
}}

QProgressBar::chunk {{
    background-color: {colors["primary"]};
}}
"""

    def _generate_minimal_style(self, colors):
        """Generate minimal style."""
        return f"""
/* Minimal Theme */
QMainWindow, QDialog {{
    background-color: {colors["background"]};
    color: {colors["text"]};
}}

QTabWidget::pane {{
    border: none;
    background-color: {colors["background"]};
}}

QTabBar::tab {{
    background-color: transparent;
    color: #666666;
    padding: 6px 12px;
    border: none;
    border-bottom: 2px solid transparent;
}}

QTabBar::tab:selected {{
    color: {colors["primary"]};
    border-bottom: 2px solid {colors["primary"]};
}}

QTabBar::tab:hover {{
    color: {colors["primary"]};
}}

QLineEdit {{
    padding: 6px;
    border: none;
    border-bottom: 1px solid #cccccc;
    background-color: {colors["background"]};
    color: {colors["text"]};
}}

QPushButton {{
    background-color: transparent;
    color: {colors["primary"]};
    padding: 6px 12px;
    border: 1px solid {colors["primary"]};
    border-radius: 4px;
}}

QPushButton:hover {{
    background-color: {colors["primary"]};
    color: white;
}}

QPushButton:pressed {{
    background-color: #3a76d8;
    color: white;
}}

QToolBar {{
    background-color: {colors["background"]};
    border: none;
    spacing: 6px;
    padding: 3px;
}}

QMenuBar {{
    background-color: {colors["background"]}; /* Background color from theme */
    color: #333333; /* Dark text for menu bar */
}}

QMenuBar::item {{
    spacing: 3px;
    padding: 6px 12px;
    
}}

QMenuBar::item:selected {{
    background: #f0f0f0; /* Highlight on hover/selection */
}}

QToolButton {{
    background-color: transparent;
    border: none;
    padding: 4px;
    border-radius: 4px;
}}

QToolButton:hover {{
    background-color: #f0f0f0;
}}

QToolButton:pressed {{
    background-color: #e0e0e0;
}}

QMenu {{
    background-color: {colors["background"]};
    color: #333333; /* Ensure readability against light backgrounds */
    border: 1px solid #cccccc;
}}

QMenu::item {{
    padding: 6px 24px 6px 12px;
}}

QMenu::item:selected {{
    background-color: #f0f0f0;
    color: {colors["primary"]};
}}

QStatusBar {{
    background-color: {colors["background"]};
    color: #666666;
    border: none;
}}

QProgressBar {{
    border: none;
    border-radius: 2px;
    text-align: center;
    background-color: #f0f0f0;
}}

QProgressBar::chunk {{
    background-color: {colors["primary"]};
}}
"""
</file>

<file path="src/themes/theme_loader.py">
#!/usr/bin/env python3
# NebulaFusion Browser - Theme Loader

import os
import sys
import json
from PyQt5.QtCore import QObject, pyqtSignal, QFile, QTextStream

class ThemeLoader(QObject):
    """
    Loads and parses theme files.
    """
    
    # Signals
    theme_loaded = pyqtSignal(str, dict)
    
    def __init__(self, app_controller):
        """Initialize the theme loader."""
        super().__init__()
        self.app_controller = app_controller
    
    def load_theme(self, theme_dir):
        """Load a theme from a directory."""
        try:
            # Check if theme.json exists
            theme_json = os.path.join(theme_dir, "theme.json")
            if not os.path.exists(theme_json):
                self.app_controller.logger.error(f"Theme.json not found in {theme_dir}")
                return None
            
            # Load theme.json
            with open(theme_json, 'r') as f:
                theme_info = json.load(f)
            
            # Check if style.qss exists
            style_file = os.path.join(theme_dir, "style.qss")
            if not os.path.exists(style_file):
                self.app_controller.logger.error(f"Style.qss not found in {theme_dir}")
                return None
            
            # Load style.qss
            with open(style_file, 'r') as f:
                style = f.read()
            
            # Create theme data
            theme_data = {
                "info": theme_info,
                "style": style,
                "dir": theme_dir
            }
            
            # Check for preview image
            preview_file = os.path.join(theme_dir, "preview.png")
            if os.path.exists(preview_file):
                theme_data["preview"] = preview_file
            
            # Emit signal
            theme_name = os.path.basename(theme_dir)
            self.theme_loaded.emit(theme_name, theme_data)
            
            return theme_data
        
        except Exception as e:
            self.app_controller.logger.error(f"Error loading theme from {theme_dir}: {e}")
            return None
    
    def parse_color_scheme(self, theme_info):
        """Parse color scheme from theme info."""
        color_scheme = theme_info.get("color_scheme", {})
        
        # Set default colors if missing
        if "primary" not in color_scheme:
            color_scheme["primary"] = "#4a86e8"
        if "secondary" not in color_scheme:
            color_scheme["secondary"] = "#f1c232"
        if "background" not in color_scheme:
            color_scheme["background"] = "#ffffff" if theme_info.get("type") == "light" else "#2d2d2d"
        if "text" not in color_scheme:
            color_scheme["text"] = "#333333" if theme_info.get("type") == "light" else "#ffffff"
        if "accent" not in color_scheme:
            color_scheme["accent"] = "#6aa84f"
        
        return color_scheme
    
    def generate_preview(self, theme_data):
        """Generate a preview image for a theme."""
        # This would typically generate a preview image
        # For now, just return a placeholder
        return os.path.join(theme_data["dir"], "preview.png")
</file>

<file path="src/themes/theme_manager.py">
#!/usr/bin/env python3
# NebulaFusion Browser - Theme Manager

import os
import sys
import json
from PyQt6.QtCore import QObject, pyqtSignal, QFile, QTextStream
from PyQt6.QtWidgets import QApplication


class ThemeManager(QObject):
    """
    Manager for browser themes.
    Handles loading, applying, and switching themes.
    """

    # Signals
    theme_changed = pyqtSignal(str)  # theme_name
    theme_loaded = pyqtSignal(str)  # theme_name

    def __init__(self, app_controller):
        """Initialize the theme manager."""
        super().__init__()
        self.app_controller = app_controller

        # Current theme
        self.current_theme = None

        # Available themes
        self.available_themes = {}

        # Theme directories
        self.theme_dirs = []

        # Default theme directory
        self.default_theme_dir = os.path.expanduser("~/.nebulafusion/themes")

        # Built-in theme directory
        self.builtin_theme_dir = os.path.join(
            os.path.dirname(os.path.dirname(os.path.abspath(__file__))),
            "themes",
            "default_themes",
        )

    def initialize(self):
        """Initialize the theme manager."""
        self.app_controller.logger.info("Initializing theme manager...")

        # Create default theme directory if it doesn't exist
        os.makedirs(self.default_theme_dir, exist_ok=True)

        # Add theme directories
        self.theme_dirs.append(self.default_theme_dir)
        if os.path.exists(self.builtin_theme_dir):
            self.theme_dirs.append(self.builtin_theme_dir)

        # Load themes
        self._load_themes()

        # Apply default theme
        default_theme = self.app_controller.settings_manager.get_setting(
            "theme", "Default"
        )
        self.apply_theme(default_theme)

        self.app_controller.logger.info("Theme manager initialized.")

    def _load_themes(self):
        """Load themes from theme directories."""
        # Clear available themes
        self.available_themes = {}

        # Load built-in themes
        self._load_builtin_themes()

        # Load themes from theme directories
        for theme_dir in self.theme_dirs:
            # Check if directory exists
            if not os.path.exists(theme_dir):
                continue

            # Get theme files
            for item in os.listdir(theme_dir):
                item_path = os.path.join(theme_dir, item)

                # Check if item is a directory
                if os.path.isdir(item_path):
                    # Check if directory contains theme.json
                    theme_json_path = os.path.join(item_path, "theme.json")
                    if os.path.exists(theme_json_path):
                        # Load theme
                        self._load_theme(item_path)

    def _load_builtin_themes(self):
        """Load built-in themes."""
        # Default theme
        self.available_themes["Default"] = {
            "name": "Default",
            "description": "Default theme for NebulaFusion browser.",
            "author": "NebulaFusion Team",
            "version": "1.0.0",
            "dark": False,
            "stylesheet": self._get_default_stylesheet(),
            "colors": {
                "primary": "#4285F4",
                "secondary": "#34A853",
                "accent": "#FBBC05",
                "background": "#FFFFFF",
                "foreground": "#202124",
                "surface": "#F8F9FA",
                "error": "#EA4335",
                "warning": "#FBBC05",
                "success": "#34A853",
                "info": "#4285F4",
            },
        }

        # Dark theme
        self.available_themes["Dark"] = {
            "name": "Dark",
            "description": "Dark theme for NebulaFusion browser.",
            "author": "NebulaFusion Team",
            "version": "1.0.0",
            "dark": True,
            "stylesheet": self._get_dark_stylesheet(),
            "colors": {
                "primary": "#BB86FC",
                "secondary": "#03DAC6",
                "accent": "#CF6679",
                "background": "#121212",
                "foreground": "#E1E1E1",
                "surface": "#1E1E1E",
                "error": "#CF6679",
                "warning": "#FFDE03",
                "success": "#03DAC6",
                "info": "#BB86FC",
            },
        }

        # Light theme
        self.available_themes["Light"] = {
            "name": "Light",
            "description": "Light theme for NebulaFusion browser.",
            "author": "NebulaFusion Team",
            "version": "1.0.0",
            "dark": False,
            "stylesheet": self._get_light_stylesheet(),
            "colors": {
                "primary": "#6200EE",
                "secondary": "#03DAC6",
                "accent": "#BB86FC",
                "background": "#FFFFFF",
                "foreground": "#000000",
                "surface": "#F5F5F5",
                "error": "#B00020",
                "warning": "#FB8C00",
                "success": "#4CAF50",
                "info": "#2196F3",
            },
        }

        # Neon theme
        self.available_themes["Neon"] = {
            "name": "Neon",
            "description": "Neon theme for NebulaFusion browser.",
            "author": "NebulaFusion Team",
            "version": "1.0.0",
            "dark": True,
            "stylesheet": self._get_neon_stylesheet(),
            "colors": {
                "primary": "#FF00FF",
                "secondary": "#00FFFF",
                "accent": "#FFFF00",
                "background": "#000000",
                "foreground": "#FFFFFF",
                "surface": "#1A1A1A",
                "error": "#FF0000",
                "warning": "#FFFF00",
                "success": "#00FF00",
                "info": "#00FFFF",
            },
        }

        # Minimal theme
        self.available_themes["Minimal"] = {
            "name": "Minimal",
            "description": "Minimal theme for NebulaFusion browser.",
            "author": "NebulaFusion Team",
            "version": "1.0.0",
            "dark": False,
            "stylesheet": self._get_minimal_stylesheet(),
            "colors": {
                "primary": "#000000",
                "secondary": "#666666",
                "accent": "#CCCCCC",
                "background": "#FFFFFF",
                "foreground": "#000000",
                "surface": "#F5F5F5",
                "error": "#FF0000",
                "warning": "#FFA500",
                "success": "#008000",
                "info": "#0000FF",
            },
        }

    def _load_theme(self, theme_path):
        """Load a theme from a path."""
        try:
            # Load theme.json
            theme_json_path = os.path.join(theme_path, "theme.json")
            with open(theme_json_path, "r") as f:
                theme_data = json.load(f)

            # Validate theme data
            required_fields = ["name", "description", "author", "version", "dark"]
            for field in required_fields:
                if field not in theme_data:
                    self.app_controller.logger.warning(
                        f"Missing required field in theme: {field}"
                    )
                    return

            # Load stylesheet
            stylesheet_path = os.path.join(theme_path, "stylesheet.qss")
            if os.path.exists(stylesheet_path):
                with open(stylesheet_path, "r") as f:
                    theme_data["stylesheet"] = f.read()
            else:
                theme_data["stylesheet"] = ""

            # Add theme
            self.available_themes[theme_data["name"]] = theme_data

            # Emit signal
            self.theme_loaded.emit(theme_data["name"])

            self.app_controller.logger.info(f"Theme loaded: {theme_data['name']}")

        except Exception as e:
            self.app_controller.logger.error(f"Error loading theme: {e}")

    def apply_theme(self, theme_name):
        """Apply a theme."""
        # Check if theme exists
        if theme_name not in self.available_themes:
            self.app_controller.logger.warning(f"Theme not found: {theme_name}")

            # Apply default theme
            if "Default" in self.available_themes:
                theme_name = "Default"
            else:
                return False

        # Get theme
        theme = self.available_themes[theme_name]

        # Apply stylesheet
        if "stylesheet" in theme:
            QApplication.instance().setStyleSheet(theme["stylesheet"])

        # Update current theme
        self.current_theme = theme_name

        # Save theme setting
        self.app_controller.settings_manager.set_setting("theme", theme_name)

        # Emit signal
        self.theme_changed.emit(theme_name)

        # Trigger hook
        self.app_controller.hook_registry.trigger_hook(
            "onThemeChanged", theme_name, theme
        )

        self.app_controller.logger.info(f"Theme applied: {theme_name}")

        return True

    def get_current_theme(self):
        """Get the current theme."""
        if self.current_theme:
            return self.available_themes[self.current_theme]
        return None

    def get_theme(self, theme_name):
        """Get a theme by name."""
        return self.available_themes.get(theme_name)

    def get_themes(self):
        """Get all available themes."""
        return self.available_themes

    def is_dark_mode(self):
        """Check if dark mode is enabled."""
        current_theme = self.get_current_theme()
        if current_theme:
            return current_theme.get("dark", False)
        return False

    def toggle_dark_mode(self):
        """Toggle between light and dark mode."""
        if self.is_dark_mode():
            # Switch to light theme
            if "Light" in self.available_themes:
                return self.apply_theme("Light")
            elif "Default" in self.available_themes:
                return self.apply_theme("Default")
        else:
            # Switch to dark theme
            if "Dark" in self.available_themes:
                return self.apply_theme("Dark")

        return False

    def create_theme(self, theme_data, save=True):
        """Create a new theme."""
        try:
            # Validate theme data
            required_fields = [
                "name",
                "description",
                "author",
                "version",
                "dark",
                "stylesheet",
                "colors",
            ]
            for field in required_fields:
                if field not in theme_data:
                    self.app_controller.logger.warning(
                        f"Missing required field in theme: {field}"
                    )
                    return False

            # Add theme
            self.available_themes[theme_data["name"]] = theme_data

            # Save theme
            if save:
                self._save_theme(theme_data)

            # Emit signal
            self.theme_loaded.emit(theme_data["name"])

            self.app_controller.logger.info(f"Theme created: {theme_data['name']}")

            return True

        except Exception as e:
            self.app_controller.logger.error(f"Error creating theme: {e}")
            return False

    def _save_theme(self, theme_data):
        """Save a theme to disk."""
        try:
            # Create theme directory
            theme_dir = os.path.join(self.default_theme_dir, theme_data["name"])
            os.makedirs(theme_dir, exist_ok=True)

            # Save theme.json
            theme_json = theme_data.copy()
            if "stylesheet" in theme_json:
                del theme_json["stylesheet"]

            with open(os.path.join(theme_dir, "theme.json"), "w") as f:
                json.dump(theme_json, f, indent=4)

            # Save stylesheet
            if "stylesheet" in theme_data:
                with open(os.path.join(theme_dir, "stylesheet.qss"), "w") as f:
                    f.write(theme_data["stylesheet"])

            return True

        except Exception as e:
            self.app_controller.logger.error(f"Error saving theme: {e}")
            return False

    def delete_theme(self, theme_name):
        """Delete a theme."""
        try:
            # Check if theme exists
            if theme_name not in self.available_themes:
                self.app_controller.logger.warning(f"Theme not found: {theme_name}")
                return False

            # Check if theme is built-in
            if theme_name in ["Default", "Dark", "Light", "Neon", "Minimal"]:
                self.app_controller.logger.warning(
                    f"Cannot delete built-in theme: {theme_name}"
                )
                return False

            # Check if theme is current
            if theme_name == self.current_theme:
                # Apply default theme
                self.apply_theme("Default")

            # Remove theme
            del self.available_themes[theme_name]

            # Delete theme directory
            theme_dir = os.path.join(self.default_theme_dir, theme_name)
            if os.path.exists(theme_dir):
                import shutil

                shutil.rmtree(theme_dir)

            self.app_controller.logger.info(f"Theme deleted: {theme_name}")

            return True

        except Exception as e:
            self.app_controller.logger.error(f"Error deleting theme: {e}")
            return False

    def _get_default_stylesheet(self):
        """Get the default stylesheet."""
        return """
/* Default Theme for NebulaFusion Browser */

/* Main Window */
QMainWindow {
    background-color: #FFFFFF;
    color: #202124;
}

/* Menu Bar */
QMenuBar {
    background-color: #F8F9FA;
    color: #202124;
}

QMenuBar::item {
    background-color: transparent;
    padding: 4px 10px;
}

QMenuBar::item:selected {
    background-color: #E8F0FE;
    color: #1A73E8;
}

QMenuBar::item:pressed {
    background-color: #D2E3FC;
    color: #1A73E8;
}

/* Menu */
QMenu {
    background-color: #FFFFFF;
    color: #202124;
    border: 1px solid #DADCE0;
}

QMenu::item {
    padding: 6px 25px 6px 20px;
}

QMenu::item:selected {
    background-color: #E8F0FE;
    color: #1A73E8;
}

QMenu::separator {
    height: 1px;
    background-color: #DADCE0;
    margin: 4px 0px;
}

/* Toolbar */
QToolBar {
    background-color: #F8F9FA;
    border-bottom: 1px solid #DADCE0;
    spacing: 2px;
    padding: 2px;
}

QToolBar::separator {
    width: 1px;
    background-color: #DADCE0;
    margin: 0px 4px;
}

QToolButton {
    background-color: transparent;
    border: 1px solid transparent;
    border-radius: 4px;
    padding: 4px;
    color: #202124; /* Ensure readability against light backgrounds */
}

QToolButton:hover {
    background-color: #E8F0FE;
    border: 1px solid #D2E3FC;
}

QToolButton:pressed {
    background-color: #D2E3FC;
}

QToolButton:checked {
    background-color: #D2E3FC;
    border: 1px solid #4285F4;
}

/* Tab Widget */
QTabWidget::pane {
    border: 1px solid #DADCE0;
    background-color: #FFFFFF;
}

QTabBar::tab {
    background-color: #F8F9FA;
    color: #5F6368;
    border: 1px solid #DADCE0;
    border-bottom: none;
    border-top-left-radius: 4px;
    border-top-right-radius: 4px;
    padding: 6px 10px;
    margin-right: 2px;
}

QTabBar::tab:selected {
    background-color: #FFFFFF;
    color: #202124;
    border-bottom: none;
}

QTabBar::tab:hover:!selected {
    background-color: #E8F0FE;
}

QTabBar::close-button {
    image: url(:/icons/close.png);
    subcontrol-position: right;
}

QTabBar::close-button:hover {
    background-color: #E8F0FE;
    border-radius: 2px;
}

/* Line Edit (Address Bar) */
QLineEdit {
    background-color: #FFFFFF;
    color: #202124;
    border: 1px solid #DADCE0;
    border-radius: 4px;
    padding: 6px;
    selection-background-color: #D2E3FC;
}

QLineEdit:focus {
    border: 1px solid #4285F4;
}

/* Push Button */
QPushButton {
    background-color: #4285F4;
    color: #FFFFFF;
    border: none;
    border-radius: 4px;
    padding: 6px 16px;
    min-width: 80px;
}

QPushButton:hover {
    background-color: #5094FC;
}

QPushButton:pressed {
    background-color: #3367D6;
}

QPushButton:disabled {
    background-color: #DADCE0;
    color: #9AA0A6;
}

/* Combo Box */
QComboBox {
    background-color: #FFFFFF;
    color: #202124;
    border: 1px solid #DADCE0;
    border-radius: 4px;
    padding: 6px;
    min-width: 6em;
}

QComboBox:hover {
    border: 1px solid #4285F4;
}

QComboBox:on {
    border: 1px solid #4285F4;
}

QComboBox::drop-down {
    subcontrol-origin: padding;
    subcontrol-position: top right;
    width: 20px;
    border-left: 1px solid #DADCE0;
}

QComboBox::down-arrow {
    image: url(:/icons/dropdown.png);
}

QComboBox QAbstractItemView {
    background-color: #FFFFFF;
    color: #202124;
    border: 1px solid #DADCE0;
    selection-background-color: #E8F0FE;
    selection-color: #1A73E8;
}

/* Check Box */
QCheckBox {
    color: #202124;
    spacing: 5px;
}

QCheckBox::indicator {
    width: 18px;
    height: 18px;
}

QCheckBox::indicator:unchecked {
    image: url(:/icons/checkbox_unchecked.png);
}

QCheckBox::indicator:checked {
    image: url(:/icons/checkbox_checked.png);
}

/* Radio Button */
QRadioButton {
    color: #202124;
    spacing: 5px;
}

QRadioButton::indicator {
    width: 18px;
    height: 18px;
}

QRadioButton::indicator:unchecked {
    image: url(:/icons/radio_unchecked.png);
}

QRadioButton::indicator:checked {
    image: url(:/icons/radio_checked.png);
}

/* Slider */
QSlider::groove:horizontal {
    border: none;
    height: 4px;
    background-color: #DADCE0;
    border-radius: 2px;
}

QSlider::handle:horizontal {
    background-color: #4285F4;
    border: none;
    width: 16px;
    height: 16px;
    margin: -6px 0;
    border-radius: 8px;
}

QSlider::handle:horizontal:hover {
    background-color: #5094FC;
}

/* Progress Bar */
QProgressBar {
    border: 1px solid #DADCE0;
    border-radius: 4px;
    background-color: #F8F9FA;
    text-align: center;
    color: #202124;
}

QProgressBar::chunk {
    background-color: #4285F4;
    width: 1px;
}

/* Scroll Bar */
QScrollBar:vertical {
    border: none;
    background-color: #F8F9FA;
    width: 10px;
    margin: 0px;
}

QScrollBar::handle:vertical {
    background-color: #DADCE0;
    min-height: 20px;
    border-radius: 5px;
}

QScrollBar::handle:vertical:hover {
    background-color: #BABCBE;
}

QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {
    height: 0px;
}

QScrollBar:horizontal {
    border: none;
    background-color: #F8F9FA;
    height: 10px;
    margin: 0px;
}

QScrollBar::handle:horizontal {
    background-color: #DADCE0;
    min-width: 20px;
    border-radius: 5px;
}

QScrollBar::handle:horizontal:hover {
    background-color: #BABCBE;
}

QScrollBar::add-line:horizontal, QScrollBar::sub-line:horizontal {
    width: 0px;
}

/* Status Bar */
QStatusBar {
    background-color: #F8F9FA;
    color: #5F6368;
    border-top: 1px solid #DADCE0;
}

QStatusBar::item {
    border: none;
}

/* Dialog */
QDialog {
    background-color: #FFFFFF;
    color: #202124;
}

QDialog QLabel {
    color: #202124;
}

/* Group Box */
QGroupBox {
    border: 1px solid #DADCE0;
    border-radius: 4px;
    margin-top: 1ex;
    padding-top: 10px;
    color: #202124;
}

QGroupBox::title {
    subcontrol-origin: margin;
    subcontrol-position: top left;
    padding: 0 3px;
    color: #5F6368;
}

/* Spin Box */
QSpinBox, QDoubleSpinBox {
    background-color: #FFFFFF;
    color: #202124;
    border: 1px solid #DADCE0;
    border-radius: 4px;
    padding: 6px;
}

QSpinBox:hover, QDoubleSpinBox:hover {
    border: 1px solid #4285F4;
}

QSpinBox::up-button, QDoubleSpinBox::up-button {
    subcontrol-origin: border;
    subcontrol-position: top right;
    width: 16px;
    border-left: 1px solid #DADCE0;
    border-bottom: 1px solid #DADCE0;
}

QSpinBox::down-button, QDoubleSpinBox::down-button {
    subcontrol-origin: border;
    subcontrol-position: bottom right;
    width: 16px;
    border-left: 1px solid #DADCE0;
    border-top: 1px solid #DADCE0;
}

/* Text Edit */
QTextEdit {
    background-color: #FFFFFF;
    color: #202124;
    border: 1px solid #DADCE0;
    border-radius: 4px;
    selection-background-color: #D2E3FC;
}

QTextEdit:focus {
    border: 1px solid #4285F4;
}

/* List Widget */
QListWidget {
    background-color: #FFFFFF;
    color: #202124;
    border: 1px solid #DADCE0;
    border-radius: 4px;
}

QListWidget::item {
    padding: 4px;
}

QListWidget::item:selected {
    background-color: #E8F0FE;
    color: #1A73E8;
}

QListWidget::item:hover {
    background-color: #F8F9FA;
}

/* Tree Widget */
QTreeWidget {
    background-color: #FFFFFF;
    color: #202124;
    border: 1px solid #DADCE0;
    border-radius: 4px;
}

QTreeWidget::item {
    padding: 4px;
}

QTreeWidget::item:selected {
    background-color: #E8F0FE;
    color: #1A73E8;
}

QTreeWidget::item:hover {
    background-color: #F8F9FA;
}

/* Table Widget */
QTableWidget {
    background-color: #FFFFFF;
    color: #202124;
    border: 1px solid #DADCE0;
    border-radius: 4px;
    gridline-color: #DADCE0;
}

QTableWidget::item {
    padding: 4px;
}

QTableWidget::item:selected {
    background-color: #E8F0FE;
    color: #1A73E8;
}

QHeaderView::section {
    background-color: #F8F9FA;
    color: #5F6368;
    padding: 4px;
    border: 1px solid #DADCE0;
    border-left: none;
    border-top: none;
}

QHeaderView::section:first {
    border-left: 1px solid #DADCE0;
}

/* Calendar Widget */
QCalendarWidget {
    background-color: #FFFFFF;
    color: #202124;
}

QCalendarWidget QToolButton {
    color: #202124;
    background-color: #F8F9FA;
    border: 1px solid #DADCE0;
    border-radius: 4px;
    padding: 4px;
}

QCalendarWidget QMenu {
    background-color: #FFFFFF;
    color: #202124;
    border: 1px solid #DADCE0;
}

QCalendarWidget QSpinBox {
    background-color: #FFFFFF;
    color: #202124;
    border: 1px solid #DADCE0;
    border-radius: 4px;
    padding: 4px;
}

QCalendarWidget QAbstractItemView:enabled {
    background-color: #FFFFFF;
    color: #202124;
    selection-background-color: #E8F0FE;
    selection-color: #1A73E8;
}

QCalendarWidget QAbstractItemView:disabled {
    color: #9AA0A6;
}

/* Tool Box */
QToolBox::tab {
    background-color: #F8F9FA;
    color: #202124;
    border: 1px solid #DADCE0;
    border-radius: 4px;
    padding: 4px;
}

QToolBox::tab:selected {
    background-color: #E8F0FE;
    color: #1A73E8;
}

/* Dock Widget */
QDockWidget {
    titlebar-close-icon: url(:/icons/close.png);
    titlebar-normal-icon: url(:/icons/undock.png);
}

QDockWidget::title {
    text-align: left;
    background-color: #F8F9FA;
    color: #202124;
    padding: 4px;
    border: 1px solid #DADCE0;
}

/* MDI Area */
QMdiArea {
    background-color: #F8F9FA;
}

QMdiSubWindow {
    background-color: #FFFFFF;
    border: 1px solid #DADCE0;
}

QMdiSubWindow::title {
    background-color: #F8F9FA;
    color: #202124;
}

/* Splitter */
QSplitter::handle {
    background-color: #DADCE0;
}

QSplitter::handle:horizontal {
    width: 1px;
}

QSplitter::handle:vertical {
    height: 1px;
}

QSplitter::handle:hover {
    background-color: #4285F4;
}

/* ToolTip */
QToolTip {
    background-color: #FFFFFF;
    color: #202124;
    border: 1px solid #DADCE0;
    border-radius: 4px;
    padding: 4px;
}

/* WebView */
QWebEngineView {
    background-color: #FFFFFF;
}
"""

    def _get_dark_stylesheet(self):
        """Get the dark stylesheet."""
        return """
/* Dark Theme for NebulaFusion Browser */

/* Main Window */
QMainWindow {
    background-color: #121212;
    color: #E1E1E1;
}

/* Menu Bar */
QMenuBar {
    background-color: #1E1E1E;
    color: #E1E1E1;
}

QMenuBar::item {
    background-color: transparent;
    padding: 4px 10px;
}

QMenuBar::item:selected {
    background-color: #3700B3;
    color: #E1E1E1;
}

QMenuBar::item:pressed {
    background-color: #6200EE;
    color: #E1E1E1;
}

/* Menu */
QMenu {
    background-color: #1E1E1E;
    color: #E1E1E1;
    border: 1px solid #333333;
}

QMenu::item {
    padding: 6px 25px 6px 20px;
}

QMenu::item:selected {
    background-color: #3700B3;
    color: #E1E1E1;
}

QMenu::separator {
    height: 1px;
    background-color: #333333;
    margin: 4px 0px;
}

/* Toolbar */
QToolBar {
    background-color: #1E1E1E;
    border-bottom: 1px solid #333333;
    spacing: 2px;
    padding: 2px;
}

QToolBar::separator {
    width: 1px;
    background-color: #333333;
    margin: 0px 4px;
}

QToolButton {
    background-color: transparent;
    border: 1px solid transparent;
    border-radius: 4px;
    padding: 4px;
    color: #E1E1E1; /* Ensure readability against dark backgrounds */
}

QToolButton:hover {
    background-color: #3700B3;
    border: 1px solid #6200EE;
}

QToolButton:pressed {
    background-color: #6200EE;
}

QToolButton:checked {
    background-color: #6200EE;
    border: 1px solid #BB86FC;
}

/* Tab Widget */
QTabWidget::pane {
    border: 1px solid #333333;
    background-color: #121212;
}

QTabBar::tab {
    background-color: #1E1E1E;
    color: #9E9E9E;
    border: 1px solid #333333;
    border-bottom: none;
    border-top-left-radius: 4px;
    border-top-right-radius: 4px;
    padding: 6px 10px;
    margin-right: 2px;
}

QTabBar::tab:selected {
    background-color: #121212;
    color: #E1E1E1;
    border-bottom: none;
}

QTabBar::tab:hover:!selected {
    background-color: #3700B3;
}

QTabBar::close-button {
    image: url(:/icons/close_dark.png);
    subcontrol-position: right;
}

QTabBar::close-button:hover {
    background-color: #3700B3;
    border-radius: 2px;
}

/* Line Edit (Address Bar) */
QLineEdit {
    background-color: #1E1E1E;
    color: #E1E1E1;
    border: 1px solid #333333;
    border-radius: 4px;
    padding: 6px;
    selection-background-color: #6200EE;
}

QLineEdit:focus {
    border: 1px solid #BB86FC;
}

/* Push Button */
QPushButton {
    background-color: #BB86FC;
    color: #121212;
    border: none;
    border-radius: 4px;
    padding: 6px 16px;
    min-width: 80px;
}

QPushButton:hover {
    background-color: #DDB8FF;
}

QPushButton:pressed {
    background-color: #9965D4;
}

QPushButton:disabled {
    background-color: #333333;
    color: #757575;
}

/* Combo Box */
QComboBox {
    background-color: #1E1E1E;
    color: #E1E1E1;
    border: 1px solid #333333;
    border-radius: 4px;
    padding: 6px;
    min-width: 6em;
}

QComboBox:hover {
    border: 1px solid #BB86FC;
}

QComboBox:on {
    border: 1px solid #BB86FC;
}

QComboBox::drop-down {
    subcontrol-origin: padding;
    subcontrol-position: top right;
    width: 20px;
    border-left: 1px solid #333333;
}

QComboBox::down-arrow {
    image: url(:/icons/dropdown_dark.png);
}

QComboBox QAbstractItemView {
    background-color: #1E1E1E;
    color: #E1E1E1;
    border: 1px solid #333333;
    selection-background-color: #3700B3;
    selection-color: #E1E1E1;
}

/* Check Box */
QCheckBox {
    color: #E1E1E1;
    spacing: 5px;
}

QCheckBox::indicator {
    width: 18px;
    height: 18px;
}

QCheckBox::indicator:unchecked {
    image: url(:/icons/checkbox_unchecked_dark.png);
}

QCheckBox::indicator:checked {
    image: url(:/icons/checkbox_checked_dark.png);
}

/* Radio Button */
QRadioButton {
    color: #E1E1E1;
    spacing: 5px;
}

QRadioButton::indicator {
    width: 18px;
    height: 18px;
}

QRadioButton::indicator:unchecked {
    image: url(:/icons/radio_unchecked_dark.png);
}

QRadioButton::indicator:checked {
    image: url(:/icons/radio_checked_dark.png);
}

/* Slider */
QSlider::groove:horizontal {
    border: none;
    height: 4px;
    background-color: #333333;
    border-radius: 2px;
}

QSlider::handle:horizontal {
    background-color: #BB86FC;
    border: none;
    width: 16px;
    height: 16px;
    margin: -6px 0;
    border-radius: 8px;
}

QSlider::handle:horizontal:hover {
    background-color: #DDB8FF;
}

/* Progress Bar */
QProgressBar {
    border: 1px solid #333333;
    border-radius: 4px;
    background-color: #1E1E1E;
    text-align: center;
    color: #E1E1E1;
}

QProgressBar::chunk {
    background-color: #BB86FC;
    width: 1px;
}

/* Scroll Bar */
QScrollBar:vertical {
    border: none;
    background-color: #1E1E1E;
    width: 10px;
    margin: 0px;
}

QScrollBar::handle:vertical {
    background-color: #333333;
    min-height: 20px;
    border-radius: 5px;
}

QScrollBar::handle:vertical:hover {
    background-color: #444444;
}

QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {
    height: 0px;
}

QScrollBar:horizontal {
    border: none;
    background-color: #1E1E1E;
    height: 10px;
    margin: 0px;
}

QScrollBar::handle:horizontal {
    background-color: #333333;
    min-width: 20px;
    border-radius: 5px;
}

QScrollBar::handle:horizontal:hover {
    background-color: #444444;
}

QScrollBar::add-line:horizontal, QScrollBar::sub-line:horizontal {
    width: 0px;
}

/* Status Bar */
QStatusBar {
    background-color: #1E1E1E;
    color: #9E9E9E;
    border-top: 1px solid #333333;
}

QStatusBar::item {
    border: none;
}

/* Dialog */
QDialog {
    background-color: #121212;
    color: #E1E1E1;
}

QDialog QLabel {
    color: #E1E1E1;
}

/* Group Box */
QGroupBox {
    border: 1px solid #333333;
    border-radius: 4px;
    margin-top: 1ex;
    padding-top: 10px;
    color: #E1E1E1;
}

QGroupBox::title {
    subcontrol-origin: margin;
    subcontrol-position: top left;
    padding: 0 3px;
    color: #9E9E9E;
}

/* Spin Box */
QSpinBox, QDoubleSpinBox {
    background-color: #1E1E1E;
    color: #E1E1E1;
    border: 1px solid #333333;
    border-radius: 4px;
    padding: 6px;
}

QSpinBox:hover, QDoubleSpinBox:hover {
    border: 1px solid #BB86FC;
}

QSpinBox::up-button, QDoubleSpinBox::up-button {
    subcontrol-origin: border;
    subcontrol-position: top right;
    width: 16px;
    border-left: 1px solid #333333;
    border-bottom: 1px solid #333333;
}

QSpinBox::down-button, QDoubleSpinBox::down-button {
    subcontrol-origin: border;
    subcontrol-position: bottom right;
    width: 16px;
    border-left: 1px solid #333333;
    border-top: 1px solid #333333;
}

/* Text Edit */
QTextEdit {
    background-color: #1E1E1E;
    color: #E1E1E1;
    border: 1px solid #333333;
    border-radius: 4px;
    selection-background-color: #6200EE;
}

QTextEdit:focus {
    border: 1px solid #BB86FC;
}

/* List Widget */
QListWidget {
    background-color: #1E1E1E;
    color: #E1E1E1;
    border: 1px solid #333333;
    border-radius: 4px;
}

QListWidget::item {
    padding: 4px;
}

QListWidget::item:selected {
    background-color: #3700B3;
    color: #E1E1E1;
}

QListWidget::item:hover {
    background-color: #2A2A2A;
}

/* Tree Widget */
QTreeWidget {
    background-color: #1E1E1E;
    color: #E1E1E1;
    border: 1px solid #333333;
    border-radius: 4px;
}

QTreeWidget::item {
    padding: 4px;
}

QTreeWidget::item:selected {
    background-color: #3700B3;
    color: #E1E1E1;
}

QTreeWidget::item:hover {
    background-color: #2A2A2A;
}

/* Table Widget */
QTableWidget {
    background-color: #1E1E1E;
    color: #E1E1E1;
    border: 1px solid #333333;
    border-radius: 4px;
    gridline-color: #333333;
}

QTableWidget::item {
    padding: 4px;
}

QTableWidget::item:selected {
    background-color: #3700B3;
    color: #E1E1E1;
}

QHeaderView::section {
    background-color: #1E1E1E;
    color: #9E9E9E;
    padding: 4px;
    border: 1px solid #333333;
    border-left: none;
    border-top: none;
}

QHeaderView::section:first {
    border-left: 1px solid #333333;
}

/* Calendar Widget */
QCalendarWidget {
    background-color: #121212;
    color: #E1E1E1;
}

QCalendarWidget QToolButton {
    color: #E1E1E1;
    background-color: #1E1E1E;
    border: 1px solid #333333;
    border-radius: 4px;
    padding: 4px;
}

QCalendarWidget QMenu {
    background-color: #1E1E1E;
    color: #E1E1E1;
    border: 1px solid #333333;
}

QCalendarWidget QSpinBox {
    background-color: #1E1E1E;
    color: #E1E1E1;
    border: 1px solid #333333;
    border-radius: 4px;
    padding: 4px;
}

QCalendarWidget QAbstractItemView:enabled {
    background-color: #1E1E1E;
    color: #E1E1E1;
    selection-background-color: #3700B3;
    selection-color: #E1E1E1;
}

QCalendarWidget QAbstractItemView:disabled {
    color: #757575;
}

/* Tool Box */
QToolBox::tab {
    background-color: #1E1E1E;
    color: #E1E1E1;
    border: 1px solid #333333;
    border-radius: 4px;
    padding: 4px;
}

QToolBox::tab:selected {
    background-color: #3700B3;
    color: #E1E1E1;
}

/* Dock Widget */
QDockWidget {
    titlebar-close-icon: url(:/icons/close_dark.png);
    titlebar-normal-icon: url(:/icons/undock_dark.png);
}

QDockWidget::title {
    text-align: left;
    background-color: #1E1E1E;
    color: #E1E1E1;
    padding: 4px;
    border: 1px solid #333333;
}

/* MDI Area */
QMdiArea {
    background-color: #1E1E1E;
}

QMdiSubWindow {
    background-color: #121212;
    border: 1px solid #333333;
}

QMdiSubWindow::title {
    background-color: #1E1E1E;
    color: #E1E1E1;
}

/* Splitter */
QSplitter::handle {
    background-color: #333333;
}

QSplitter::handle:horizontal {
    width: 1px;
}

QSplitter::handle:vertical {
    height: 1px;
}

QSplitter::handle:hover {
    background-color: #BB86FC;
}

/* ToolTip */
QToolTip {
    background-color: #1E1E1E;
    color: #E1E1E1;
    border: 1px solid #333333;
    border-radius: 4px;
    padding: 4px;
}

/* WebView */
QWebEngineView {
    background-color: #121212;
}
"""

    def _get_light_stylesheet(self):
        """Get the light stylesheet."""
        return """
/* Light Theme for NebulaFusion Browser */

/* Main Window */
QMainWindow {
    background-color: #FFFFFF;
    color: #000000;
}

/* Menu Bar */
QMenuBar {
    background-color: #F5F5F5;
    color: #000000;
    border: none;
}

QMenuBar::item {
    background-color: transparent;
    color: #000000 !important;
    padding: 4px 10px;
    margin: 2px 2px;
    border-radius: 3px;
}

QMenuBar::item:enabled {
    color: #000000 !important;
}

QMenuBar::item:disabled {
    color: #808080 !important;
}

QMenuBar::item:selected {
    background-color: #E0E0E0;
    color: #000000;
}

QMenuBar::item:pressed {
    background-color: #D0D0D0;
    color: #000000;
}

/* Menu */
QMenu {
    background-color: #FFFFFF;
    color: #000000;
    border: 1px solid #E0E0E0;
}

QMenu::item {
    padding: 6px 25px 6px 20px;
}

QMenu::item:selected {
    background-color: #E0E0E0;
    color: #6200EE;
}

QMenu::separator {
    height: 1px;
    background-color: #E0E0E0;
    margin: 4px 0px;
}

/* Toolbar */
QToolBar {
    background-color: #F5F5F5;
    border-bottom: 1px solid #E0E0E0;
    spacing: 2px;
    padding: 2px;
}

QToolBar::separator {
    width: 1px;
    background-color: #E0E0E0;
    margin: 0px 4px;
}

QToolButton {
    background-color: transparent;
    border: 1px solid transparent;
    border-radius: 4px;
    padding: 4px;
    color: #000000; /* Ensure readability against light backgrounds */
}

QToolButton:hover {
    background-color: #E0E0E0;
    border: 1px solid #D0D0D0;
}

QToolButton:pressed {
    background-color: #D0D0D0;
}

QToolButton:checked {
    background-color: #D0D0D0;
    border: 1px solid #6200EE;
}

/* Tab Widget */
QTabWidget::pane {
    border: 1px solid #E0E0E0;
    background-color: #FFFFFF;
}

QTabBar::tab {
    background-color: #F5F5F5;
    color: #757575;
    border: 1px solid #E0E0E0;
    border-bottom: none;
    border-top-left-radius: 4px;
    border-top-right-radius: 4px;
    padding: 6px 10px;
    margin-right: 2px;
}

QTabBar::tab:selected {
    background-color: #FFFFFF;
    color: #000000;
    border-bottom: none;
}

QTabBar::tab:hover:!selected {
    background-color: #E0E0E0;
}

QTabBar::close-button {
    image: url(:/icons/close.png);
    subcontrol-position: right;
}

QTabBar::close-button:hover {
    background-color: #E0E0E0;
    border-radius: 2px;
}

/* Line Edit (Address Bar) */
QLineEdit {
    background-color: #FFFFFF;
    color: #000000;
    border: 1px solid #E0E0E0;
    border-radius: 4px;
    padding: 6px;
    selection-background-color: #D0D0D0;
}

QLineEdit:focus {
    border: 1px solid #6200EE;
}

/* Push Button */
QPushButton {
    background-color: #6200EE;
    color: #FFFFFF;
    border: none;
    border-radius: 4px;
    padding: 6px 16px;
    min-width: 80px;
}

QPushButton:hover {
    background-color: #7722FF;
}

QPushButton:pressed {
    background-color: #5000CC;
}

QPushButton:disabled {
    background-color: #E0E0E0;
    color: #9E9E9E;
}

/* Combo Box */
QComboBox {
    background-color: #FFFFFF;
    color: #000000;
    border: 1px solid #E0E0E0;
    border-radius: 4px;
    padding: 6px;
    min-width: 6em;
}

QComboBox:hover {
    border: 1px solid #6200EE;
}

QComboBox:on {
    border: 1px solid #6200EE;
}

QComboBox::drop-down {
    subcontrol-origin: padding;
    subcontrol-position: top right;
    width: 20px;
    border-left: 1px solid #E0E0E0;
}

QComboBox::down-arrow {
    image: url(:/icons/dropdown.png);
}

QComboBox QAbstractItemView {
    background-color: #FFFFFF;
    color: #000000;
    border: 1px solid #E0E0E0;
    selection-background-color: #E0E0E0;
    selection-color: #6200EE;
}

/* Check Box */
QCheckBox {
    color: #000000;
    spacing: 5px;
}

QCheckBox::indicator {
    width: 18px;
    height: 18px;
}

QCheckBox::indicator:unchecked {
    image: url(:/icons/checkbox_unchecked.png);
}

QCheckBox::indicator:checked {
    image: url(:/icons/checkbox_checked.png);
}

/* Radio Button */
QRadioButton {
    color: #000000;
    spacing: 5px;
}

QRadioButton::indicator {
    width: 18px;
    height: 18px;
}

QRadioButton::indicator:unchecked {
    image: url(:/icons/radio_unchecked.png);
}

QRadioButton::indicator:checked {
    image: url(:/icons/radio_checked.png);
}

/* Slider */
QSlider::groove:horizontal {
    border: none;
    height: 4px;
    background-color: #E0E0E0;
    border-radius: 2px;
}

QSlider::handle:horizontal {
    background-color: #6200EE;
    border: none;
    width: 16px;
    height: 16px;
    margin: -6px 0;
    border-radius: 8px;
}

QSlider::handle:horizontal:hover {
    background-color: #7722FF;
}

/* Progress Bar */
QProgressBar {
    border: 1px solid #E0E0E0;
    border-radius: 4px;
    background-color: #F5F5F5;
    text-align: center;
    color: #000000;
}

QProgressBar::chunk {
    background-color: #6200EE;
    width: 1px;
}

/* Scroll Bar */
QScrollBar:vertical {
    border: none;
    background-color: #F5F5F5;
    width: 10px;
    margin: 0px;
}

QScrollBar::handle:vertical {
    background-color: #E0E0E0;
    min-height: 20px;
    border-radius: 5px;
}

QScrollBar::handle:vertical:hover {
    background-color: #D0D0D0;
}

QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {
    height: 0px;
}

QScrollBar:horizontal {
    border: none;
    background-color: #F5F5F5;
    height: 10px;
    margin: 0px;
}

QScrollBar::handle:horizontal {
    background-color: #E0E0E0;
    min-width: 20px;
    border-radius: 5px;
}

QScrollBar::handle:horizontal:hover {
    background-color: #D0D0D0;
}

QScrollBar::add-line:horizontal, QScrollBar::sub-line:horizontal {
    width: 0px;
}

/* Status Bar */
QStatusBar {
    background-color: #F5F5F5;
    color: #757575;
    border-top: 1px solid #E0E0E0;
}

QStatusBar::item {
    border: none;
}

/* Dialog */
QDialog {
    background-color: #FFFFFF;
    color: #000000;
}

QDialog QLabel {
    color: #000000;
}

/* Group Box */
QGroupBox {
    border: 1px solid #E0E0E0;
    border-radius: 4px;
    margin-top: 1ex;
    padding-top: 10px;
    color: #000000;
}

QGroupBox::title {
    subcontrol-origin: margin;
    subcontrol-position: top left;
    padding: 0 3px;
    color: #757575;
}

/* Spin Box */
QSpinBox, QDoubleSpinBox {
    background-color: #FFFFFF;
    color: #000000;
    border: 1px solid #E0E0E0;
    border-radius: 4px;
    padding: 6px;
}

QSpinBox:hover, QDoubleSpinBox:hover {
    border: 1px solid #6200EE;
}

QSpinBox::up-button, QDoubleSpinBox::up-button {
    subcontrol-origin: border;
    subcontrol-position: top right;
    width: 16px;
    border-left: 1px solid #E0E0E0;
    border-bottom: 1px solid #E0E0E0;
}

QSpinBox::down-button, QDoubleSpinBox::down-button {
    subcontrol-origin: border;
    subcontrol-position: bottom right;
    width: 16px;
    border-left: 1px solid #E0E0E0;
    border-top: 1px solid #E0E0E0;
}

/* Text Edit */
QTextEdit {
    background-color: #FFFFFF;
    color: #000000;
    border: 1px solid #E0E0E0;
    border-radius: 4px;
    selection-background-color: #D0D0D0;
}

QTextEdit:focus {
    border: 1px solid #6200EE;
}

/* List Widget */
QListWidget {
    background-color: #FFFFFF;
    color: #000000;
    border: 1px solid #E0E0E0;
    border-radius: 4px;
}

QListWidget::item {
    padding: 4px;
}

QListWidget::item:selected {
    background-color: #E0E0E0;
    color: #6200EE;
}

QListWidget::item:hover {
    background-color: #F5F5F5;
}

/* Tree Widget */
QTreeWidget {
    background-color: #FFFFFF;
    color: #000000;
    border: 1px solid #E0E0E0;
    border-radius: 4px;
}

QTreeWidget::item {
    padding: 4px;
}

QTreeWidget::item:selected {
    background-color: #E0E0E0;
    color: #6200EE;
}

QTreeWidget::item:hover {
    background-color: #F5F5F5;
}

/* Table Widget */
QTableWidget {
    background-color: #FFFFFF;
    color: #000000;
    border: 1px solid #E0E0E0;
    border-radius: 4px;
    gridline-color: #E0E0E0;
}

QTableWidget::item {
    padding: 4px;
}

QTableWidget::item:selected {
    background-color: #E0E0E0;
    color: #6200EE;
}

QHeaderView::section {
    background-color: #F5F5F5;
    color: #757575;
    padding: 4px;
    border: 1px solid #E0E0E0;
    border-left: none;
    border-top: none;
}

QHeaderView::section:first {
    border-left: 1px solid #E0E0E0;
}

/* Calendar Widget */
QCalendarWidget {
    background-color: #FFFFFF;
    color: #000000;
}

QCalendarWidget QToolButton {
    color: #000000;
    background-color: #F5F5F5;
    border: 1px solid #E0E0E0;
    border-radius: 4px;
    padding: 4px;
}

QCalendarWidget QMenu {
    background-color: #FFFFFF;
    color: #000000;
    border: 1px solid #E0E0E0;
}

QCalendarWidget QSpinBox {
    background-color: #FFFFFF;
    color: #000000;
    border: 1px solid #E0E0E0;
    border-radius: 4px;
    padding: 4px;
}

QCalendarWidget QAbstractItemView:enabled {
    background-color: #FFFFFF;
    color: #000000;
    selection-background-color: #E0E0E0;
    selection-color: #6200EE;
}

QCalendarWidget QAbstractItemView:disabled {
    color: #9E9E9E;
}

/* Tool Box */
QToolBox::tab {
    background-color: #F5F5F5;
    color: #000000;
    border: 1px solid #E0E0E0;
    border-radius: 4px;
    padding: 4px;
}

QToolBox::tab:selected {
    background-color: #E0E0E0;
    color: #6200EE;
}

/* Dock Widget */
QDockWidget {
    titlebar-close-icon: url(:/icons/close.png);
    titlebar-normal-icon: url(:/icons/undock.png);
}

QDockWidget::title {
    text-align: left;
    background-color: #F5F5F5;
    color: #000000;
    padding: 4px;
    border: 1px solid #E0E0E0;
}

/* MDI Area */
QMdiArea {
    background-color: #F5F5F5;
}

QMdiSubWindow {
    background-color: #FFFFFF;
    border: 1px solid #E0E0E0;
}

QMdiSubWindow::title {
    background-color: #F5F5F5;
    color: #000000;
}

/* Splitter */
QSplitter::handle {
    background-color: #E0E0E0;
}

QSplitter::handle:horizontal {
    width: 1px;
}

QSplitter::handle:vertical {
    height: 1px;
}

QSplitter::handle:hover {
    background-color: #6200EE;
}

/* ToolTip */
QToolTip {
    background-color: #FFFFFF;
    color: #000000;
    border: 1px solid #E0E0E0;
    border-radius: 4px;
    padding: 4px;
}

/* WebView */
QWebEngineView {
    background-color: #FFFFFF;
}
"""

    def _get_neon_stylesheet(self):
        """Get the neon stylesheet."""
        return """
/* Neon Theme for NebulaFusion Browser */

/* Main Window */
QMainWindow {
    background-color: #000000;
    color: #FFFFFF;
}

/* Menu Bar */
QMenuBar {
    background-color: #1A1A1A;
    color: #FFFFFF;
}

QMenuBar::item {
    background-color: transparent;
    padding: 4px 10px;
}

QMenuBar::item:selected {
    background-color: #FF00FF;
    color: #000000;
}

QMenuBar::item:pressed {
    background-color: #CC00CC;
    color: #000000;
}

/* Menu */
QMenu {
    background-color: #1A1A1A;
    color: #FFFFFF;
    border: 1px solid #333333;
}

QMenu::item {
    padding: 6px 25px 6px 20px;
}

QMenu::item:selected {
    background-color: #FF00FF;
    color: #000000;
}

QMenu::separator {
    height: 1px;
    background-color: #333333;
    margin: 4px 0px;
}

/* Toolbar */
QToolBar {
    background-color: #1A1A1A;
    border-bottom: 1px solid #333333;
    spacing: 2px;
    padding: 2px;
}

QToolBar::separator {
    width: 1px;
    background-color: #333333;
    margin: 0px 4px;
}

QToolButton {
    background-color: transparent;
    border: 1px solid transparent;
    border-radius: 4px;
    padding: 4px;
    color: #FFFFFF; /* Ensure readability against dark backgrounds */
}

QToolButton:hover {
    background-color: #FF00FF;
    border: 1px solid #CC00CC;
    color: #000000;
}

QToolButton:pressed {
    background-color: #CC00CC;
    color: #000000;
}

QToolButton:checked {
    background-color: #CC00CC;
    border: 1px solid #FF00FF;
    color: #000000;
}

/* Tab Widget */
QTabWidget::pane {
    border: 1px solid #333333;
    background-color: #000000;
}

QTabBar::tab {
    background-color: #1A1A1A;
    color: #CCCCCC;
    border: 1px solid #333333;
    border-bottom: none;
    border-top-left-radius: 4px;
    border-top-right-radius: 4px;
    padding: 6px 10px;
    margin-right: 2px;
}

QTabBar::tab:selected {
    background-color: #000000;
    color: #FF00FF;
    border-bottom: none;
}

QTabBar::tab:hover:!selected {
    background-color: #333333;
    color: #00FFFF;
}

QTabBar::close-button {
    image: url(:/icons/close_neon.png);
    subcontrol-position: right;
}

QTabBar::close-button:hover {
    background-color: #FF00FF;
    border-radius: 2px;
}

/* Line Edit (Address Bar) */
QLineEdit {
    background-color: #1A1A1A;
    color: #FFFFFF;
    border: 1px solid #333333;
    border-radius: 4px;
    padding: 6px;
    selection-background-color: #FF00FF;
}

QLineEdit:focus {
    border: 1px solid #FF00FF;
}

/* Push Button */
QPushButton {
    background-color: #FF00FF;
    color: #000000;
    border: none;
    border-radius: 4px;
    padding: 6px 16px;
    min-width: 80px;
}

QPushButton:hover {
    background-color: #FF33FF;
}

QPushButton:pressed {
    background-color: #CC00CC;
}

QPushButton:disabled {
    background-color: #333333;
    color: #666666;
}

/* Combo Box */
QComboBox {
    background-color: #1A1A1A;
    color: #FFFFFF;
    border: 1px solid #333333;
    border-radius: 4px;
    padding: 6px;
    min-width: 6em;
}

QComboBox:hover {
    border: 1px solid #FF00FF;
}

QComboBox:on {
    border: 1px solid #FF00FF;
}

QComboBox::drop-down {
    subcontrol-origin: padding;
    subcontrol-position: top right;
    width: 20px;
    border-left: 1px solid #333333;
}

QComboBox::down-arrow {
    image: url(:/icons/dropdown_neon.png);
}

QComboBox QAbstractItemView {
    background-color: #1A1A1A;
    color: #FFFFFF;
    border: 1px solid #333333;
    selection-background-color: #FF00FF;
    selection-color: #000000;
}

/* Check Box */
QCheckBox {
    color: #FFFFFF;
    spacing: 5px;
}

QCheckBox::indicator {
    width: 18px;
    height: 18px;
}

QCheckBox::indicator:unchecked {
    image: url(:/icons/checkbox_unchecked_neon.png);
}

QCheckBox::indicator:checked {
    image: url(:/icons/checkbox_checked_neon.png);
}

/* Radio Button */
QRadioButton {
    color: #FFFFFF;
    spacing: 5px;
}

QRadioButton::indicator {
    width: 18px;
    height: 18px;
}

QRadioButton::indicator:unchecked {
    image: url(:/icons/radio_unchecked_neon.png);
}

QRadioButton::indicator:checked {
    image: url(:/icons/radio_checked_neon.png);
}

/* Slider */
QSlider::groove:horizontal {
    border: none;
    height: 4px;
    background-color: #333333;
    border-radius: 2px;
}

QSlider::handle:horizontal {
    background-color: #FF00FF;
    border: none;
    width: 16px;
    height: 16px;
    margin: -6px 0;
    border-radius: 8px;
}

QSlider::handle:horizontal:hover {
    background-color: #FF33FF;
}

/* Progress Bar */
QProgressBar {
    border: 1px solid #333333;
    border-radius: 4px;
    background-color: #1A1A1A;
    text-align: center;
    color: #FFFFFF;
}

QProgressBar::chunk {
    background-color: #FF00FF;
    width: 1px;
}

/* Scroll Bar */
QScrollBar:vertical {
    border: none;
    background-color: #1A1A1A;
    width: 10px;
    margin: 0px;
}

QScrollBar::handle:vertical {
    background-color: #333333;
    min-height: 20px;
    border-radius: 5px;
}

QScrollBar::handle:vertical:hover {
    background-color: #FF00FF;
}

QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {
    height: 0px;
}

QScrollBar:horizontal {
    border: none;
    background-color: #1A1A1A;
    height: 10px;
    margin: 0px;
}

QScrollBar::handle:horizontal {
    background-color: #333333;
    min-width: 20px;
    border-radius: 5px;
}

QScrollBar::handle:horizontal:hover {
    background-color: #FF00FF;
}

QScrollBar::add-line:horizontal, QScrollBar::sub-line:horizontal {
    width: 0px;
}

/* Status Bar */
QStatusBar {
    background-color: #1A1A1A;
    color: #CCCCCC;
    border-top: 1px solid #333333;
}

QStatusBar::item {
    border: none;
}

/* Dialog */
QDialog {
    background-color: #000000;
    color: #FFFFFF;
}

QDialog QLabel {
    color: #FFFFFF;
}

/* Group Box */
QGroupBox {
    border: 1px solid #333333;
    border-radius: 4px;
    margin-top: 1ex;
    padding-top: 10px;
    color: #FFFFFF;
}

QGroupBox::title {
    subcontrol-origin: margin;
    subcontrol-position: top left;
    padding: 0 3px;
    color: #CCCCCC;
}

/* Spin Box */
QSpinBox, QDoubleSpinBox {
    background-color: #1A1A1A;
    color: #FFFFFF;
    border: 1px solid #333333;
    border-radius: 4px;
    padding: 6px;
}

QSpinBox:hover, QDoubleSpinBox:hover {
    border: 1px solid #FF00FF;
}

QSpinBox::up-button, QDoubleSpinBox::up-button {
    subcontrol-origin: border;
    subcontrol-position: top right;
    width: 16px;
    border-left: 1px solid #333333;
    border-bottom: 1px solid #333333;
}

QSpinBox::down-button, QDoubleSpinBox::down-button {
    subcontrol-origin: border;
    subcontrol-position: bottom right;
    width: 16px;
    border-left: 1px solid #333333;
    border-top: 1px solid #333333;
}

/* Text Edit */
QTextEdit {
    background-color: #1A1A1A;
    color: #FFFFFF;
    border: 1px solid #333333;
    border-radius: 4px;
    selection-background-color: #FF00FF;
}

QTextEdit:focus {
    border: 1px solid #FF00FF;
}

/* List Widget */
QListWidget {
    background-color: #1A1A1A;
    color: #FFFFFF;
    border: 1px solid #333333;
    border-radius: 4px;
}

QListWidget::item {
    padding: 4px;
}

QListWidget::item:selected {
    background-color: #FF00FF;
    color: #000000;
}

QListWidget::item:hover {
    background-color: #333333;
}

/* Tree Widget */
QTreeWidget {
    background-color: #1A1A1A;
    color: #FFFFFF;
    border: 1px solid #333333;
    border-radius: 4px;
}

QTreeWidget::item {
    padding: 4px;
}

QTreeWidget::item:selected {
    background-color: #FF00FF;
    color: #000000;
}

QTreeWidget::item:hover {
    background-color: #333333;
}

/* Table Widget */
QTableWidget {
    background-color: #1A1A1A;
    color: #FFFFFF;
    border: 1px solid #333333;
    border-radius: 4px;
    gridline-color: #333333;
}

QTableWidget::item {
    padding: 4px;
}

QTableWidget::item:selected {
    background-color: #FF00FF;
    color: #000000;
}

QHeaderView::section {
    background-color: #1A1A1A;
    color: #CCCCCC;
    padding: 4px;
    border: 1px solid #333333;
    border-left: none;
    border-top: none;
}

QHeaderView::section:first {
    border-left: 1px solid #333333;
}

/* Calendar Widget */
QCalendarWidget {
    background-color: #000000;
    color: #FFFFFF;
}

QCalendarWidget QToolButton {
    color: #FFFFFF;
    background-color: #1A1A1A;
    border: 1px solid #333333;
    border-radius: 4px;
    padding: 4px;
}

QCalendarWidget QMenu {
    background-color: #1A1A1A;
    color: #FFFFFF;
    border: 1px solid #333333;
}

QCalendarWidget QSpinBox {
    background-color: #1A1A1A;
    color: #FFFFFF;
    border: 1px solid #333333;
    border-radius: 4px;
    padding: 4px;
}

QCalendarWidget QAbstractItemView:enabled {
    background-color: #1A1A1A;
    color: #FFFFFF;
    selection-background-color: #FF00FF;
    selection-color: #000000;
}

QCalendarWidget QAbstractItemView:disabled {
    color: #666666;
}

/* Tool Box */
QToolBox::tab {
    background-color: #1A1A1A;
    color: #FFFFFF;
    border: 1px solid #333333;
    border-radius: 4px;
    padding: 4px;
}

QToolBox::tab:selected {
    background-color: #FF00FF;
    color: #000000;
}

/* Dock Widget */
QDockWidget {
    titlebar-close-icon: url(:/icons/close_neon.png);
    titlebar-normal-icon: url(:/icons/undock_neon.png);
}

QDockWidget::title {
    text-align: left;
    background-color: #1A1A1A;
    color: #FFFFFF;
    padding: 4px;
    border: 1px solid #333333;
}

/* MDI Area */
QMdiArea {
    background-color: #1A1A1A;
}

QMdiSubWindow {
    background-color: #000000;
    border: 1px solid #333333;
}

QMdiSubWindow::title {
    background-color: #1A1A1A;
    color: #FFFFFF;
}

/* Splitter */
QSplitter::handle {
    background-color: #333333;
}

QSplitter::handle:horizontal {
    width: 1px;
}

QSplitter::handle:vertical {
    height: 1px;
}

QSplitter::handle:hover {
    background-color: #FF00FF;
}

/* ToolTip */
QToolTip {
    background-color: #1A1A1A;
    color: #FFFFFF;
    border: 1px solid #333333;
    border-radius: 4px;
    padding: 4px;
}

/* WebView */
QWebEngineView {
    background-color: #000000;
}
"""

    def _get_minimal_stylesheet(self):
        """Get the minimal stylesheet."""
        return """
/* Minimal Theme for NebulaFusion Browser */

/* Main Window */
QMainWindow {
    background-color: #FFFFFF;
    color: #000000;
}

/* Menu Bar */
QMenuBar {
    background-color: #FFFFFF;
    color: #000000;
    border-bottom: 1px solid #CCCCCC;
}

QMenuBar::item {
    background-color: transparent;
    padding: 4px 10px;
}

QMenuBar::item:selected {
    background-color: #EEEEEE;
}

QMenuBar::item:pressed {
    background-color: #DDDDDD;
}

/* Menu */
QMenu {
    background-color: #FFFFFF;
    color: #000000;
    border: 1px solid #CCCCCC;
}

QMenu::item {
    padding: 6px 25px 6px 20px;
}

QMenu::item:selected {
    background-color: #EEEEEE;
}

QMenu::separator {
    height: 1px;
    background-color: #CCCCCC;
    margin: 4px 0px;
}

/* Toolbar */
QToolBar {
    background-color: #FFFFFF;
    border-bottom: 1px solid #CCCCCC;
    spacing: 2px;
    padding: 2px;
}

QToolBar::separator {
    width: 1px;
    background-color: #CCCCCC;
    margin: 0px 4px;
}

QToolButton {
    background-color: transparent;
    border: 1px solid transparent;
    border-radius: 2px;
    padding: 4px;
}

QToolButton:hover {
    background-color: #EEEEEE;
}

QToolButton:pressed {
    background-color: #DDDDDD;
}

QToolButton:checked {
    background-color: #DDDDDD;
    border: 1px solid #CCCCCC;
}

/* Tab Widget */
QTabWidget::pane {
    border: 1px solid #CCCCCC;
    background-color: #FFFFFF;
}

QTabBar::tab {
    background-color: #FFFFFF;
    color: #666666;
    border: 1px solid #CCCCCC;
    border-bottom: none;
    padding: 6px 10px;
    margin-right: 2px;
}

QTabBar::tab:selected {
    background-color: #FFFFFF;
    color: #000000;
    border-bottom: none;
}

QTabBar::tab:hover:!selected {
    background-color: #EEEEEE;
}

QTabBar::close-button {
    image: url(:/icons/close_minimal.png);
    subcontrol-position: right;
}

QTabBar::close-button:hover {
    background-color: #EEEEEE;
    border-radius: 2px;
}

/* Line Edit (Address Bar) */
QLineEdit {
    background-color: #FFFFFF;
    color: #000000;
    border: 1px solid #CCCCCC;
    border-radius: 2px;
    padding: 6px;
    selection-background-color: #DDDDDD;
}

QLineEdit:focus {
    border: 1px solid #999999;
}

/* Push Button */
QPushButton {
    background-color: #FFFFFF;
    color: #000000;
    border: 1px solid #CCCCCC;
    border-radius: 2px;
    padding: 6px 16px;
    min-width: 80px;
}

QPushButton:hover {
    background-color: #EEEEEE;
}

QPushButton:pressed {
    background-color: #DDDDDD;
}

QPushButton:disabled {
    background-color: #F5F5F5;
    color: #AAAAAA;
    border: 1px solid #DDDDDD;
}

/* Combo Box */
QComboBox {
    background-color: #FFFFFF;
    color: #000000;
    border: 1px solid #CCCCCC;
    border-radius: 2px;
    padding: 6px;
    min-width: 6em;
}

QComboBox:hover {
    border: 1px solid #999999;
}

QComboBox:on {
    border: 1px solid #999999;
}

QComboBox::drop-down {
    subcontrol-origin: padding;
    subcontrol-position: top right;
    width: 20px;
    border-left: 1px solid #CCCCCC;
}

QComboBox::down-arrow {
    image: url(:/icons/dropdown_minimal.png);
}

QComboBox QAbstractItemView {
    background-color: #FFFFFF;
    color: #000000;
    border: 1px solid #CCCCCC;
    selection-background-color: #EEEEEE;
}

/* Check Box */
QCheckBox {
    color: #000000;
    spacing: 5px;
}

QCheckBox::indicator {
    width: 18px;
    height: 18px;
}

QCheckBox::indicator:unchecked {
    image: url(:/icons/checkbox_unchecked_minimal.png);
}

QCheckBox::indicator:checked {
    image: url(:/icons/checkbox_checked_minimal.png);
}

/* Radio Button */
QRadioButton {
    color: #000000;
    spacing: 5px;
}

QRadioButton::indicator {
    width: 18px;
    height: 18px;
}

QRadioButton::indicator:unchecked {
    image: url(:/icons/radio_unchecked_minimal.png);
}

QRadioButton::indicator:checked {
    image: url(:/icons/radio_checked_minimal.png);
}

/* Slider */
QSlider::groove:horizontal {
    border: none;
    height: 4px;
    background-color: #CCCCCC;
    border-radius: 2px;
}

QSlider::handle:horizontal {
    background-color: #000000;
    border: none;
    width: 16px;
    height: 16px;
    margin: -6px 0;
    border-radius: 8px;
}

QSlider::handle:horizontal:hover {
    background-color: #333333;
}

/* Progress Bar */
QProgressBar {
    border: 1px solid #CCCCCC;
    border-radius: 2px;
    background-color: #FFFFFF;
    text-align: center;
    color: #000000;
}

QProgressBar::chunk {
    background-color: #000000;
    width: 1px;
}

/* Scroll Bar */
QScrollBar:vertical {
    border: none;
    background-color: #FFFFFF;
    width: 8px;
    margin: 0px;
}

QScrollBar::handle:vertical {
    background-color: #CCCCCC;
    min-height: 20px;
    border-radius: 4px;
}

QScrollBar::handle:vertical:hover {
    background-color: #AAAAAA;
}

QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {
    height: 0px;
}

QScrollBar:horizontal {
    border: none;
    background-color: #FFFFFF;
    height: 8px;
    margin: 0px;
}

QScrollBar::handle:horizontal {
    background-color: #CCCCCC;
    min-width: 20px;
    border-radius: 4px;
}

QScrollBar::handle:horizontal:hover {
    background-color: #AAAAAA;
}

QScrollBar::add-line:horizontal, QScrollBar::sub-line:horizontal {
    width: 0px;
}

/* Status Bar */
QStatusBar {
    background-color: #FFFFFF;
    color: #666666;
    border-top: 1px solid #CCCCCC;
}

QStatusBar::item {
    border: none;
}

/* Dialog */
QDialog {
    background-color: #FFFFFF;
    color: #000000;
}

QDialog QLabel {
    color: #000000;
}

/* Group Box */
QGroupBox {
    border: 1px solid #CCCCCC;
    border-radius: 2px;
    margin-top: 1ex;
    padding-top: 10px;
    color: #000000;
}

QGroupBox::title {
    subcontrol-origin: margin;
    subcontrol-position: top left;
    padding: 0 3px;
    color: #666666;
}

/* Spin Box */
QSpinBox, QDoubleSpinBox {
    background-color: #FFFFFF;
    color: #000000;
    border: 1px solid #CCCCCC;
    border-radius: 2px;
    padding: 6px;
}

QSpinBox:hover, QDoubleSpinBox:hover {
    border: 1px solid #999999;
}

QSpinBox::up-button, QDoubleSpinBox::up-button {
    subcontrol-origin: border;
    subcontrol-position: top right;
    width: 16px;
    border-left: 1px solid #CCCCCC;
    border-bottom: 1px solid #CCCCCC;
}

QSpinBox::down-button, QDoubleSpinBox::down-button {
    subcontrol-origin: border;
    subcontrol-position: bottom right;
    width: 16px;
    border-left: 1px solid #CCCCCC;
    border-top: 1px solid #CCCCCC;
}

/* Text Edit */
QTextEdit {
    background-color: #FFFFFF;
    color: #000000;
    border: 1px solid #CCCCCC;
    border-radius: 2px;
    selection-background-color: #DDDDDD;
}

QTextEdit:focus {
    border: 1px solid #999999;
}

/* List Widget */
QListWidget {
    background-color: #FFFFFF;
    color: #000000;
    border: 1px solid #CCCCCC;
    border-radius: 2px;
}

QListWidget::item {
    padding: 4px;
}

QListWidget::item:selected {
    background-color: #EEEEEE;
    color: #000000;
}

QListWidget::item:hover {
    background-color: #F5F5F5;
}

/* Tree Widget */
QTreeWidget {
    background-color: #FFFFFF;
    color: #000000;
    border: 1px solid #CCCCCC;
    border-radius: 2px;
}

QTreeWidget::item {
    padding: 4px;
}

QTreeWidget::item:selected {
    background-color: #EEEEEE;
    color: #000000;
}

QTreeWidget::item:hover {
    background-color: #F5F5F5;
}

/* Table Widget */
QTableWidget {
    background-color: #FFFFFF;
    color: #000000;
    border: 1px solid #CCCCCC;
    border-radius: 2px;
    gridline-color: #CCCCCC;
}

QTableWidget::item {
    padding: 4px;
}

QTableWidget::item:selected {
    background-color: #EEEEEE;
    color: #000000;
}

QHeaderView::section {
    background-color: #FFFFFF;
    color: #666666;
    padding: 4px;
    border: 1px solid #CCCCCC;
    border-left: none;
    border-top: none;
}

QHeaderView::section:first {
    border-left: 1px solid #CCCCCC;
}

/* Calendar Widget */
QCalendarWidget {
    background-color: #FFFFFF;
    color: #000000;
}

QCalendarWidget QToolButton {
    color: #000000;
    background-color: #FFFFFF;
    border: 1px solid #CCCCCC;
    border-radius: 2px;
    padding: 4px;
}

QCalendarWidget QMenu {
    background-color: #FFFFFF;
    color: #000000;
    border: 1px solid #CCCCCC;
}

QCalendarWidget QSpinBox {
    background-color: #FFFFFF;
    color: #000000;
    border: 1px solid #CCCCCC;
    border-radius: 2px;
    padding: 4px;
}

QCalendarWidget QAbstractItemView:enabled {
    background-color: #FFFFFF;
    color: #000000;
    selection-background-color: #EEEEEE;
    selection-color: #000000;
}

QCalendarWidget QAbstractItemView:disabled {
    color: #AAAAAA;
}

/* Tool Box */
QToolBox::tab {
    background-color: #FFFFFF;
    color: #000000;
    border: 1px solid #CCCCCC;
    border-radius: 2px;
    padding: 4px;
}

QToolBox::tab:selected {
    background-color: #EEEEEE;
    color: #000000;
}

/* Dock Widget */
QDockWidget {
    titlebar-close-icon: url(:/icons/close_minimal.png);
    titlebar-normal-icon: url(:/icons/undock_minimal.png);
}

QDockWidget::title {
    text-align: left;
    background-color: #FFFFFF;
    color: #000000;
    padding: 4px;
    border: 1px solid #CCCCCC;
}

/* MDI Area */
QMdiArea {
    background-color: #F5F5F5;
}

QMdiSubWindow {
    background-color: #FFFFFF;
    border: 1px solid #CCCCCC;
}

QMdiSubWindow::title {
    background-color: #FFFFFF;
    color: #000000;
}

/* Splitter */
QSplitter::handle {
    background-color: #CCCCCC;
}

QSplitter::handle:horizontal {
    width: 1px;
}

QSplitter::handle:vertical {
    height: 1px;
}

QSplitter::handle:hover {
    background-color: #999999;
}

/* ToolTip */
QToolTip {
    background-color: #FFFFFF;
    color: #000000;
    border: 1px solid #CCCCCC;
    border-radius: 2px;
    padding: 4px;
}

/* WebView */
QWebEngineView {
    background-color: #FFFFFF;
}
"""
</file>

<file path="src/ui/address_bar.py">
#!/usr/bin/env python3
# NebulaFusion Browser - Address Bar

import os
import sys
from PyQt6.QtWidgets import QLineEdit, QCompleter
from PyQt6.QtGui import QIcon
from PyQt6.QtCore import Qt, pyqtSignal, QStringListModel

class AddressBar(QLineEdit):
    """
    Address bar for NebulaFusion browser.
    Handles URL input and navigation.
    """
    
    # Signals
    url_changed = pyqtSignal(str)  # url
    
    def __init__(self, app_controller):
        """Initialize the address bar."""
        super().__init__()
        self.app_controller = app_controller
        
        # Set properties
        self.setPlaceholderText("Enter URL or search term")
        
        # Create completer
        self.completer = QCompleter()
        self.completer.setFilterMode(Qt.MatchFlag.MatchContains)
        self.completer.setCaseSensitivity(Qt.CaseSensitivity.CaseInsensitive)
        self.setCompleter(self.completer)
        
        # Connect signals
        self.returnPressed.connect(self._on_return_pressed)
    
    def set_url(self, url):
        """Set the URL in the address bar."""
        self.setText(url)
    
    def update_completer(self, urls):
        """Update the completer with a list of URLs."""
        model = QStringListModel()
        model.setStringList(urls)
        self.completer.setModel(model)
    
    def _on_return_pressed(self):
        """Handle return key press."""
        # Get URL
        url = self.text()
        
        # Check if URL is valid
        if not url.startswith(("http://", "https://", "file://", "ftp://", "data:")):
            # Check if URL is a local file
            if os.path.exists(url):
                url = f"file://{url}"
            # Check if URL is a domain
            elif "." in url and " " not in url:
                url = f"https://{url}"
            # Treat as search query
            else:
                search_engine = self.app_controller.settings_manager.get_setting("general.search_engine")
                if not search_engine:
                    search_engine = "https://www.google.com/search?q="
                url = f"{search_engine}{url.replace(' ', '+')}"
        
        # Emit signal
        self.url_changed.emit(url)
</file>

<file path="src/ui/bookmarks_dialog.py">
#!/usr/bin/env python3
# NebulaFusion Browser - Bookmarks Dialog

import os
import sys
from PyQt6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QHBoxLayout,
    QTreeWidget,
    QTreeWidgetItem,
    QPushButton,
    QLineEdit,
    QLabel,
    QMenu,
    QMessageBox,
    QInputDialog,
)
from PyQt6.QtCore import Qt, pyqtSignal, QSize
from PyQt6.QtGui import QIcon, QAction


class BookmarksDialog(QDialog):
    """
    Dialog for managing bookmarks.
    """

    def __init__(self, app_controller):
        """Initialize the bookmarks dialog."""
        super().__init__()
        self.app_controller = app_controller

        # Set properties
        self.setWindowTitle("Bookmarks")
        self.setMinimumSize(600, 400)

        # Create layout
        self.layout = QVBoxLayout(self)

        # Create search bar
        self._create_search_bar()

        # Create bookmarks tree
        self._create_bookmarks_tree()

        # Create buttons
        self._create_buttons()

        # Load bookmarks
        self._load_bookmarks()

    def _create_search_bar(self):
        """Create search bar."""
        search_layout = QHBoxLayout()

        # Search label
        search_label = QLabel("Search:")
        search_layout.addWidget(search_label)

        # Search input
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Search bookmarks...")
        self.search_edit.textChanged.connect(self._on_search)
        search_layout.addWidget(self.search_edit)

        self.layout.addLayout(search_layout)

    def _create_bookmarks_tree(self):
        """Create bookmarks tree."""
        self.bookmarks_tree = QTreeWidget()
        self.bookmarks_tree.setHeaderLabels(["Title", "URL"])
        self.bookmarks_tree.setColumnWidth(0, 250)
        self.bookmarks_tree.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.bookmarks_tree.customContextMenuRequested.connect(self._on_context_menu)
        self.bookmarks_tree.itemDoubleClicked.connect(self._on_item_double_clicked)

        self.layout.addWidget(self.bookmarks_tree)

    def _create_buttons(self):
        """Create dialog buttons."""
        button_layout = QHBoxLayout()

        # New folder button
        self.new_folder_button = QPushButton("New Folder")
        self.new_folder_button.clicked.connect(self._on_new_folder)
        button_layout.addWidget(self.new_folder_button)

        # Import button
        self.import_button = QPushButton("Import")
        self.import_button.clicked.connect(self._on_import)
        button_layout.addWidget(self.import_button)

        # Export button
        self.export_button = QPushButton("Export")
        self.export_button.clicked.connect(self._on_export)
        button_layout.addWidget(self.export_button)

        # Spacer
        button_layout.addStretch()

        # Close button
        self.close_button = QPushButton("Close")
        self.close_button.clicked.connect(self.accept)
        button_layout.addWidget(self.close_button)

        self.layout.addLayout(button_layout)

    def _load_bookmarks(self):
        """Load bookmarks from bookmark manager."""
        # Clear tree
        self.bookmarks_tree.clear()

        # Create root items for folders
        folder_items = {}

        # Get folders
        folders = self.app_controller.bookmarks_manager.get_folders()

        # Add folders to tree
        for folder in folders:
            folder_item = QTreeWidgetItem(self.bookmarks_tree)
            folder_item.setText(0, folder)
            folder_item.setIcon(0, QIcon.fromTheme("folder"))
            folder_item.setData(
                0, Qt.ItemDataRole.UserRole, {"type": "folder", "name": folder}
            )
            folder_items[folder] = folder_item

        # Get bookmarks
        bookmarks = self.app_controller.bookmarks_manager.get_bookmarks()

        # Add bookmarks to tree
        for bookmark in bookmarks:
            folder = bookmark.get("folder", "other")

            # Create folder if it doesn't exist
            if folder not in folder_items:
                folder_item = QTreeWidgetItem(self.bookmarks_tree)
                folder_item.setText(0, folder)
                folder_item.setIcon(0, QIcon.fromTheme("folder"))
                folder_item.setData(
                    0, Qt.ItemDataRole.UserRole, {"type": "folder", "name": folder}
                )
                folder_items[folder] = folder_item

            # Add bookmark to folder
            bookmark_item = QTreeWidgetItem(folder_items[folder])
            bookmark_item.setText(0, bookmark["title"])
            bookmark_item.setText(1, bookmark["url"])
            bookmark_item.setIcon(0, QIcon.fromTheme("bookmark-new"))
            bookmark_item.setData(
                0, Qt.ItemDataRole.UserRole, {"type": "bookmark", "id": bookmark["id"]}
            )

        # Expand all folders
        self.bookmarks_tree.expandAll()

    def _on_search(self, text):
        """Handle search text changed event."""
        # If search text is empty, show all bookmarks
        if not text:
            for i in range(self.bookmarks_tree.topLevelItemCount()):
                folder_item = self.bookmarks_tree.topLevelItem(i)
                folder_item.setHidden(False)

                for j in range(folder_item.childCount()):
                    bookmark_item = folder_item.child(j)
                    bookmark_item.setHidden(False)

            return

        # Hide all items that don't match search text
        for i in range(self.bookmarks_tree.topLevelItemCount()):
            folder_item = self.bookmarks_tree.topLevelItem(i)
            folder_visible = False

            for j in range(folder_item.childCount()):
                bookmark_item = folder_item.child(j)

                # Check if bookmark title or URL contains search text
                if (
                    text.lower() in bookmark_item.text(0).lower()
                    or text.lower() in bookmark_item.text(1).lower()
                ):
                    bookmark_item.setHidden(False)
                    folder_visible = True
                else:
                    bookmark_item.setHidden(True)

            # Hide folder if it has no visible bookmarks
            folder_item.setHidden(not folder_visible)

    def _on_context_menu(self, pos):
        """Handle context menu event."""
        # Get item at position
        item = self.bookmarks_tree.itemAt(pos)
        if not item:
            return

        # Get item data
        item_data = item.data(0, Qt.ItemDataRole.UserRole)
        item_type = item_data.get("type")

        # Create context menu
        menu = QMenu(self)

        if item_type == "folder":
            # Folder context menu
            rename_action = QAction("Rename Folder", menu)
            rename_action.triggered.connect(lambda: self._on_rename_folder(item))
            menu.addAction(rename_action)

            delete_action = QAction("Delete Folder", menu)
            delete_action.triggered.connect(lambda: self._on_delete_folder(item))
            menu.addAction(delete_action)

        elif item_type == "bookmark":
            # Bookmark context menu
            open_action = QAction("Open", menu)
            open_action.triggered.connect(lambda: self._on_open_bookmark(item))
            menu.addAction(open_action)

            open_new_tab_action = QAction("Open in New Tab", menu)
            open_new_tab_action.triggered.connect(
                lambda: self._on_open_bookmark_new_tab(item)
            )
            menu.addAction(open_new_tab_action)

            menu.addSeparator()

            edit_action = QAction("Edit", menu)
            edit_action.triggered.connect(lambda: self._on_edit_bookmark(item))
            menu.addAction(edit_action)

            delete_action = QAction("Delete", menu)
            delete_action.triggered.connect(lambda: self._on_delete_bookmark(item))
            menu.addAction(delete_action)

        # Show menu
        menu.exec(self.bookmarks_tree.mapToGlobal(pos))

    def _on_item_double_clicked(self, item, column):
        """Handle item double clicked event."""
        # Get item data
        item_data = item.data(0, Qt.ItemDataRole.UserRole)
        item_type = item_data.get("type")

        if item_type == "bookmark":
            # Open bookmark
            self._on_open_bookmark(item)

    def _on_open_bookmark(self, item):
        """Handle open bookmark action."""
        # Get bookmark URL
        url = item.text(1)

        # Navigate to URL
        self.app_controller.tab_manager.navigate_current_tab(url)

        # Close dialog
        self.accept()

    def _on_open_bookmark_new_tab(self, item):
        """Handle open bookmark in new tab action."""
        # Get bookmark URL
        url = item.text(1)

        # Open URL in new tab
        self.app_controller.tab_manager.new_tab(url)

        # Close dialog
        self.accept()

    def _on_edit_bookmark(self, item):
        """Handle edit bookmark action."""
        # Get bookmark data
        bookmark_id = item.data(0, Qt.ItemDataRole.UserRole).get("id")
        title = item.text(0)
        url = item.text(1)

        # Show edit dialog
        # This would typically show a dialog to edit the bookmark
        # For now, just update the bookmark with the same data
        self.app_controller.bookmark_manager.update_bookmark(bookmark_id, url, title)

    def _on_delete_bookmark(self, item):
        """Handle delete bookmark action."""
        # Get bookmark ID
        bookmark_id = item.data(0, Qt.ItemDataRole.UserRole).get("id")

        # Confirm deletion
        result = QMessageBox.question(
            self,
            "Delete Bookmark",
            "Are you sure you want to delete this bookmark?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
        )

        if result == QMessageBox.StandardButton.Yes:
            # Delete bookmark
            self.app_controller.bookmark_manager.remove_bookmark(bookmark_id)

            # Reload bookmarks
            self._load_bookmarks()

    def _on_rename_folder(self, item):
        """Handle rename folder action."""
        # Get folder name
        folder_name = item.text(0)

        # Show input dialog
        new_name, ok = QInputDialog.getText(
            self,
            "Rename Folder",
            "Enter new folder name:",
            QLineEdit.EchoMode.Normal,
            folder_name,
        )

        if ok and new_name:
            # Rename folder
            self.app_controller.bookmark_manager.rename_bookmark_folder(
                folder_name, new_name
            )

            # Reload bookmarks
            self._load_bookmarks()

    def _on_delete_folder(self, item):
        """Handle delete folder action."""
        # Get folder name
        folder_name = item.text(0)

        # Confirm deletion
        result = QMessageBox.question(
            self,
            "Delete Folder",
            f"Are you sure you want to delete the folder '{folder_name}' and all its bookmarks?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
        )

        if result == QMessageBox.StandardButton.Yes:
            # Delete folder
            self.app_controller.bookmark_manager.remove_bookmark_folder(folder_name)

            # Reload bookmarks
            self._load_bookmarks()

    def _on_new_folder(self):
        """Handle new folder button click."""
        # Show input dialog
        folder_name, ok = QInputDialog.getText(
            self, "New Folder", "Enter folder name:", QLineEdit.EchoMode.Normal
        )

        if ok and folder_name:
            # Create folder
            self.app_controller.bookmark_manager.create_bookmark_folder(folder_name)

            # Reload bookmarks
            self._load_bookmarks()

    def _on_import(self):
        """Handle import button click."""
        # This would typically show a file dialog to import bookmarks
        # For now, just log the action
        self.app_controller.logger.info("Import bookmarks action triggered")

    def _on_export(self):
        """Handle export button click."""
        # This would typically show a file dialog to export bookmarks
        # For now, just log the action
        self.app_controller.logger.info("Export bookmarks action triggered")
</file>

<file path="src/ui/browser_tabs.py">
#!/usr/bin/env python3
# NebulaFusion Browser - Browser Tabs

import os
import sys
from PyQt6.QtWidgets import QTabWidget, QMenu, QTabBar, QWidget, QVBoxLayout, QLabel
from PyQt6.QtCore import Qt, QUrl, pyqtSignal, QObject
from PyQt6.QtGui import QIcon, QAction, QContextMenuEvent
from PyQt6.QtWebEngineWidgets import QWebEngineView
from PyQt6.QtWebEngineCore import QWebEnginePage


class BrowserTab(QWebEngineView):
    """
    Individual browser tab containing a web view.
    """

    # Signals
    title_changed = pyqtSignal(str)
    url_changed = pyqtSignal(QUrl)
    icon_changed = pyqtSignal(QIcon)
    loading_started = pyqtSignal()
    loading_finished = pyqtSignal(bool)
    loading_progress = pyqtSignal(int)

    def __init__(self, app_controller, private=False):
        """Initialize the browser tab."""
        super().__init__()
        self.app_controller = app_controller
        self.private = private

        # Create web profile
        if private:
            # Create off-the-record profile for private browsing
            self.profile = (
                self.app_controller.web_engine_manager.create_private_profile()
            )
        else:
            # Use default profile
            self.profile = self.app_controller.web_engine_manager.get_default_profile()

        # Create web page
        self.page = QWebEnginePage(self.profile, self)
        self.setPage(self.page)

        # Connect signals
        self._connect_signals()

    def _connect_signals(self):
        """Connect signals."""
        # Page signals
        self.titleChanged.connect(self.title_changed)
        self.urlChanged.connect(self.url_changed)
        self.iconChanged.connect(self.icon_changed)
        self.loadStarted.connect(self.loading_started)
        self.loadFinished.connect(self.loading_finished)
        self.loadProgress.connect(self.loading_progress)

    def navigate(self, url):
        """Navigate to URL."""
        if isinstance(url, str):
            # Convert string to QUrl
            if (
                url.startswith("http://")
                or url.startswith("https://")
                or url.startswith("file://")
            ):
                qurl = QUrl(url)
            else:
                # Assume it's a search or URL without scheme
                if "." in url and " " not in url:
                    # Likely a URL without scheme
                    qurl = QUrl("https://" + url)
                else:
                    # Likely a search query
                    search_engine = self.app_controller.settings_manager.get_setting(
                        "default_search_engine"
                    )
                    if search_engine == "google":
                        qurl = QUrl(
                            "https://www.google.com/search?q=" + url.replace(" ", "+")
                        )
                    elif search_engine == "bing":
                        qurl = QUrl(
                            "https://www.bing.com/search?q=" + url.replace(" ", "+")
                        )
                    elif search_engine == "duckduckgo":
                        qurl = QUrl(
                            "https://duckduckgo.com/?q=" + url.replace(" ", "+")
                        )
                    else:
                        qurl = QUrl(
                            "https://www.google.com/search?q=" + url.replace(" ", "+")
                        )
        else:
            # Already a QUrl
            qurl = url

        # Add to history
        if not self.private:
            self.app_controller.history_manager.add_history(
                qurl.toString(), self.title()
            )

        # Navigate
        self.load(qurl)

    def back(self):
        """Go back in history."""
        self.triggerPageAction(QWebEnginePage.WebAction.Back)

    def forward(self):
        """Go forward in history."""
        self.triggerPageAction(QWebEnginePage.WebAction.Forward)

    def reload(self):
        """Reload page."""
        self.triggerPageAction(QWebEnginePage.WebAction.Reload)

    def stop(self):
        """Stop loading."""
        self.triggerPageAction(QWebEnginePage.WebAction.Stop)

    def zoom_in(self):
        """Zoom in."""
        current_zoom = self.zoomFactor()
        self.setZoomFactor(current_zoom + 0.1)

    def zoom_out(self):
        """Zoom out."""
        current_zoom = self.zoomFactor()
        self.setZoomFactor(max(0.1, current_zoom - 0.1))

    def zoom_reset(self):
        """Reset zoom."""
        self.setZoomFactor(1.0)

    def save_page(self, file_path):
        """Save page to file."""
        self.page.save(file_path)

    def print_page(self):
        """Print page."""
        self.triggerPageAction(QWebEnginePage.WebAction.Print)

    def find(self):
        """Find in page."""
        self.triggerPageAction(QWebEnginePage.WebAction.Find)

    def cut(self):
        """Cut selected text."""
        self.triggerPageAction(QWebEnginePage.WebAction.Cut)

    def copy(self):
        """Copy selected text."""
        self.triggerPageAction(QWebEnginePage.WebAction.Copy)

    def paste(self):
        """Paste from clipboard."""
        self.triggerPageAction(QWebEnginePage.WebAction.Paste)

    def undo(self):
        """Undo last action."""
        self.triggerPageAction(QWebEnginePage.WebAction.Undo)

    def redo(self):
        """Redo last undone action."""
        self.triggerPageAction(QWebEnginePage.WebAction.Redo)

    def toggle_inspector(self):
        """Toggle web inspector."""
        self.triggerPageAction(QWebEnginePage.WebAction.InspectElement)

    def contextMenuEvent(self, event):
        """Handle context menu event."""
        # Create context menu
        menu = self.createStandardContextMenu()

        # Add custom actions
        menu.addSeparator()

        # Add bookmark action
        bookmark_action = QAction("Bookmark This Page", menu)
        bookmark_action.triggered.connect(self._on_bookmark_page)
        menu.addAction(bookmark_action)

        # Add reality augmentation action
        reality_action = QAction("Reality Augmentation", menu)
        reality_action.triggered.connect(self._on_reality_augmentation)
        menu.addAction(reality_action)

        # Add content transformation action
        transform_action = QAction("Content Transformation", menu)
        transform_action.triggered.connect(self._on_content_transformation)
        menu.addAction(transform_action)

        # Add plugin context menu items
        self.app_controller.hook_registry.trigger_hook(
            "onContextMenu", menu, self.url().toString()
        )

        # Show menu
        menu.exec(event.globalPos())

    def _on_bookmark_page(self):
        """Handle bookmark page action."""
        url = self.url().toString()
        title = self.title()
        self.app_controller.bookmark_manager.add_bookmark(url, title)

    def _on_reality_augmentation(self):
        """Handle reality augmentation action."""
        # This would typically activate reality augmentation
        # For now, just log the action
        self.app_controller.logger.info("Reality Augmentation action triggered")

        # Trigger hook
        self.app_controller.hook_registry.trigger_hook(
            "onRealityAugmentation", "activate"
        )

    def _on_content_transformation(self):
        """Handle content transformation action."""
        # This would typically transform content
        # For now, just log the action
        self.app_controller.logger.info("Content Transformation action triggered")

        # Trigger hook
        self.app_controller.hook_registry.trigger_hook(
            "onContentTransform", "text_to_speech", ""
        )


class BrowserTabs(QTabWidget):
    """
    Tab widget for browser tabs.
    """

    def __init__(self, app_controller):
        """Initialize the browser tabs."""
        super().__init__()
        self.app_controller = app_controller

        # Set properties
        self.setTabsClosable(True)
        self.setMovable(True)
        self.setDocumentMode(True)
        self.setElideMode(Qt.TextElideMode.ElideRight)

        # Add new tab button
        self.setCornerWidget(self._create_new_tab_button())

        # Connect signals
        self.tabCloseRequested.connect(self._on_tab_close_requested)
        self.currentChanged.connect(self._on_current_changed)

        # Tab context menu
        self.tabBar().setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.tabBar().customContextMenuRequested.connect(self._on_tab_context_menu)

    def _create_new_tab_button(self):
        """Create new tab button."""
        button = QWidget()
        layout = QVBoxLayout(button)
        layout.setContentsMargins(0, 0, 0, 0)

        label = QLabel("+")
        label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(label)

        button.setToolTip("New Tab")
        button.setCursor(Qt.CursorShape.PointingHandCursor)
        button.mousePressEvent = lambda event: self.app_controller.tab_manager.new_tab()

        return button

    def on_tab_created(self, tab_index, tab):
        """Handle tab created event."""
        # Add tab to widget
        self.addTab(tab, "New Tab")

        # Connect tab signals
        tab.title_changed.connect(
            lambda title: self._on_tab_title_changed(tab_index, title)
        )
        tab.icon_changed.connect(
            lambda icon: self._on_tab_icon_changed(tab_index, icon)
        )

        # Select tab
        self.setCurrentIndex(tab_index)

    def on_tab_closed(self, tab_index):
        """Handle tab closed event."""
        # Remove tab from widget
        self.removeTab(tab_index)

    def on_tab_selected(self, tab_index):
        """Handle tab selected event."""
        # Select tab
        self.setCurrentIndex(tab_index)

    def _on_tab_close_requested(self, tab_index):
        """Handle tab close requested event."""
        # Close tab
        self.app_controller.tab_manager.close_tab(tab_index)

    def _on_current_changed(self, tab_index):
        """Handle current tab changed event."""
        # Select tab
        self.app_controller.tab_manager.select_tab(tab_index)

    def _on_tab_title_changed(self, tab_index, title):
        """Handle tab title changed event."""
        # Update tab title
        self.setTabText(tab_index, title)
        self.setTabToolTip(tab_index, title)

    def _on_tab_icon_changed(self, tab_index, icon):
        """Handle tab icon changed event."""
        # Update tab icon
        self.setTabIcon(tab_index, icon)

    def _on_tab_context_menu(self, pos):
        """Handle tab context menu event."""
        # Get tab index
        tab_index = self.tabBar().tabAt(pos)
        if tab_index == -1:
            return

        # Create context menu
        menu = QMenu(self)

        # Add actions
        new_tab_action = QAction("New Tab", menu)
        new_tab_action.triggered.connect(
            lambda: self.app_controller.tab_manager.new_tab()
        )
        menu.addAction(new_tab_action)

        close_tab_action = QAction("Close Tab", menu)
        close_tab_action.triggered.connect(
            lambda: self.app_controller.tab_manager.close_tab(tab_index)
        )
        menu.addAction(close_tab_action)

        close_other_tabs_action = QAction("Close Other Tabs", menu)
        close_other_tabs_action.triggered.connect(
            lambda: self._close_other_tabs(tab_index)
        )
        menu.addAction(close_other_tabs_action)

        menu.addSeparator()

        reload_tab_action = QAction("Reload Tab", menu)
        reload_tab_action.triggered.connect(lambda: self._reload_tab(tab_index))
        menu.addAction(reload_tab_action)

        duplicate_tab_action = QAction("Duplicate Tab", menu)
        duplicate_tab_action.triggered.connect(lambda: self._duplicate_tab(tab_index))
        menu.addAction(duplicate_tab_action)

        menu.addSeparator()

        pin_tab_action = QAction("Pin Tab", menu)
        pin_tab_action.triggered.connect(lambda: self._pin_tab(tab_index))
        menu.addAction(pin_tab_action)

        # Show menu
        menu.exec(self.tabBar().mapToGlobal(pos))

    def _close_other_tabs(self, tab_index):
        """Close all tabs except the specified one."""
        # Get tab count
        tab_count = self.count()

        # Close tabs
        for i in range(tab_count - 1, -1, -1):
            if i != tab_index:
                self.app_controller.tab_manager.close_tab(i)

    def _reload_tab(self, tab_index):
        """Reload the specified tab."""
        # Get tab
        tab = self.widget(tab_index)
        if tab:
            tab.reload()

    def _duplicate_tab(self, tab_index):
        """Duplicate the specified tab."""
        # Get tab
        tab = self.widget(tab_index)
        if tab:
            # Create new tab with same URL
            url = tab.url().toString()
            self.app_controller.tab_manager.new_tab(url)

    def _pin_tab(self, tab_index):
        """Pin the specified tab."""
        # This would typically pin the tab
        # For now, just log the action
        self.app_controller.logger.info(f"Pin tab action triggered for tab {tab_index}")
</file>

<file path="src/ui/downloads_dialog.py">
#!/usr/bin/env python3
# NebulaFusion Browser - Downloads Dialog

import os
import sys
from PyQt6.QtWidgets import (QDialog, QVBoxLayout, QHBoxLayout, QTableWidget, QTableWidgetItem,
                            QPushButton, QProgressBar, QMenu, QMessageBox, QHeaderView,
                            QLabel, QFileDialog)
from PyQt6.QtCore import Qt, pyqtSignal, QSize
from PyQt6.QtGui import QIcon, QAction

class DownloadsDialog(QDialog):
    """
    Dialog for managing downloads.
    """
    
    def __init__(self, app_controller):
        """Initialize the downloads dialog."""
        super().__init__()
        self.app_controller = app_controller
        
        # Set properties
        self.setWindowTitle("Downloads")
        self.setMinimumSize(700, 400)
        
        # Create layout
        self.layout = QVBoxLayout(self)
        
        # Create downloads table
        self._create_downloads_table()
        
        # Create buttons
        self._create_buttons()
        
        # Load downloads
        self._load_downloads()
        
        # Connect signals
        self._connect_signals()
    
    def _create_downloads_table(self):
        """Create downloads table."""
        self.downloads_table = QTableWidget()
        self.downloads_table.setColumnCount(5)
        self.downloads_table.setHorizontalHeaderLabels(["Name", "Status", "Progress", "Size", "Location"])
        self.downloads_table.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeMode.Stretch)
        self.downloads_table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeMode.ResizeToContents)
        self.downloads_table.horizontalHeader().setSectionResizeMode(2, QHeaderView.ResizeMode.ResizeToContents)
        self.downloads_table.horizontalHeader().setSectionResizeMode(3, QHeaderView.ResizeMode.ResizeToContents)
        self.downloads_table.horizontalHeader().setSectionResizeMode(4, QHeaderView.ResizeMode.Stretch)
        self.downloads_table.setSelectionBehavior(QTableWidget.SelectionBehavior.SelectRows)
        self.downloads_table.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.downloads_table.customContextMenuRequested.connect(self._on_context_menu)
        self.downloads_table.itemDoubleClicked.connect(self._on_item_double_clicked)
        
        self.layout.addWidget(self.downloads_table)
    
    def _create_buttons(self):
        """Create dialog buttons."""
        button_layout = QHBoxLayout()
        
        # Clear completed button
        self.clear_completed_button = QPushButton("Clear Completed")
        self.clear_completed_button.clicked.connect(self._on_clear_completed)
        button_layout.addWidget(self.clear_completed_button)
        
        # Open download folder button
        self.open_folder_button = QPushButton("Open Download Folder")
        self.open_folder_button.clicked.connect(self._on_open_download_folder)
        button_layout.addWidget(self.open_folder_button)
        
        # Spacer
        button_layout.addStretch()
        
        # Close button
        self.close_button = QPushButton("Close")
        self.close_button.clicked.connect(self.accept)
        button_layout.addWidget(self.close_button)
        
        self.layout.addLayout(button_layout)
    
    def _connect_signals(self):
        """Connect signals."""
        # Connect to download manager signals
        self.app_controller.download_manager.download_started.connect(self._on_download_started)
        self.app_controller.download_manager.download_progress.connect(self._on_download_progress)
        self.app_controller.download_manager.download_finished.connect(self._on_download_finished)
    
    def _load_downloads(self):
        """Load downloads from download manager."""
        # Clear table
        self.downloads_table.setRowCount(0)
        
        # Get downloads
        downloads = self.app_controller.download_manager.get_downloads()
        
        # Add downloads to table
        for i, download in enumerate(downloads):
            self._add_download_to_table(download)
    
    def _add_download_to_table(self, download):
        """Add download to table."""
        # Insert new row
        row = self.downloads_table.rowCount()
        self.downloads_table.insertRow(row)
        
        # Name
        name_item = QTableWidgetItem(os.path.basename(download["path"]))
        name_item.setData(Qt.ItemDataRole.UserRole, download["id"])
        self.downloads_table.setItem(row, 0, name_item)
        
        # Status
        status_item = QTableWidgetItem(download["status"])
        self.downloads_table.setItem(row, 1, status_item)
        
        # Progress
        progress_bar = QProgressBar()
        progress_bar.setRange(0, 100)
        progress_bar.setValue(download["progress"])
        self.downloads_table.setCellWidget(row, 2, progress_bar)
        
        # Size
        size_item = QTableWidgetItem(self._format_size(download["size"]))
        self.downloads_table.setItem(row, 3, size_item)
        
        # Location
        location_item = QTableWidgetItem(os.path.dirname(download["path"]))
        self.downloads_table.setItem(row, 4, location_item)
    
    def _format_size(self, size):
        """Format size in bytes to human-readable format."""
        if size < 0:
            return "Unknown"
        
        if size < 1024:
            return f"{size} B"
        
        if size < 1024 * 1024:
            return f"{size / 1024:.1f} KB"
        
        if size < 1024 * 1024 * 1024:
            return f"{size / (1024 * 1024):.1f} MB"
        
        return f"{size / (1024 * 1024 * 1024):.1f} GB"
    
    def _find_download_row(self, download_id):
        """Find row index for download ID."""
        for i in range(self.downloads_table.rowCount()):
            item = self.downloads_table.item(i, 0)
            if item and item.data(Qt.ItemDataRole.UserRole) == download_id:
                return i
        
        return -1
    
    def _on_download_started(self, download_id, url, path):
        """Handle download started event."""
        # Get download
        download = self.app_controller.download_manager.get_download(download_id)
        if download:
            self._add_download_to_table(download)
    
    def _on_download_progress(self, download_id, received, total):
        """Handle download progress event."""
        # Find download row
        row = self._find_download_row(download_id)
        if row >= 0:
            # Update progress
            progress_bar = self.downloads_table.cellWidget(row, 2)
            if progress_bar:
                if total > 0:
                    percent = int(received * 100 / total)
                    progress_bar.setValue(percent)
                else:
                    progress_bar.setRange(0, 0)  # Indeterminate progress
            
            # Update size
            if total > 0:
                size_item = self.downloads_table.item(row, 3)
                if size_item:
                    size_item.setText(f"{self._format_size(received)} / {self._format_size(total)}")
    
    def _on_download_finished(self, download_id, success):
        """Handle download finished event."""
        # Find download row
        row = self._find_download_row(download_id)
        if row >= 0:
            # Update status
            status_item = self.downloads_table.item(row, 1)
            if status_item:
                status_item.setText("Completed" if success else "Failed")
            
            # Update progress
            progress_bar = self.downloads_table.cellWidget(row, 2)
            if progress_bar:
                progress_bar.setRange(0, 100)
                progress_bar.setValue(100 if success else 0)
    
    def _on_context_menu(self, pos):
        """Handle context menu event."""
        # Get selected items
        selected_items = self.downloads_table.selectedItems()
        if not selected_items:
            return
        
        # Create context menu
        menu = QMenu(self)
        
        # Open file action
        open_action = QAction("Open File", menu)
        open_action.triggered.connect(self._on_open_file)
        menu.addAction(open_action)
        
        # Open containing folder action
        open_folder_action = QAction("Open Containing Folder", menu)
        open_folder_action.triggered.connect(self._on_open_containing_folder)
        menu.addAction(open_folder_action)
        
        menu.addSeparator()
        
        # Copy URL action
        copy_url_action = QAction("Copy Download URL", menu)
        copy_url_action.triggered.connect(self._on_copy_url)
        menu.addAction(copy_url_action)
        
        menu.addSeparator()
        
        # Resume action
        resume_action = QAction("Resume", menu)
        resume_action.triggered.connect(self._on_resume_download)
        menu.addAction(resume_action)
        
        # Pause action
        pause_action = QAction("Pause", menu)
        pause_action.triggered.connect(self._on_pause_download)
        menu.addAction(pause_action)
        
        # Cancel action
        cancel_action = QAction("Cancel", menu)
        cancel_action.triggered.connect(self._on_cancel_download)
        menu.addAction(cancel_action)
        
        menu.addSeparator()
        
        # Remove from list action
        remove_action = QAction("Remove from List", menu)
        remove_action.triggered.connect(self._on_remove_download)
        menu.addAction(remove_action)
        
        # Show menu
        menu.exec(self.downloads_table.mapToGlobal(pos))
    
    def _on_item_double_clicked(self, item):
        """Handle item double clicked event."""
        # Open file
        self._on_open_file()
    
    def _on_open_file(self):
        """Handle open file action."""
        # Get selected row
        selected_rows = set(item.row() for item in self.downloads_table.selectedItems())
        if not selected_rows:
            return
        
        # Get download ID from first selected row
        row = list(selected_rows)[0]
        download_id = self.downloads_table.item(row, 0).data(Qt.ItemDataRole.UserRole)
        
        # Get download
        download = self.app_controller.download_manager.get_download(download_id)
        if download and download["status"] == "Completed":
            # Open file
            self.app_controller.file_utils.open_file(download["path"])
    
    def _on_open_containing_folder(self):
        """Handle open containing folder action."""
        # Get selected row
        selected_rows = set(item.row() for item in self.downloads_table.selectedItems())
        if not selected_rows:
            return
        
        # Get download ID from first selected row
        row = list(selected_rows)[0]
        download_id = self.downloads_table.item(row, 0).data(Qt.ItemDataRole.UserRole)
        
        # Get download
        download = self.app_controller.download_manager.get_download(download_id)
        if download:
            # Open containing folder
            self.app_controller.file_utils.open_folder(os.path.dirname(download["path"]))
    
    def _on_copy_url(self):
        """Handle copy URL action."""
        # Get selected row
        selected_rows = set(item.row() for item in self.downloads_table.selectedItems())
        if not selected_rows:
            return
        
        # Get download ID from first selected row
        row = list(selected_rows)[0]
        download_id = self.downloads_table.item(row, 0).data(Qt.ItemDataRole.UserRole)
        
        # Get download
        download = self.app_controller.download_manager.get_download(download_id)
        if download:
            # Copy URL to clipboard
            from PyQt6.QtWidgets import QApplication
            clipboard = QApplication.clipboard()
            clipboard.setText(download["url"])
    
    def _on_resume_download(self):
        """Handle resume download action."""
        # Get selected rows
        selected_rows = set(item.row() for item in self.downloads_table.selectedItems())
        if not selected_rows:
            return
        
        # Resume downloads
        for row in selected_rows:
            download_id = self.downloads_table.item(row, 0).data(Qt.ItemDataRole.UserRole)
            self.app_controller.download_manager.resume_download(download_id)
    
    def _on_pause_download(self):
        """Handle pause download action."""
        # Get selected rows
        selected_rows = set(item.row() for item in self.downloads_table.selectedItems())
        if not selected_rows:
            return
        
        # Pause downloads
        for row in selected_rows:
            download_id = self.downloads_table.item(row, 0).data(Qt.ItemDataRole.UserRole)
            self.app_controller.download_manager.pause_download(download_id)
    
    def _on_cancel_download(self):
        """Handle cancel download action."""
        # Get selected rows
        selected_rows = set(item.row() for item in self.downloads_table.selectedItems())
        if not selected_rows:
            return
        
        # Confirm cancellation
        result = QMessageBox.question(
            self,
            "Cancel Downloads",
            f"Are you sure you want to cancel {len(selected_rows)} downloads?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )
        
        if result == QMessageBox.StandardButton.Yes:
            # Cancel downloads
            for row in selected_rows:
                download_id = self.downloads_table.item(row, 0).data(Qt.ItemDataRole.UserRole)
                self.app_controller.download_manager.cancel_download(download_id)
    
    def _on_remove_download(self):
        """Handle remove download action."""
        # Get selected rows
        selected_rows = set(item.row() for item in self.downloads_table.selectedItems())
        if not selected_rows:
            return
        
        # Confirm removal
        result = QMessageBox.question(
            self,
            "Remove Downloads",
            f"Are you sure you want to remove {len(selected_rows)} downloads from the list?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )
        
        if result == QMessageBox.StandardButton.Yes:
            # Remove downloads
            for row in sorted(selected_rows, reverse=True):
                download_id = self.downloads_table.item(row, 0).data(Qt.ItemDataRole.UserRole)
                self.app_controller.download_manager.remove_download(download_id)
                self.downloads_table.removeRow(row)
    
    def _on_clear_completed(self):
        """Handle clear completed button click."""
        # Confirm removal
        result = QMessageBox.question(
            self,
            "Clear Completed Downloads",
            "Are you sure you want to clear all completed downloads from the list?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )
        
        if result == QMessageBox.StandardButton.Yes:
            # Clear completed downloads
            self.app_controller.download_manager.clear_completed_downloads()
            
            # Reload downloads
            self._load_downloads()
    
    def _on_open_download_folder(self):
        """Handle open download folder button click."""
        # Get download directory
        download_dir = self.app_controller.settings_manager.get_setting("download_directory")
        
        # Open folder
        self.app_controller.file_utils.open_folder(download_dir)
</file>

<file path="src/ui/history_dialog.py">
#!/usr/bin/env python3
# NebulaFusion Browser - History Dialog

import os
import sys
from PyQt6.QtWidgets import (QDialog, QVBoxLayout, QHBoxLayout, QTableWidget, QTableWidgetItem,
                            QPushButton, QLineEdit, QLabel, QMenu, QMessageBox, QHeaderView,
                            QDateEdit, QComboBox)
from PyQt6.QtCore import Qt, pyqtSignal, QSize, QDate, QDateTime
from PyQt6.QtGui import QIcon, QAction

class HistoryDialog(QDialog):
    """
    Dialog for browsing and managing history.
    """
    
    def __init__(self, app_controller):
        """Initialize the history dialog."""
        super().__init__()
        self.app_controller = app_controller
        
        # Set properties
        self.setWindowTitle("History")
        self.setMinimumSize(700, 500)
        
        # Create layout
        self.layout = QVBoxLayout(self)
        
        # Create search and filter bar
        self._create_search_bar()
        
        # Create history table
        self._create_history_table()
        
        # Create buttons
        self._create_buttons()
        
        # Load history
        self._load_history()
    
    def _create_search_bar(self):
        """Create search and filter bar."""
        search_layout = QHBoxLayout()
        
        # Search label
        search_label = QLabel("Search:")
        search_layout.addWidget(search_label)
        
        # Search input
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Search history...")
        self.search_edit.textChanged.connect(self._on_search)
        search_layout.addWidget(self.search_edit)
        
        # Date filter label
        date_label = QLabel("Date:")
        search_layout.addWidget(date_label)
        
        # Date filter combo
        self.date_combo = QComboBox()
        self.date_combo.addItems(["All Time", "Today", "Yesterday", "Last 7 Days", "Last 30 Days", "Custom"])
        self.date_combo.currentIndexChanged.connect(self._on_date_filter_changed)
        search_layout.addWidget(self.date_combo)
        
        # Custom date filter
        self.date_edit = QDateEdit()
        self.date_edit.setCalendarPopup(True)
        self.date_edit.setDate(QDate.currentDate())
        self.date_edit.setVisible(False)
        self.date_edit.dateChanged.connect(self._on_custom_date_changed)
        search_layout.addWidget(self.date_edit)
        
        self.layout.addLayout(search_layout)
    
    def _create_history_table(self):
        """Create history table."""
        self.history_table = QTableWidget()
        self.history_table.setColumnCount(3)
        self.history_table.setHorizontalHeaderLabels(["Title", "URL", "Date"])
        self.history_table.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeMode.Stretch)
        self.history_table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeMode.Stretch)
        self.history_table.horizontalHeader().setSectionResizeMode(2, QHeaderView.ResizeMode.ResizeToContents)
        self.history_table.setSelectionBehavior(QTableWidget.SelectionBehavior.SelectRows)
        self.history_table.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.history_table.customContextMenuRequested.connect(self._on_context_menu)
        self.history_table.itemDoubleClicked.connect(self._on_item_double_clicked)
        
        self.layout.addWidget(self.history_table)
    
    def _create_buttons(self):
        """Create dialog buttons."""
        button_layout = QHBoxLayout()
        
        # Clear history button
        self.clear_button = QPushButton("Clear History")
        self.clear_button.clicked.connect(self._on_clear_history)
        button_layout.addWidget(self.clear_button)
        
        # Spacer
        button_layout.addStretch()
        
        # Close button
        self.close_button = QPushButton("Close")
        self.close_button.clicked.connect(self.accept)
        button_layout.addWidget(self.close_button)
        
        self.layout.addLayout(button_layout)
    
    def _load_history(self):
        """Load history from history manager."""
        # Clear table
        self.history_table.setRowCount(0)
        
        # Get history
        history = self.app_controller.history_manager.get_history(limit=1000)
        
        # Add history to table
        for i, item in enumerate(history):
            self.history_table.insertRow(i)
            
            # Title
            title_item = QTableWidgetItem(item["title"])
            title_item.setData(Qt.ItemDataRole.UserRole, item["id"])
            self.history_table.setItem(i, 0, title_item)
            
            # URL
            url_item = QTableWidgetItem(item["url"])
            self.history_table.setItem(i, 1, url_item)
            
            # Date
            date = QDateTime.fromSecsSinceEpoch(item["timestamp"]).toString("yyyy-MM-dd hh:mm:ss")
            date_item = QTableWidgetItem(date)
            date_item.setData(Qt.ItemDataRole.UserRole, item["timestamp"])
            self.history_table.setItem(i, 2, date_item)
    
    def _filter_history(self):
        """Filter history based on search text and date filter."""
        search_text = self.search_edit.text().lower()
        date_filter = self.date_combo.currentText()
        
        # Get current date
        current_date = QDate.currentDate()
        
        # Show all rows
        for i in range(self.history_table.rowCount()):
            self.history_table.setRowHidden(i, False)
        
        # Apply search filter
        if search_text:
            for i in range(self.history_table.rowCount()):
                title = self.history_table.item(i, 0).text().lower()
                url = self.history_table.item(i, 1).text().lower()
                
                if search_text not in title and search_text not in url:
                    self.history_table.setRowHidden(i, True)
        
        # Apply date filter
        if date_filter != "All Time":
            for i in range(self.history_table.rowCount()):
                if self.history_table.isRowHidden(i):
                    continue
                
                timestamp = self.history_table.item(i, 2).data(Qt.ItemDataRole.UserRole)
                date = QDateTime.fromSecsSinceEpoch(timestamp).date()
                
                if date_filter == "Today":
                    if date != current_date:
                        self.history_table.setRowHidden(i, True)
                
                elif date_filter == "Yesterday":
                    if date != current_date.addDays(-1):
                        self.history_table.setRowHidden(i, True)
                
                elif date_filter == "Last 7 Days":
                    if date < current_date.addDays(-7):
                        self.history_table.setRowHidden(i, True)
                
                elif date_filter == "Last 30 Days":
                    if date < current_date.addDays(-30):
                        self.history_table.setRowHidden(i, True)
                
                elif date_filter == "Custom":
                    custom_date = self.date_edit.date()
                    if date != custom_date:
                        self.history_table.setRowHidden(i, True)
    
    def _on_search(self, text):
        """Handle search text changed event."""
        self._filter_history()
    
    def _on_date_filter_changed(self, index):
        """Handle date filter changed event."""
        # Show custom date edit if "Custom" is selected
        self.date_edit.setVisible(self.date_combo.currentText() == "Custom")
        
        # Apply filter
        self._filter_history()
    
    def _on_custom_date_changed(self, date):
        """Handle custom date changed event."""
        self._filter_history()
    
    def _on_context_menu(self, pos):
        """Handle context menu event."""
        # Get selected items
        selected_items = self.history_table.selectedItems()
        if not selected_items:
            return
        
        # Create context menu
        menu = QMenu(self)
        
        # Open action
        open_action = QAction("Open", menu)
        open_action.triggered.connect(self._on_open_selected)
        menu.addAction(open_action)
        
        # Open in new tab action
        open_new_tab_action = QAction("Open in New Tab", menu)
        open_new_tab_action.triggered.connect(self._on_open_selected_new_tab)
        menu.addAction(open_new_tab_action)
        
        menu.addSeparator()
        
        # Copy URL action
        copy_url_action = QAction("Copy URL", menu)
        copy_url_action.triggered.connect(self._on_copy_url)
        menu.addAction(copy_url_action)
        
        menu.addSeparator()
        
        # Delete action
        delete_action = QAction("Delete", menu)
        delete_action.triggered.connect(self._on_delete_selected)
        menu.addAction(delete_action)
        
        # Show menu
        menu.exec(self.history_table.mapToGlobal(pos))
    
    def _on_item_double_clicked(self, item):
        """Handle item double clicked event."""
        # Open URL
        self._on_open_selected()
    
    def _on_open_selected(self):
        """Handle open selected action."""
        # Get selected row
        selected_rows = set(item.row() for item in self.history_table.selectedItems())
        if not selected_rows:
            return
        
        # Get URL from first selected row
        row = list(selected_rows)[0]
        url = self.history_table.item(row, 1).text()
        
        # Navigate to URL
        self.app_controller.tab_manager.navigate_current_tab(url)
        
        # Close dialog
        self.accept()
    
    def _on_open_selected_new_tab(self):
        """Handle open selected in new tab action."""
        # Get selected rows
        selected_rows = set(item.row() for item in self.history_table.selectedItems())
        if not selected_rows:
            return
        
        # Get URL from first selected row
        row = list(selected_rows)[0]
        url = self.history_table.item(row, 1).text()
        
        # Open URL in new tab
        self.app_controller.tab_manager.new_tab(url)
        
        # Close dialog
        self.accept()
    
    def _on_copy_url(self):
        """Handle copy URL action."""
        # Get selected rows
        selected_rows = set(item.row() for item in self.history_table.selectedItems())
        if not selected_rows:
            return
        
        # Get URL from first selected row
        row = list(selected_rows)[0]
        url = self.history_table.item(row, 1).text()
        
        # Copy URL to clipboard
        clipboard = QApplication.clipboard()
        clipboard.setText(url)
    
    def _on_delete_selected(self):
        """Handle delete selected action."""
        # Get selected rows
        selected_rows = set(item.row() for item in self.history_table.selectedItems())
        if not selected_rows:
            return
        
        # Confirm deletion
        result = QMessageBox.question(
            self,
            "Delete History Items",
            f"Are you sure you want to delete {len(selected_rows)} history items?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )
        
        if result == QMessageBox.StandardButton.Yes:
            # Delete history items
            for row in sorted(selected_rows, reverse=True):
                history_id = self.history_table.item(row, 0).data(Qt.ItemDataRole.UserRole)
                self.app_controller.history_manager.remove_history(history_id)
                self.history_table.removeRow(row)
    
    def _on_clear_history(self):
        """Handle clear history button click."""
        # Confirm deletion
        result = QMessageBox.question(
            self,
            "Clear History",
            "Are you sure you want to clear all browsing history?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )
        
        if result == QMessageBox.StandardButton.Yes:
            # Clear history
            self.app_controller.history_manager.clear_history()
            
            # Reload history
            self._load_history()
</file>

<file path="src/ui/main_window.py">
#!/usr/bin/env python3
# NebulaFusion Browser - Main Window (FULL CORRECTED COMBINED VERSION)

from PyQt6.QtWidgets import (
    QMainWindow,
    QWidget,
    QVBoxLayout,
    QTabWidget,
    QToolBar,
    QLineEdit,
    QMessageBox,
)
from PyQt6.QtGui import QAction
from PyQt6.QtWebEngineWidgets import QWebEngineView
from PyQt6.QtCore import QUrl, Qt

# Import your dialogs
from src.ui.plugin_dialog import PluginDialog
from src.ui.history_dialog import HistoryDialog
from src.ui.bookmarks_dialog import BookmarksDialog
from src.ui.settings_dialog import SettingsDialog
from src.ui.status_bar import StatusBar
from src.ui.toolbar import Toolbar


class MainWindow(QMainWindow):
    def __init__(self, app_controller):
        super().__init__()

        self.app_controller = app_controller
        self.setWindowTitle("NebulaFusion Browser")
        self.resize(1200, 800)

        # Central widget and layout
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        self.layout = QVBoxLayout(central_widget)

        # --- Add persistent toolbar (for plugins and navigation) ---
        self.toolbar = Toolbar(self.app_controller)
        self.toolbar.action_triggered.connect(self.handle_toolbar_action)
        self.addToolBar(self.toolbar)

        # Address bar
        self.address_bar = QLineEdit()
        self.address_bar.returnPressed.connect(self.navigate_to_address)
        self.layout.addWidget(self.address_bar)

        # Tab widget
        self.tab_widget = QTabWidget()
        self.tab_widget.setTabsClosable(True)
        self.tab_widget.tabCloseRequested.connect(self.close_tab)
        self.tab_widget.currentChanged.connect(self.update_address_bar)
        self.layout.addWidget(self.tab_widget)

        # Plugin / Manager dialogs
        self.plugin_manager_dialog = PluginDialog(self.app_controller)
        self.history_dialog = HistoryDialog(self.app_controller)
        self.bookmarks_dialog = BookmarksDialog(self.app_controller)
        self.settings_dialog = SettingsDialog(self.app_controller)
        self.downloads_dialog = None  # Will be created when needed

        # Status bar
        self.status_bar = StatusBar(self.app_controller)
        self.setStatusBar(self.status_bar)

        # Open initial tab
        self.add_new_tab(QUrl("https://www.google.com"), "New Tab")

        self.app_controller.logger.info(
            "Main window fully initialized with tabbed browsing and managers."
        )

    def add_new_tab(self, url, label="New Tab"):
        browser = QWebEngineView()
        browser.setUrl(url)

        index = self.tab_widget.addTab(browser, label)
        self.tab_widget.setCurrentIndex(index)

        self.app_controller.hook_registry.trigger_hook("onTabCreated", tab=browser)

        # Connect signals
        browser.urlChanged.connect(
            lambda qurl, browser=browser: self.update_url(qurl, browser)
        )
        browser.loadFinished.connect(
            lambda _, browser=browser: self.update_tab_title(browser)
        )

        # Trigger plugin hook
        self.app_controller.hook_registry.trigger_hook("onTabCreated")

        self.app_controller.logger.info(f"New tab opened: {url.toString()}")

    def handle_toolbar_action(self, action_id):
        """Handle toolbar button clicks."""
        browser = self.current_browser()
        if not browser and action_id not in ["plugins", "settings"]:
            return
            
        if action_id == "back":
            browser.back()
        elif action_id == "forward":
            browser.forward()
        elif action_id == "reload":
            browser.reload()
        elif action_id == "stop":
            browser.stop()
        elif action_id == "home":
            home_url = self.app_controller.settings_manager.get_setting("general.homepage", "https://www.google.com")
            browser.setUrl(QUrl(home_url))
        elif action_id == "bookmark":
            self.show_bookmarks()
        elif action_id == "history":
            self.show_history()
        elif action_id == "downloads":
            self.show_downloads()
        elif action_id == "plugins":
            self.plugin_manager_dialog.show()
        elif action_id == "settings":
            self.show_settings()

    def navigate_to_address(self):
        url_text = self.address_bar.text()
        if not url_text.startswith("http"):
            url_text = "https://" + url_text
        qurl = QUrl(url_text)
        current_browser = self.current_browser()
        if current_browser:
            current_browser.setUrl(qurl)
            self.app_controller.logger.info(f"Navigating to: {qurl.toString()}")

    def update_address_bar(self, index):
        browser = self.current_browser()
        if browser:
            url = browser.url().toString()
            self.address_bar.setText(url)

    def update_url(self, qurl, browser):
        if browser == self.current_browser():
            self.address_bar.setText(qurl.toString())

    def update_tab_title(self, browser):
        index = self.tab_widget.indexOf(browser)
        if index != -1:
            self.tab_widget.setTabText(index, browser.title())

    def current_browser(self):
        return self.tab_widget.currentWidget()

    def close_tab(self, index):
        if self.tab_widget.count() < 2:
            QMessageBox.warning(self, "Warning", "Cannot close the last tab.")
            return
        self.tab_widget.removeTab(index)
        self.app_controller.logger.info(f"Tab closed: {index}")
        self.app_controller.hook_registry.trigger_hook("onTabClosed")

        # Trigger plugin hook
        self.app_controller.hook_registry.trigger_hook("onTabClosed")

    def go_back(self):
        browser = self.current_browser()
        if browser:
            browser.back()

    def go_forward(self):
        browser = self.current_browser()
        if browser:
            browser.forward()

    def reload_page(self):
        browser = self.current_browser()
        if browser:
            browser.reload()

    # Dialog handlers
    def show_plugin_manager(self):
        self.plugin_manager_dialog.show()

    def show_history(self):
        self.history_dialog.show()

    def show_bookmarks(self):
        self.bookmarks_dialog.show()

    def show_settings(self):
        """Show settings dialog."""
        self.settings_dialog.show()
        
    def show_downloads(self):
        """Show downloads dialog."""
        if not hasattr(self, 'downloads_dialog') or not self.downloads_dialog:
            from src.ui.downloads_dialog import DownloadsDialog
            self.downloads_dialog = DownloadsDialog(self.app_controller)
        self.downloads_dialog.show()
</file>

<file path="src/ui/plugin_dialog.py">
#!/usr/bin/env python3
# NebulaFusion Browser - Plugin Dialog

import os
import sys
from PyQt6.QtWidgets import (QDialog, QVBoxLayout, QHBoxLayout, QTableWidget, QTableWidgetItem,
                            QPushButton, QLabel, QMenu, QMessageBox, QHeaderView,
                            QCheckBox, QFileDialog, QTabWidget, QWidget, QTextEdit)
from PyQt6.QtCore import Qt, pyqtSignal, QSize
from PyQt6.QtGui import QIcon, QAction

class PluginDialog(QDialog):
    """
    Dialog for managing plugins.
    """
    
    def __init__(self, app_controller):
        """Initialize the plugin dialog."""
        super().__init__()
        self.app_controller = app_controller
        
        # Set properties
        self.setWindowTitle("Plugins")
        self.setMinimumSize(800, 500)
        
        # Create layout
        self.layout = QVBoxLayout(self)
        
        # Create tab widget
        self.tab_widget = QTabWidget()
        self.layout.addWidget(self.tab_widget)
        
        # Create tabs
        self._create_installed_tab()
        self._create_store_tab()
        self._create_developer_tab()
        
        # Create buttons
        self._create_buttons()
        
        # Load plugins
        self._load_plugins()
    
    def _create_installed_tab(self):
        """Create installed plugins tab."""
        installed_tab = QWidget()
        installed_layout = QVBoxLayout(installed_tab)
        
        # Create plugins table
        self.plugins_table = QTableWidget()
        self.plugins_table.setColumnCount(5)
        self.plugins_table.setHorizontalHeaderLabels(["Name", "Version", "Author", "Description", "Enabled"])
        self.plugins_table.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeMode.ResizeToContents)
        self.plugins_table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeMode.ResizeToContents)
        self.plugins_table.horizontalHeader().setSectionResizeMode(2, QHeaderView.ResizeMode.ResizeToContents)
        self.plugins_table.horizontalHeader().setSectionResizeMode(3, QHeaderView.ResizeMode.Stretch)
        self.plugins_table.horizontalHeader().setSectionResizeMode(4, QHeaderView.ResizeMode.ResizeToContents)
        self.plugins_table.setSelectionBehavior(QTableWidget.SelectionBehavior.SelectRows)
        self.plugins_table.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.plugins_table.customContextMenuRequested.connect(self._on_context_menu)
        self.plugins_table.itemDoubleClicked.connect(self._on_item_double_clicked)
        
        installed_layout.addWidget(self.plugins_table)
        
        # Add tab
        self.tab_widget.addTab(installed_tab, "Installed Plugins")
    
    def _create_store_tab(self):
        """Create plugin store tab."""
        store_tab = QWidget()
        store_layout = QVBoxLayout(store_tab)
        
        # Create store table
        self.store_table = QTableWidget()
        self.store_table.setColumnCount(5)
        self.store_table.setHorizontalHeaderLabels(["Name", "Version", "Author", "Description", "Action"])
        self.store_table.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeMode.ResizeToContents)
        self.store_table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeMode.ResizeToContents)
        self.store_table.horizontalHeader().setSectionResizeMode(2, QHeaderView.ResizeMode.ResizeToContents)
        self.store_table.horizontalHeader().setSectionResizeMode(3, QHeaderView.ResizeMode.Stretch)
        self.store_table.horizontalHeader().setSectionResizeMode(4, QHeaderView.ResizeMode.ResizeToContents)
        self.store_table.setSelectionBehavior(QTableWidget.SelectionBehavior.SelectRows)
        
        store_layout.addWidget(self.store_table)
        
        # Add tab
        self.tab_widget.addTab(store_tab, "Plugin Store")
    
    def _create_developer_tab(self):
        """Create developer tab."""
        developer_tab = QWidget()
        developer_layout = QVBoxLayout(developer_tab)
        
        # Create developer tools
        developer_layout.addWidget(QLabel("Plugin Development Tools"))
        
        # Create plugin API documentation
        api_label = QLabel("Plugin API Documentation:")
        developer_layout.addWidget(api_label)
        
        self.api_text = QTextEdit()
        self.api_text.setReadOnly(True)
        self.api_text.setPlainText(self._get_api_documentation())
        developer_layout.addWidget(self.api_text)
        
        # Create plugin template button
        template_button = QPushButton("Create Plugin Template")
        template_button.clicked.connect(self._on_create_template)
        developer_layout.addWidget(template_button)
        
        # Add tab
        self.tab_widget.addTab(developer_tab, "Developer")
    
    def _create_buttons(self):
        """Create dialog buttons."""
        button_layout = QHBoxLayout()
        
        # Install button
        self.install_button = QPushButton("Install from File...")
        self.install_button.clicked.connect(self._on_install_from_file)
        button_layout.addWidget(self.install_button)
        
        # Reload button
        self.reload_button = QPushButton("Reload All")
        self.reload_button.clicked.connect(self._on_reload_all)
        button_layout.addWidget(self.reload_button)
        
        # Spacer
        button_layout.addStretch()
        
        # Close button
        self.close_button = QPushButton("Close")
        self.close_button.clicked.connect(self.accept)
        button_layout.addWidget(self.close_button)
        
        self.layout.addLayout(button_layout)
    
    def _load_plugins(self):
        """Load plugins from plugin manager."""
        # Clear table
        self.plugins_table.setRowCount(0)
        
        # Get plugins
        plugins = self.app_controller.plugin_manager.get_plugins()
        
        # Add plugins to table
        for i, (plugin_id, plugin_info) in enumerate(plugins.items()):
            self.plugins_table.insertRow(i)
            
            # Get plugin details
            name = plugin_info.get("name", "Unknown Plugin")
            version = plugin_info.get("version", "1.0.0")
            author = plugin_info.get("author", "Unknown")
            description = plugin_info.get("description", "No description available")
            enabled = plugin_info.get("enabled", False)
            
            # Name
            name_item = QTableWidgetItem(name)
            name_item.setData(Qt.ItemDataRole.UserRole, plugin_id)
            self.plugins_table.setItem(i, 0, name_item)
            
            # Version
            version_item = QTableWidgetItem(version)
            self.plugins_table.setItem(i, 1, version_item)
            
            # Author
            author_item = QTableWidgetItem(author)
            self.plugins_table.setItem(i, 2, author_item)
            
            # Description
            description_item = QTableWidgetItem(description)
            self.plugins_table.setItem(i, 3, description_item)
            
            # Enabled
            enabled_check = QCheckBox()
            enabled_check.setChecked(enabled)
            enabled_check.stateChanged.connect(lambda state, pid=plugin_id: self._on_plugin_enabled_changed(pid, state))
            self.plugins_table.setCellWidget(i, 4, enabled_check)
        
        # Load store plugins
        self._load_store_plugins()
    
    def _load_store_plugins(self):
        """Load plugins from plugin store."""
        # Clear table
        self.store_table.setRowCount(0)
        
        # Get store plugins
        store_plugins = self.app_controller.plugin_manager.get_store_plugins()
        
        # Add plugins to table
        for i, plugin in enumerate(store_plugins):
            self.store_table.insertRow(i)
            
            # Get plugin details
            name = plugin.get("name", "Unknown Plugin")
            plugin_id = plugin.get("id", f"unknown_{i}")
            version = plugin.get("version", "1.0.0")
            author = plugin.get("author", "Unknown")
            
            # Name
            name_item = QTableWidgetItem(name)
            name_item.setData(Qt.ItemDataRole.UserRole, plugin_id)
            self.store_table.setItem(i, 0, name_item)
            
            # Version
            version_item = QTableWidgetItem(version)
            self.store_table.setItem(i, 1, version_item)
            
            # Author
            author_item = QTableWidgetItem(author)
            self.store_table.setItem(i, 2, author_item)
            
            # Description
            description_item = QTableWidgetItem(plugin["description"])
            self.store_table.setItem(i, 3, description_item)
            
            # Install button
            install_button = QPushButton("Install")
            install_button.clicked.connect(lambda checked=False, plugin_id=plugin["id"]: self._on_install_plugin(plugin_id))
            self.store_table.setCellWidget(i, 4, install_button)
    
    def _get_api_documentation(self):
        """Get plugin API documentation."""
        return """
NebulaFusion Plugin API Documentation

Plugin Structure:
- Each plugin must be a Python package with an __init__.py file
- The package must contain a manifest.json file with plugin metadata
- The __init__.py file must define a Plugin class that inherits from PluginBase

Manifest Format:
{
    "id": "unique_plugin_id",
    "name": "Plugin Name",
    "version": "1.0.0",
    "author": "Author Name",
    "description": "Plugin description",
    "permissions": ["tabs", "bookmarks", "history", "downloads", "cookies", "storage"]
}

Plugin Class:
class Plugin(PluginBase):
    def __init__(self, api):
        super().__init__(api)
        # Initialize plugin
    
    def activate(self):
        # Called when plugin is activated
        # Register hooks here
        return True
    
    def deactivate(self):
        # Called when plugin is deactivated
        # Unregister hooks here
        return True

Available Hooks:
- onBrowserStart: Called when browser starts
- onBrowserExit: Called when browser exits
- onTabCreated: Called when a new tab is created
- onTabClosed: Called when a tab is closed
- onTabSelected: Called when a tab is selected
- onPageLoading: Called when a page starts loading
- onPageLoaded: Called when a page finishes loading
- onUrlChanged: Called when URL changes
- onDownloadStarted: Called when a download starts
- onDownloadFinished: Called when a download finishes
- onBookmarkAdded: Called when a bookmark is added
- onBookmarkRemoved: Called when a bookmark is removed
- onHistoryAdded: Called when a history entry is added
- onContextMenu: Called when context menu is shown
- onToolbarCreated: Called when toolbar is created
- onSettingsChanged: Called when settings change
- onRealityAugmentation: Called when reality augmentation is activated
- onCollaborativeSession: Called when collaborative session is started
- onContentTransform: Called when content transformation is requested
- onTimeTravelSnapshot: Called when time travel snapshot is created
- onDimensionalTabChange: Called when dimensional tab changes
- onVoiceCommand: Called when voice command is received

Plugin API:
- tabs: Access to browser tabs
- bookmarks: Access to bookmarks
- history: Access to browsing history
- downloads: Access to downloads
- cookies: Access to cookies
- storage: Access to plugin storage
- settings: Access to browser settings
- ui: Access to browser UI elements
- hooks: Register and unregister hooks
- network: Make network requests
- filesystem: Access filesystem (sandboxed)
- reality: Access reality augmentation features
- collaboration: Access collaborative browsing features
- transformation: Access content transformation features
- timetravel: Access time-travel browsing features
- dimensions: Access dimensional tabs features
- voice: Access voice command features

For more detailed documentation, see the Plugin Developer Guide.
"""
    
    def _on_context_menu(self, pos):
        """Handle context menu event."""
        # Get selected items
        selected_items = self.plugins_table.selectedItems()
        if not selected_items:
            return
        
        # Create context menu
        menu = QMenu(self)
        
        # Enable action
        enable_action = QAction("Enable", menu)
        enable_action.triggered.connect(lambda: self._on_enable_plugin())
        menu.addAction(enable_action)
        
        # Disable action
        disable_action = QAction("Disable", menu)
        disable_action.triggered.connect(lambda: self._on_disable_plugin())
        menu.addAction(disable_action)
        
        menu.addSeparator()
        
        # Configure action
        configure_action = QAction("Configure", menu)
        configure_action.triggered.connect(lambda: self._on_configure_plugin())
        menu.addAction(configure_action)
        
        # Reload action
        reload_action = QAction("Reload", menu)
        reload_action.triggered.connect(lambda: self._on_reload_plugin())
        menu.addAction(reload_action)
        
        menu.addSeparator()
        
        # Uninstall action
        uninstall_action = QAction("Uninstall", menu)
        uninstall_action.triggered.connect(lambda: self._on_uninstall_plugin())
        menu.addAction(uninstall_action)
        
        # Show menu
        menu.exec(self.plugins_table.mapToGlobal(pos))
    
    def _on_item_double_clicked(self, item):
        """Handle item double clicked event."""
        # Configure plugin
        self._on_configure_plugin()
    
    def _on_enable_plugin(self):
        """Handle enable plugin action."""
        # Get selected rows
        selected_rows = set(item.row() for item in self.plugins_table.selectedItems())
        if not selected_rows:
            return
        
        # Enable plugins
        for row in selected_rows:
            plugin_id = self.plugins_table.item(row, 0).data(Qt.ItemDataRole.UserRole)
            self.app_controller.plugin_manager.enable_plugin(plugin_id)
            
            # Update checkbox
            enabled_check = self.plugins_table.cellWidget(row, 4)
            if enabled_check:
                enabled_check.setChecked(True)
    
    def _on_disable_plugin(self):
        """Handle disable plugin action."""
        # Get selected rows
        selected_rows = set(item.row() for item in self.plugins_table.selectedItems())
        if not selected_rows:
            return
        
        # Disable plugins
        for row in selected_rows:
            plugin_id = self.plugins_table.item(row, 0).data(Qt.ItemDataRole.UserRole)
            self.app_controller.plugin_manager.disable_plugin(plugin_id)
            
            # Update checkbox
            enabled_check = self.plugins_table.cellWidget(row, 4)
            if enabled_check:
                enabled_check.setChecked(False)
    
    def _on_configure_plugin(self):
        """Handle configure plugin action."""
        # Get selected row
        selected_rows = set(item.row() for item in self.plugins_table.selectedItems())
        if not selected_rows:
            return
        
        # Get plugin ID from first selected row
        row = list(selected_rows)[0]
        plugin_id = self.plugins_table.item(row, 0).data(Qt.ItemDataRole.UserRole)
        
        # Configure plugin
        self.app_controller.plugin_manager.configure_plugin(plugin_id)
    
    def _on_reload_plugin(self):
        """Handle reload plugin action."""
        # Get selected rows
        selected_rows = set(item.row() for item in self.plugins_table.selectedItems())
        if not selected_rows:
            return
        
        # Reload plugins
        for row in selected_rows:
            plugin_id = self.plugins_table.item(row, 0).data(Qt.ItemDataRole.UserRole)
            self.app_controller.plugin_manager.reload_plugin(plugin_id)
    
    def _on_uninstall_plugin(self):
        """Handle uninstall plugin action."""
        # Get selected rows
        selected_rows = set(item.row() for item in self.plugins_table.selectedItems())
        if not selected_rows:
            return
        
        # Confirm uninstallation
        result = QMessageBox.question(
            self,
            "Uninstall Plugins",
            f"Are you sure you want to uninstall {len(selected_rows)} plugins?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )
        
        if result == QMessageBox.StandardButton.Yes:
            # Uninstall plugins
            for row in sorted(selected_rows, reverse=True):
                plugin_id = self.plugins_table.item(row, 0).data(Qt.ItemDataRole.UserRole)
                self.app_controller.plugin_manager.uninstall_plugin(plugin_id)
                self.plugins_table.removeRow(row)
    
    def _on_plugin_enabled_changed(self, plugin_id, state):
        """Handle plugin enabled state changed event."""
        # Enable or disable plugin
        if state == Qt.CheckState.Checked:
            self.app_controller.plugin_manager.enable_plugin(plugin_id)
        else:
            self.app_controller.plugin_manager.disable_plugin(plugin_id)
    
    def _on_install_from_file(self):
        """Handle install from file button click."""
        # Show file dialog
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Install Plugin",
            "",
            "Python Packages (*.zip *.whl);;All Files (*.*)"
        )
        
        if file_path:
            # Install plugin
            success = self.app_controller.plugin_manager.install_plugin(file_path)
            
            if success:
                # Reload plugins
                self._load_plugins()
                
                # Show success message
                QMessageBox.information(
                    self,
                    "Plugin Installed",
                    "Plugin installed successfully.",
                    QMessageBox.StandardButton.Ok
                )
            else:
                # Show error message
                QMessageBox.critical(
                    self,
                    "Installation Failed",
                    "Failed to install plugin.",
                    QMessageBox.StandardButton.Ok
                )
    
    def _on_reload_all(self):
        """Handle reload all button click."""
        # Reload all plugins
        self.app_controller.plugin_manager.reload_all_plugins()
        
        # Reload plugins
        self._load_plugins()
    
    def _on_install_plugin(self, plugin_id):
        """Handle install plugin button click."""
        # Install plugin
        success = self.app_controller.plugin_manager.install_store_plugin(plugin_id)
        
        if success:
            # Reload plugins
            self._load_plugins()
            
            # Show success message
            QMessageBox.information(
                self,
                "Plugin Installed",
                "Plugin installed successfully.",
                QMessageBox.StandardButton.Ok
            )
        else:
            # Show error message
            QMessageBox.critical(
                self,
                "Installation Failed",
                "Failed to install plugin.",
                QMessageBox.StandardButton.Ok
            )
    
    def _on_create_template(self):
        """Handle create template button click."""
        # Show file dialog
        directory = QFileDialog.getExistingDirectory(
            self,
            "Select Plugin Directory",
            ""
        )
        
        if directory:
            # Create plugin template
            success = self.app_controller.plugin_manager.create_plugin_template(directory)
            
            if success:
                # Show success message
                QMessageBox.information(
                    self,
                    "Template Created",
                    f"Plugin template created in {directory}.",
                    QMessageBox.StandardButton.Ok
                )
            else:
                # Show error message
                QMessageBox.critical(
                    self,
                    "Template Creation Failed",
                    "Failed to create plugin template.",
                    QMessageBox.StandardButton.Ok
                )
</file>

<file path="src/ui/settings_dialog.py">
#!/usr/bin/env python3
# NebulaFusion Browser - Settings Dialog

import os
import sys
from PyQt6.QtWidgets import (
    QDialog,
    QTabWidget,
    QVBoxLayout,
    QHBoxLayout,
    QLabel,
    QLineEdit,
    QCheckBox,
    QComboBox,
    QPushButton,
    QFileDialog,
    QGroupBox,
    QFormLayout,
    QSpinBox,
    QListWidget,
    QListWidgetItem,
    QWidget,
)
from PyQt6.QtCore import Qt, pyqtSignal, QSize
from PyQt6.QtGui import QIcon


class SettingsDialog(QDialog):
    """
    Settings dialog for browser configuration.
    """

    def __init__(self, app_controller):
        """Initialize the settings dialog."""
        super().__init__()
        self.app_controller = app_controller

        # Set properties
        self.setWindowTitle("NebulaFusion Settings")
        self.setMinimumSize(600, 500)

        # Create layout
        self.layout = QVBoxLayout(self)

        # Create tab widget
        self.tab_widget = QTabWidget()
        self.layout.addWidget(self.tab_widget)

        # Create tabs
        self._create_general_tab()
        self._create_privacy_tab()
        self._create_security_tab()
        self._create_downloads_tab()
        self._create_appearance_tab()
        self._create_advanced_tab()
        self._create_unique_features_tab()

        # Create buttons
        self._create_buttons()

        # Load settings
        self._load_settings()

    def _create_general_tab(self):
        """Create general settings tab."""
        general_tab = QWidget()
        general_layout = QVBoxLayout(general_tab)

        # Startup group
        startup_group = QGroupBox("Startup")
        startup_layout = QFormLayout(startup_group)

        # Home page
        self.home_page_edit = QLineEdit()
        startup_layout.addRow("Home page:", self.home_page_edit)

        # Restore session
        self.restore_session_check = QCheckBox("Restore previous session on startup")
        startup_layout.addRow("", self.restore_session_check)

        general_layout.addWidget(startup_group)

        # Search group
        search_group = QGroupBox("Search")
        search_layout = QFormLayout(search_group)

        # Default search engine
        self.search_engine_combo = QComboBox()
        self.search_engine_combo.addItems(["Google", "Bing", "DuckDuckGo"])
        search_layout.addRow("Default search engine:", self.search_engine_combo)

        general_layout.addWidget(search_group)

        # Features group
        features_group = QGroupBox("Features")
        features_layout = QFormLayout(features_group)

        # JavaScript
        self.javascript_check = QCheckBox("Enable JavaScript")
        features_layout.addRow("", self.javascript_check)

        # Plugins
        self.plugins_check = QCheckBox("Enable plugins")
        features_layout.addRow("", self.plugins_check)

        general_layout.addWidget(features_group)

        # Add tab
        self.tab_widget.addTab(general_tab, "General")

    def _create_privacy_tab(self):
        """Create privacy settings tab."""
        privacy_tab = QWidget()
        privacy_layout = QVBoxLayout(privacy_tab)

        # Browsing history group
        history_group = QGroupBox("Browsing History")
        history_layout = QFormLayout(history_group)

        # Clear history on exit
        self.clear_history_check = QCheckBox("Clear history when browser closes")
        history_layout.addRow("", self.clear_history_check)

        # Clear history button
        self.clear_history_button = QPushButton("Clear Browsing History...")
        self.clear_history_button.clicked.connect(self._on_clear_history)
        history_layout.addRow("", self.clear_history_button)

        privacy_layout.addWidget(history_group)

        # Cookies group
        cookies_group = QGroupBox("Cookies")
        cookies_layout = QFormLayout(cookies_group)

        # Enable cookies
        self.cookies_check = QCheckBox("Enable cookies")
        cookies_layout.addRow("", self.cookies_check)

        # Block third-party cookies
        self.third_party_cookies_check = QCheckBox("Block third-party cookies")
        cookies_layout.addRow("", self.third_party_cookies_check)

        # Clear cookies on exit
        self.clear_cookies_check = QCheckBox("Clear cookies when browser closes")
        cookies_layout.addRow("", self.clear_cookies_check)

        # Clear cookies button
        self.clear_cookies_button = QPushButton("Clear Cookies...")
        self.clear_cookies_button.clicked.connect(self._on_clear_cookies)
        cookies_layout.addRow("", self.clear_cookies_button)

        privacy_layout.addWidget(cookies_group)

        # Tracking group
        tracking_group = QGroupBox("Tracking")
        tracking_layout = QFormLayout(tracking_group)

        # Do not track
        self.do_not_track_check = QCheckBox(
            'Send "Do Not Track" request with browsing traffic'
        )
        tracking_layout.addRow("", self.do_not_track_check)

        # Block trackers
        self.block_trackers_check = QCheckBox("Block known trackers")
        tracking_layout.addRow("", self.block_trackers_check)

        privacy_layout.addWidget(tracking_group)

        # Add tab
        self.tab_widget.addTab(privacy_tab, "Privacy")

    def _create_security_tab(self):
        """Create security settings tab."""
        security_tab = QWidget()
        security_layout = QVBoxLayout(security_tab)

        # Protection group
        protection_group = QGroupBox("Protection")
        protection_layout = QFormLayout(protection_group)

        # Block malicious sites
        self.block_malicious_check = QCheckBox("Block dangerous and deceptive sites")
        protection_layout.addRow("", self.block_malicious_check)

        # Warn on insecure forms
        self.warn_insecure_forms_check = QCheckBox(
            "Warn about password entry on non-secure pages"
        )
        protection_layout.addRow("", self.warn_insecure_forms_check)

        # Phishing protection
        self.phishing_protection_check = QCheckBox("Enable phishing protection")
        protection_layout.addRow("", self.phishing_protection_check)

        # XSS protection
        self.xss_protection_check = QCheckBox(
            "Enable cross-site scripting (XSS) protection"
        )
        protection_layout.addRow("", self.xss_protection_check)

        # Content verification
        self.content_verification_check = QCheckBox(
            "Verify content integrity when possible"
        )
        protection_layout.addRow("", self.content_verification_check)

        security_layout.addWidget(protection_group)

        # Plugin security group
        plugin_security_group = QGroupBox("Plugin Security")
        plugin_security_layout = QFormLayout(plugin_security_group)

        # Plugin sandboxing
        self.plugin_sandbox_check = QCheckBox("Enable plugin sandboxing")
        plugin_security_layout.addRow("", self.plugin_sandbox_check)

        # Plugin CPU limit
        self.plugin_cpu_spin = QSpinBox()
        self.plugin_cpu_spin.setRange(1, 100)
        self.plugin_cpu_spin.setSuffix("%")
        plugin_security_layout.addRow("Plugin CPU limit:", self.plugin_cpu_spin)

        # Plugin memory limit
        self.plugin_memory_spin = QSpinBox()
        self.plugin_memory_spin.setRange(10, 1000)
        self.plugin_memory_spin.setSuffix(" MB")
        plugin_security_layout.addRow("Plugin memory limit:", self.plugin_memory_spin)

        # Plugin network limit
        self.plugin_network_spin = QSpinBox()
        self.plugin_network_spin.setRange(10, 1000)
        self.plugin_network_spin.setSuffix(" requests/min")
        plugin_security_layout.addRow("Plugin network limit:", self.plugin_network_spin)

        security_layout.addWidget(plugin_security_group)

        # Add tab
        self.tab_widget.addTab(security_tab, "Security")

    def _create_downloads_tab(self):
        """Create downloads settings tab."""
        downloads_tab = QWidget()
        downloads_layout = QVBoxLayout(downloads_tab)

        # Downloads group
        downloads_group = QGroupBox("Downloads")
        downloads_layout_group = QFormLayout(downloads_group)

        # Download location
        self.download_location_edit = QLineEdit()
        self.download_location_button = QPushButton("Browse...")
        self.download_location_button.clicked.connect(self._on_browse_download_location)

        download_location_layout = QHBoxLayout()
        download_location_layout.addWidget(self.download_location_edit)
        download_location_layout.addWidget(self.download_location_button)

        downloads_layout_group.addRow("Download location:", download_location_layout)

        # Ask before download
        self.ask_download_check = QCheckBox(
            "Ask where to save each file before downloading"
        )
        downloads_layout_group.addRow("", self.ask_download_check)

        # Open after download
        self.open_download_check = QCheckBox("Open files after downloading")
        downloads_layout_group.addRow("", self.open_download_check)

        downloads_layout.addWidget(downloads_group)

        # Add tab
        self.tab_widget.addTab(downloads_tab, "Downloads")

    def _create_appearance_tab(self):
        """Create appearance settings tab."""
        appearance_tab = QWidget()
        appearance_layout = QVBoxLayout(appearance_tab)

        # Theme group
        theme_group = QGroupBox("Theme")
        theme_layout = QFormLayout(theme_group)

        # Theme selection
        self.theme_combo = QComboBox()
        for theme_name in self.app_controller.theme_manager.available_themes:
            self.theme_combo.addItem(theme_name.capitalize(), theme_name)

        theme_layout.addRow("Theme:", self.theme_combo)

        appearance_layout.addWidget(theme_group)

        # UI elements group
        ui_group = QGroupBox("UI Elements")
        ui_layout = QFormLayout(ui_group)

        # Show bookmarks bar
        self.bookmarks_bar_check = QCheckBox("Show bookmarks bar")
        ui_layout.addRow("", self.bookmarks_bar_check)

        # Show status bar
        self.status_bar_check = QCheckBox("Show status bar")
        ui_layout.addRow("", self.status_bar_check)

        # Show tab previews
        self.tab_previews_check = QCheckBox("Show tab previews on hover")
        ui_layout.addRow("", self.tab_previews_check)

        # Tab position
        self.tab_position_combo = QComboBox()
        self.tab_position_combo.addItems(["Top", "Bottom", "Left", "Right"])
        ui_layout.addRow("Tab position:", self.tab_position_combo)

        # Toolbar style
        self.toolbar_style_combo = QComboBox()
        self.toolbar_style_combo.addItems(["Icon Only", "Text Only", "Icon and Text"])
        ui_layout.addRow("Toolbar style:", self.toolbar_style_combo)

        appearance_layout.addWidget(ui_group)

        # Add tab
        self.tab_widget.addTab(appearance_tab, "Appearance")

    def _create_advanced_tab(self):
        """Create advanced settings tab."""
        advanced_tab = QWidget()
        advanced_layout = QVBoxLayout(advanced_tab)

        # Cache group
        cache_group = QGroupBox("Cache")
        cache_layout = QFormLayout(cache_group)

        # Cache size
        self.cache_size_spin = QSpinBox()
        self.cache_size_spin.setRange(10, 1000)
        self.cache_size_spin.setSuffix(" MB")
        cache_layout.addRow("Cache size:", self.cache_size_spin)

        # Clear cache button
        self.clear_cache_button = QPushButton("Clear Cache...")
        self.clear_cache_button.clicked.connect(self._on_clear_cache)
        cache_layout.addRow("", self.clear_cache_button)

        advanced_layout.addWidget(cache_group)

        # Plugins group
        plugins_group = QGroupBox("Plugins")
        plugins_layout = QFormLayout(plugins_group)

        # Plugin directory
        self.plugin_directory_edit = QLineEdit()
        self.plugin_directory_button = QPushButton("Browse...")
        self.plugin_directory_button.clicked.connect(self._on_browse_plugin_directory)

        plugin_directory_layout = QHBoxLayout()
        plugin_directory_layout.addWidget(self.plugin_directory_edit)
        plugin_directory_layout.addWidget(self.plugin_directory_button)

        plugins_layout.addRow("Plugin directory:", plugin_directory_layout)

        advanced_layout.addWidget(plugins_group)

        # Developer group
        developer_group = QGroupBox("Developer")
        developer_layout = QFormLayout(developer_group)

        # Developer tools
        self.developer_tools_check = QCheckBox("Enable developer tools")
        developer_layout.addRow("", self.developer_tools_check)

        # Experimental features
        self.experimental_features_check = QCheckBox("Enable experimental features")
        developer_layout.addRow("", self.experimental_features_check)

        # Log level
        self.log_level_combo = QComboBox()
        self.log_level_combo.addItems(["Debug", "Info", "Warning", "Error"])
        developer_layout.addRow("Log level:", self.log_level_combo)

        advanced_layout.addWidget(developer_group)

        # Add tab
        self.tab_widget.addTab(advanced_tab, "Advanced")

    def _create_unique_features_tab(self):
        """Create unique features settings tab."""
        unique_tab = QWidget()
        unique_layout = QVBoxLayout(unique_tab)

        # Reality Augmentation group
        reality_group = QGroupBox("Reality Augmentation")
        reality_layout = QFormLayout(reality_group)

        # Enable Reality Augmentation
        self.reality_augmentation_check = QCheckBox("Enable Reality Augmentation")
        reality_layout.addRow("", self.reality_augmentation_check)

        unique_layout.addWidget(reality_group)

        # Collaborative Browsing group
        collaborative_group = QGroupBox("Collaborative Browsing")
        collaborative_layout = QFormLayout(collaborative_group)

        # Enable Collaborative Browsing
        self.collaborative_browsing_check = QCheckBox("Enable Collaborative Browsing")
        collaborative_layout.addRow("", self.collaborative_browsing_check)

        unique_layout.addWidget(collaborative_group)

        # Content Transformation group
        transform_group = QGroupBox("Content Transformation")
        transform_layout = QFormLayout(transform_group)

        # Enable Content Transformation
        self.content_transformation_check = QCheckBox("Enable Content Transformation")
        transform_layout.addRow("", self.content_transformation_check)

        unique_layout.addWidget(transform_group)

        # Time-Travel Browsing group
        time_travel_group = QGroupBox("Time-Travel Browsing")
        time_travel_layout = QFormLayout(time_travel_group)

        # Enable Time-Travel Browsing
        self.time_travel_check = QCheckBox("Enable Time-Travel Browsing")
        time_travel_layout.addRow("", self.time_travel_check)

        unique_layout.addWidget(time_travel_group)

        # Dimensional Tabs group
        dimensional_group = QGroupBox("Dimensional Tabs")
        dimensional_layout = QFormLayout(dimensional_group)

        # Enable Dimensional Tabs
        self.dimensional_tabs_check = QCheckBox("Enable Dimensional Tabs")
        dimensional_layout.addRow("", self.dimensional_tabs_check)

        unique_layout.addWidget(dimensional_group)

        # Voice Commands group
        voice_group = QGroupBox("Voice Commands")
        voice_layout = QFormLayout(voice_group)

        # Enable Voice Commands
        self.voice_commands_check = QCheckBox("Enable Voice Commands")
        voice_layout.addRow("", self.voice_commands_check)

        unique_layout.addWidget(voice_group)

        # Add tab
        self.tab_widget.addTab(unique_tab, "Unique Features")

    def _create_buttons(self):
        """Create dialog buttons."""
        button_layout = QHBoxLayout()

        # Reset button
        self.reset_button = QPushButton("Reset to Defaults")
        self.reset_button.clicked.connect(self._on_reset)
        button_layout.addWidget(self.reset_button)

        # Spacer
        button_layout.addStretch()

        # Cancel button
        self.cancel_button = QPushButton("Cancel")
        self.cancel_button.clicked.connect(self.reject)
        button_layout.addWidget(self.cancel_button)

        # Save button
        self.save_button = QPushButton("Save")
        self.save_button.clicked.connect(self._on_save)
        self.save_button.setDefault(True)
        button_layout.addWidget(self.save_button)

        self.layout.addLayout(button_layout)

    def _load_settings(self):
        """Load settings from settings manager."""
        settings = self.app_controller.settings_manager.default_settings

        # General settings
        self.home_page_edit.setText(settings.get("home_page", ""))
        self.restore_session_check.setChecked(settings.get("restore_session", True))

        search_engine = settings.get("default_search_engine", "google")
        if search_engine == "google":
            self.search_engine_combo.setCurrentIndex(0)
        elif search_engine == "bing":
            self.search_engine_combo.setCurrentIndex(1)
        elif search_engine == "duckduckgo":
            self.search_engine_combo.setCurrentIndex(2)

        self.javascript_check.setChecked(settings.get("enable_javascript", True))
        self.plugins_check.setChecked(settings.get("enable_plugins", True))

        # Privacy settings
        self.clear_history_check.setChecked(
            settings.get("clear_history_on_exit", False)
        )
        self.cookies_check.setChecked(settings.get("enable_cookies", True))
        self.third_party_cookies_check.setChecked(
            settings.get("block_third_party_cookies", False)
        )
        self.clear_cookies_check.setChecked(
            settings.get("clear_cookies_on_exit", False)
        )
        self.do_not_track_check.setChecked(settings.get("do_not_track", False))
        self.block_trackers_check.setChecked(settings.get("block_trackers", False))

        # Security settings
        self.block_malicious_check.setChecked(
            settings.get("security_block_malicious_sites", True)
        )
        self.warn_insecure_forms_check.setChecked(
            settings.get("security_warn_on_insecure_forms", True)
        )
        self.phishing_protection_check.setChecked(
            settings.get("security_enable_phishing_protection", True)
        )
        self.xss_protection_check.setChecked(
            settings.get("security_enable_xss_protection", True)
        )
        self.content_verification_check.setChecked(
            settings.get("security_enable_content_verification", True)
        )
        self.plugin_sandbox_check.setChecked(
            settings.get("security_plugin_sandbox_enabled", True)
        )
        self.plugin_cpu_spin.setValue(settings.get("security_plugin_cpu_percent", 10))
        self.plugin_memory_spin.setValue(settings.get("security_plugin_memory_mb", 100))
        self.plugin_network_spin.setValue(
            settings.get("security_plugin_network_requests_per_minute", 60)
        )

        # Downloads settings
        self.download_location_edit.setText(settings.get("download_directory", ""))
        self.ask_download_check.setChecked(settings.get("ask_before_download", True))
        self.open_download_check.setChecked(settings.get("open_after_download", False))

        # Appearance settings
        theme = settings.get("theme", "default")
        for i in range(self.theme_combo.count()):
            if self.theme_combo.itemData(i) == theme:
                self.theme_combo.setCurrentIndex(i)
                break

        self.bookmarks_bar_check.setChecked(settings.get("show_bookmarks_bar", True))
        self.status_bar_check.setChecked(settings.get("show_status_bar", True))
        self.tab_previews_check.setChecked(settings.get("show_tab_previews", True))

        tab_position = settings.get("tab_position", "top")
        if tab_position == "top":
            self.tab_position_combo.setCurrentIndex(0)
        elif tab_position == "bottom":
            self.tab_position_combo.setCurrentIndex(1)
        elif tab_position == "left":
            self.tab_position_combo.setCurrentIndex(2)
        elif tab_position == "right":
            self.tab_position_combo.setCurrentIndex(3)

        toolbar_style = settings.get("toolbar_style", "icon_text")
        if toolbar_style == "icon":
            self.toolbar_style_combo.setCurrentIndex(0)
        elif toolbar_style == "text":
            self.toolbar_style_combo.setCurrentIndex(1)
        elif toolbar_style == "icon_text":
            self.toolbar_style_combo.setCurrentIndex(2)

        # Advanced settings
        self.cache_size_spin.setValue(settings.get("cache_size_mb", 100))
        self.plugin_directory_edit.setText(settings.get("plugin_directory", ""))
        self.developer_tools_check.setChecked(
            settings.get("enable_developer_tools", False)
        )
        self.experimental_features_check.setChecked(
            settings.get("enable_experimental_features", False)
        )

        log_level = settings.get("log_level", "info")
        if log_level == "debug":
            self.log_level_combo.setCurrentIndex(0)
        elif log_level == "info":
            self.log_level_combo.setCurrentIndex(1)
        elif log_level == "warning":
            self.log_level_combo.setCurrentIndex(2)
        elif log_level == "error":
            self.log_level_combo.setCurrentIndex(3)

        # Unique features settings
        self.reality_augmentation_check.setChecked(
            settings.get("enable_reality_augmentation", True)
        )
        self.collaborative_browsing_check.setChecked(
            settings.get("enable_collaborative_browsing", True)
        )
        self.content_transformation_check.setChecked(
            settings.get("enable_content_transformation", True)
        )
        self.time_travel_check.setChecked(settings.get("enable_time_travel", True))
        self.dimensional_tabs_check.setChecked(
            settings.get("enable_dimensional_tabs", True)
        )
        self.voice_commands_check.setChecked(
            settings.get("enable_voice_commands", True)
        )

    def _save_settings(self):
        """Save settings to settings manager."""
        # General settings
        self.app_controller.settings_manager.set_setting(
            "home_page", self.home_page_edit.text()
        )
        self.app_controller.settings_manager.set_setting(
            "restore_session", self.restore_session_check.isChecked()
        )

        search_engine_index = self.search_engine_combo.currentIndex()
        if search_engine_index == 0:
            self.app_controller.settings_manager.set_setting(
                "default_search_engine", "google"
            )
        elif search_engine_index == 1:
            self.app_controller.settings_manager.set_setting(
                "default_search_engine", "bing"
            )
        elif search_engine_index == 2:
            self.app_controller.settings_manager.set_setting(
                "default_search_engine", "duckduckgo"
            )

        self.app_controller.settings_manager.set_setting(
            "enable_javascript", self.javascript_check.isChecked()
        )
        self.app_controller.settings_manager.set_setting(
            "enable_plugins", self.plugins_check.isChecked()
        )

        # Privacy settings
        self.app_controller.settings_manager.set_setting(
            "clear_history_on_exit", self.clear_history_check.isChecked()
        )
        self.app_controller.settings_manager.set_setting(
            "enable_cookies", self.cookies_check.isChecked()
        )
        self.app_controller.settings_manager.set_setting(
            "block_third_party_cookies", self.third_party_cookies_check.isChecked()
        )
        self.app_controller.settings_manager.set_setting(
            "clear_cookies_on_exit", self.clear_cookies_check.isChecked()
        )
        self.app_controller.settings_manager.set_setting(
            "do_not_track", self.do_not_track_check.isChecked()
        )
        self.app_controller.settings_manager.set_setting(
            "block_trackers", self.block_trackers_check.isChecked()
        )

        # Security settings
        self.app_controller.settings_manager.set_setting(
            "security_block_malicious_sites", self.block_malicious_check.isChecked()
        )
        self.app_controller.settings_manager.set_setting(
            "security_warn_on_insecure_forms",
            self.warn_insecure_forms_check.isChecked(),
        )
        self.app_controller.settings_manager.set_setting(
            "security_enable_phishing_protection",
            self.phishing_protection_check.isChecked(),
        )
        self.app_controller.settings_manager.set_setting(
            "security_enable_xss_protection", self.xss_protection_check.isChecked()
        )
        self.app_controller.settings_manager.set_setting(
            "security_enable_content_verification",
            self.content_verification_check.isChecked(),
        )
        self.app_controller.settings_manager.set_setting(
            "security_plugin_sandbox_enabled", self.plugin_sandbox_check.isChecked()
        )
        self.app_controller.settings_manager.set_setting(
            "security_plugin_cpu_percent", self.plugin_cpu_spin.value()
        )
        self.app_controller.settings_manager.set_setting(
            "security_plugin_memory_mb", self.plugin_memory_spin.value()
        )
        self.app_controller.settings_manager.set_setting(
            "security_plugin_network_requests_per_minute",
            self.plugin_network_spin.value(),
        )

        # Downloads settings
        self.app_controller.settings_manager.set_setting(
            "download_directory", self.download_location_edit.text()
        )
        self.app_controller.settings_manager.set_setting(
            "ask_before_download", self.ask_download_check.isChecked()
        )
        self.app_controller.settings_manager.set_setting(
            "open_after_download", self.open_download_check.isChecked()
        )

        # Appearance settings
        theme_index = self.theme_combo.currentIndex()
        if theme_index >= 0:
            self.app_controller.settings_manager.set_setting(
                "theme", self.theme_combo.itemData(theme_index)
            )

        self.app_controller.settings_manager.set_setting(
            "show_bookmarks_bar", self.bookmarks_bar_check.isChecked()
        )
        self.app_controller.settings_manager.set_setting(
            "show_status_bar", self.status_bar_check.isChecked()
        )
        self.app_controller.settings_manager.set_setting(
            "show_tab_previews", self.tab_previews_check.isChecked()
        )

        tab_position_index = self.tab_position_combo.currentIndex()
        if tab_position_index == 0:
            self.app_controller.settings_manager.set_setting("tab_position", "top")
        elif tab_position_index == 1:
            self.app_controller.settings_manager.set_setting("tab_position", "bottom")
        elif tab_position_index == 2:
            self.app_controller.settings_manager.set_setting("tab_position", "left")
        elif tab_position_index == 3:
            self.app_controller.settings_manager.set_setting("tab_position", "right")

        toolbar_style_index = self.toolbar_style_combo.currentIndex()
        if toolbar_style_index == 0:
            self.app_controller.settings_manager.set_setting("toolbar_style", "icon")
        elif toolbar_style_index == 1:
            self.app_controller.settings_manager.set_setting("toolbar_style", "text")
        elif toolbar_style_index == 2:
            self.app_controller.settings_manager.set_setting(
                "toolbar_style", "icon_text"
            )

        # Advanced settings
        self.app_controller.settings_manager.set_setting(
            "cache_size_mb", self.cache_size_spin.value()
        )
        self.app_controller.settings_manager.set_setting(
            "plugin_directory", self.plugin_directory_edit.text()
        )
        self.app_controller.settings_manager.set_setting(
            "enable_developer_tools", self.developer_tools_check.isChecked()
        )
        self.app_controller.settings_manager.set_setting(
            "enable_experimental_features", self.experimental_features_check.isChecked()
        )

        log_level_index = self.log_level_combo.currentIndex()
        if log_level_index == 0:
            self.app_controller.settings_manager.set_setting("log_level", "debug")
        elif log_level_index == 1:
            self.app_controller.settings_manager.set_setting("log_level", "info")
        elif log_level_index == 2:
            self.app_controller.settings_manager.set_setting("log_level", "warning")
        elif log_level_index == 3:
            self.app_controller.settings_manager.set_setting("log_level", "error")

        # Unique features settings
        self.app_controller.settings_manager.set_setting(
            "enable_reality_augmentation", self.reality_augmentation_check.isChecked()
        )
        self.app_controller.settings_manager.set_setting(
            "enable_collaborative_browsing",
            self.collaborative_browsing_check.isChecked(),
        )
        self.app_controller.settings_manager.set_setting(
            "enable_content_transformation",
            self.content_transformation_check.isChecked(),
        )
        self.app_controller.settings_manager.set_setting(
            "enable_time_travel", self.time_travel_check.isChecked()
        )
        self.app_controller.settings_manager.set_setting(
            "enable_dimensional_tabs", self.dimensional_tabs_check.isChecked()
        )
        self.app_controller.settings_manager.set_setting(
            "enable_voice_commands", self.voice_commands_check.isChecked()
        )

    def _on_browse_download_location(self):
        """Handle browse download location button click."""
        directory = QFileDialog.getExistingDirectory(
            self, "Select Download Location", self.download_location_edit.text()
        )

        if directory:
            self.download_location_edit.setText(directory)

    def _on_browse_plugin_directory(self):
        """Handle browse plugin directory button click."""
        directory = QFileDialog.getExistingDirectory(
            self, "Select Plugin Directory", self.plugin_directory_edit.text()
        )

        if directory:
            self.plugin_directory_edit.setText(directory)

    def _on_clear_history(self):
        """Handle clear history button click."""
        self.app_controller.history_manager.clear_history()

    def _on_clear_cookies(self):
        """Handle clear cookies button click."""
        self.app_controller.cookies_manager.clear_cookies()

    def _on_clear_cache(self):
        """Handle clear cache button click."""
        self.app_controller.web_engine_manager.clear_cache()

    def _on_reset(self):
        """Handle reset button click."""
        self.app_controller.settings_manager.reset_all_settings()
        self._load_settings()

    def _on_save(self):
        """Handle save button click."""
        self._save_settings()
        self.accept()
</file>

<file path="src/ui/status_bar.py">
#!/usr/bin/env python3
# NebulaFusion Browser - Status Bar

import os
import sys
from PyQt6.QtWidgets import QStatusBar, QLabel, QProgressBar
from PyQt6.QtCore import Qt, pyqtSignal

class StatusBar(QStatusBar):
    """
    Status bar for browser status information.
    """
    
    def __init__(self, app_controller):
        """Initialize the status bar."""
        super().__init__()
        self.app_controller = app_controller
        
        # Create widgets
        self._create_widgets()
        
        # Connect signals
        self._connect_signals()
    
    def _create_widgets(self):
        """Create status bar widgets."""
        # URL label
        self.url_label = QLabel()
        self.url_label.setTextFormat(Qt.TextFormat.RichText)
        self.addWidget(self.url_label, 1)
        
        # Progress bar
        self.progress_bar = QProgressBar()
        self.progress_bar.setMaximumHeight(12)
        self.progress_bar.setMaximumWidth(100)
        self.progress_bar.setVisible(False)
        self.addPermanentWidget(self.progress_bar)
        
        # Security label
        self.security_label = QLabel()
        self.addPermanentWidget(self.security_label)
        
        # Download label
        self.download_label = QLabel()
        self.addPermanentWidget(self.download_label)
    
    def _connect_signals(self):
        """Connect signals."""
        pass
    
    def on_page_loading(self):
        """Handle page loading event."""
        # Show progress bar
        self.progress_bar.setValue(0)
        self.progress_bar.setVisible(True)
        
        # Update status
        self.showMessage("Loading...")
    
    def on_page_loaded(self, success):
        """Handle page loaded event."""
        # Hide progress bar
        self.progress_bar.setVisible(False)
        
        # Update status
        if success:
            self.showMessage("Page loaded", 5000)
        else:
            self.showMessage("Failed to load page", 5000)
    
    def on_page_load_progress(self, progress):
        """Handle page load progress event."""
        # Update progress bar
        self.progress_bar.setValue(progress)
    
    def on_url_changed(self, url):
        """Handle URL changed event."""
        # Update URL label
        self.url_label.setText(f"<small>{url.toString()}</small>")
    
    def on_security_changed(self, security_status):
        """Handle security changed event."""
        # Update security label
        if security_status["is_secure"]:
            self.security_label.setText("🔒 Secure")
            self.security_label.setToolTip("Connection is secure")
        else:
            self.security_label.setText("🔓 Not Secure")
            self.security_label.setToolTip(security_status.get("message", "Connection is not secure"))
    
    def on_download_started(self, download_id, url, path):
        """Handle download started event."""
        # Update download label
        self.download_label.setText("⬇️ Downloading...")
        self.download_label.setToolTip(f"Downloading {os.path.basename(path)}")
    
    def on_download_progress(self, download_id, received, total):
        """Handle download progress event."""
        # Update download label
        if total > 0:
            percent = int(received * 100 / total)
            self.download_label.setText(f"⬇️ {percent}%")
            self.download_label.setToolTip(f"Downloaded {received} of {total} bytes")
    
    def on_download_finished(self, download_id, success):
        """Handle download finished event."""
        # Update download label
        if success:
            self.download_label.setText("✅ Download complete")
            self.download_label.setToolTip("Download completed successfully")
        else:
            self.download_label.setText("❌ Download failed")
            self.download_label.setToolTip("Download failed")
        
        # Clear download label after 5 seconds
        QTimer.singleShot(5000, lambda: self.download_label.setText(""))
</file>

<file path="src/ui/toolbar.py">
#!/usr/bin/env python3
# NebulaFusion Browser - Toolbar

import os
import sys
from PyQt6.QtWidgets import QToolBar, QToolButton, QMenu
from PyQt6.QtGui import QAction, QIcon
from PyQt6.QtCore import Qt, QSize, pyqtSignal

class Toolbar(QToolBar):
    """
    Toolbar for NebulaFusion browser.
    Handles toolbar buttons and actions.
    """
    
    # Signals
    action_triggered = pyqtSignal(str)  # action_id
    
    def __init__(self, app_controller):
        """Initialize the toolbar."""
        super().__init__("Navigation")
        self.app_controller = app_controller
        
        # Set properties
        self.setMovable(False)
        self.setIconSize(QSize(16, 16))
        self.setToolButtonStyle(Qt.ToolButtonStyle.ToolButtonTextBesideIcon)
        
        # Create actions
        self._create_actions()
        
        # Add actions to toolbar
        self._add_actions()
        
        # Notify plugins that toolbar is created
        if hasattr(self.app_controller, 'hook_registry'):
            self.app_controller.hook_registry.trigger_hook('onToolbarCreated')
    
    def _create_actions(self):
        """Create toolbar actions."""
        # Create back action
        self.back_action = QAction("Back", self)
        self.back_action.setIcon(QIcon(os.path.join(os.path.dirname(__file__), "../resources/icons/back.png")))
        self.back_action.setToolTip("Go back one page")
        self.back_action.triggered.connect(lambda: self.action_triggered.emit("back"))
        
        # Create forward action
        self.forward_action = QAction("Forward", self)
        self.forward_action.setIcon(QIcon(os.path.join(os.path.dirname(__file__), "../resources/icons/forward.png")))
        self.forward_action.setToolTip("Go forward one page")
        self.forward_action.triggered.connect(lambda: self.action_triggered.emit("forward"))
        
        # Create reload action
        self.reload_action = QAction("Reload", self)
        self.reload_action.setIcon(QIcon(os.path.join(os.path.dirname(__file__), "../resources/icons/reload.png")))
        self.reload_action.setToolTip("Reload current page")
        self.reload_action.triggered.connect(lambda: self.action_triggered.emit("reload"))
        
        # Create stop action
        self.stop_action = QAction("Stop", self)
        self.stop_action.setIcon(QIcon(os.path.join(os.path.dirname(__file__), "../resources/icons/stop.png")))
        self.stop_action.setToolTip("Stop loading page")
        self.stop_action.triggered.connect(lambda: self.action_triggered.emit("stop"))
        
        # Create home action
        self.home_action = QAction("Home", self)
        self.home_action.setIcon(QIcon(os.path.join(os.path.dirname(__file__), "../resources/icons/home.png")))
        self.home_action.setToolTip("Go to home page")
        self.home_action.triggered.connect(lambda: self.action_triggered.emit("home"))
        
        # Create bookmark action
        self.bookmark_action = QAction("Bookmark", self)
        self.bookmark_action.setIcon(QIcon(os.path.join(os.path.dirname(__file__), "../resources/icons/bookmark.png")))
        self.bookmark_action.setToolTip("Bookmark current page")
        self.bookmark_action.triggered.connect(lambda: self.action_triggered.emit("bookmark"))
        
        # Create history action
        self.history_action = QAction("History", self)
        self.history_action.setIcon(QIcon(os.path.join(os.path.dirname(__file__), "../resources/icons/history.png")))
        self.history_action.setToolTip("View browsing history")
        self.history_action.triggered.connect(lambda: self.action_triggered.emit("history"))
        
        # Create downloads action
        self.downloads_action = QAction("Downloads", self)
        self.downloads_action.setIcon(QIcon(os.path.join(os.path.dirname(__file__), "../resources/icons/download.png")))
        self.downloads_action.setToolTip("View downloads")
        self.downloads_action.triggered.connect(lambda: self.action_triggered.emit("downloads"))
        
        # Create plugins action
        self.plugins_action = QAction("Plugins", self)
        self.plugins_action.setIcon(QIcon(os.path.join(os.path.dirname(__file__), "../resources/icons/plugins.png")))
        self.plugins_action.setToolTip("Manage plugins")
        self.plugins_action.triggered.connect(lambda: self.action_triggered.emit("plugins"))
        
        # Create settings action
        self.settings_action = QAction("Settings", self)
        self.settings_action.setIcon(QIcon(os.path.join(os.path.dirname(__file__), "../resources/icons/settings.png")))
        self.settings_action.setToolTip("Open settings")
        self.settings_action.triggered.connect(lambda: self.action_triggered.emit("settings"))
    
    def _add_actions(self):
        """Add actions to toolbar."""
        # Add back button
        self.addAction(self.back_action)
        
        # Add forward button
        self.addAction(self.forward_action)
        
        # Add reload button
        self.addAction(self.reload_action)
        
        # Add stop button
        self.addAction(self.stop_action)
        
        # Add home button
        self.addAction(self.home_action)
        
        # Add separator
        self.addSeparator()
        
        # Add bookmark button
        self.addAction(self.bookmark_action)
        
        # Add history button
        self.addAction(self.history_action)
        
        # Add downloads button
        self.addAction(self.downloads_action)
        
        # Add separator
        self.addSeparator()
        
        # Add plugins button
        self.addAction(self.plugins_action)
        
        # Add settings button
        self.addAction(self.settings_action)
    
    def update_actions(self, can_go_back, can_go_forward, is_loading):
        """Update toolbar actions."""
        # Update back action
        self.back_action.setEnabled(can_go_back)
        
        # Update forward action
        self.forward_action.setEnabled(can_go_forward)
        
        # Update reload/stop actions
        self.reload_action.setVisible(not is_loading)
        self.stop_action.setVisible(is_loading)
    
    def add_plugin_button(self, action):
        """Add a plugin button (QAction) to the toolbar after the last separator."""
        # Find the last separator and insert after it, or just add if not found
        actions = self.actions()
        last_sep = None
        for a in actions:
            if a.isSeparator():
                last_sep = a
        if last_sep:
            self.insertAction(last_sep, action)
        else:
            self.addAction(action)
</file>

<file path="src/utils/file_utils.py">
#!/usr/bin/env python3
# NebulaFusion Browser - File Utilities

import os
import sys
import shutil
import subprocess
import platform
from PyQt6.QtCore import QObject, pyqtSignal

class FileUtils(QObject):
    """
    File utility functions for NebulaFusion browser.
    Provides file operations with platform-specific handling.
    """
    
    # Signals
    file_operation_completed = pyqtSignal(str, bool)  # operation, success
    
    def __init__(self):
        """Initialize the file utilities."""
        super().__init__()
    
    def ensure_directory_exists(self, directory):
        """Ensure that a directory exists, creating it if necessary."""
        if not os.path.exists(directory):
            try:
                os.makedirs(directory, exist_ok=True)
                return True
            except Exception as e:
                print(f"Error creating directory {directory}: {e}")
                return False
        return True
    
    def copy_file(self, source, destination):
        """Copy a file from source to destination."""
        try:
            shutil.copy2(source, destination)
            self.file_operation_completed.emit("copy", True)
            return True
        except Exception as e:
            print(f"Error copying file from {source} to {destination}: {e}")
            self.file_operation_completed.emit("copy", False)
            return False
    
    def move_file(self, source, destination):
        """Move a file from source to destination."""
        try:
            shutil.move(source, destination)
            self.file_operation_completed.emit("move", True)
            return True
        except Exception as e:
            print(f"Error moving file from {source} to {destination}: {e}")
            self.file_operation_completed.emit("move", False)
            return False
    
    def delete_file(self, file_path):
        """Delete a file."""
        try:
            if os.path.exists(file_path):
                os.remove(file_path)
                self.file_operation_completed.emit("delete", True)
                return True
            return False
        except Exception as e:
            print(f"Error deleting file {file_path}: {e}")
            self.file_operation_completed.emit("delete", False)
            return False
    
    def read_file(self, file_path, binary=False):
        """Read a file and return its contents."""
        try:
            mode = "rb" if binary else "r"
            with open(file_path, mode) as f:
                return f.read()
        except Exception as e:
            print(f"Error reading file {file_path}: {e}")
            return None
    
    def write_file(self, file_path, content, binary=False):
        """Write content to a file."""
        try:
            mode = "wb" if binary else "w"
            with open(file_path, mode) as f:
                f.write(content)
            self.file_operation_completed.emit("write", True)
            return True
        except Exception as e:
            print(f"Error writing to file {file_path}: {e}")
            self.file_operation_completed.emit("write", False)
            return False
    
    def append_to_file(self, file_path, content, binary=False):
        """Append content to a file."""
        try:
            mode = "ab" if binary else "a"
            with open(file_path, mode) as f:
                f.write(content)
            self.file_operation_completed.emit("append", True)
            return True
        except Exception as e:
            print(f"Error appending to file {file_path}: {e}")
            self.file_operation_completed.emit("append", False)
            return False
    
    def file_exists(self, file_path):
        """Check if a file exists."""
        return os.path.isfile(file_path)
    
    def directory_exists(self, directory):
        """Check if a directory exists."""
        return os.path.isdir(directory)
    
    def get_file_size(self, file_path):
        """Get the size of a file in bytes."""
        try:
            return os.path.getsize(file_path)
        except Exception as e:
            print(f"Error getting size of file {file_path}: {e}")
            return -1
    
    def get_file_modification_time(self, file_path):
        """Get the modification time of a file."""
        try:
            return os.path.getmtime(file_path)
        except Exception as e:
            print(f"Error getting modification time of file {file_path}: {e}")
            return -1
    
    def list_directory(self, directory):
        """List the contents of a directory."""
        try:
            return os.listdir(directory)
        except Exception as e:
            print(f"Error listing directory {directory}: {e}")
            return []
    
    def get_home_directory(self):
        """Get the user's home directory."""
        return os.path.expanduser("~")
    
    def get_downloads_directory(self):
        """Get the user's downloads directory."""
        home = self.get_home_directory()
        
        # Platform-specific downloads directory
        if platform.system() == "Windows":
            return os.path.join(home, "Downloads")
        elif platform.system() == "Darwin":  # macOS
            return os.path.join(home, "Downloads")
        else:  # Linux and others
            # Try to get from XDG user dirs
            try:
                with open(os.path.join(home, ".config", "user-dirs.dirs"), "r") as f:
                    for line in f:
                        if line.startswith("XDG_DOWNLOAD_DIR="):
                            download_dir = line.split("=")[1].strip().strip('"')
                            download_dir = download_dir.replace("$HOME", home)
                            if os.path.exists(download_dir):
                                return download_dir
            except:
                pass
            
            # Fallback to ~/Downloads
            downloads = os.path.join(home, "Downloads")
            if os.path.exists(downloads):
                return downloads
            
            # Last resort: home directory
            return home
    
    def get_temporary_directory(self):
        """Get a temporary directory."""
        import tempfile
        return tempfile.gettempdir()
    
    def create_temporary_file(self, prefix="nebulafusion_", suffix=""):
        """Create a temporary file and return its path."""
        import tempfile
        fd, path = tempfile.mkstemp(prefix=prefix, suffix=suffix)
        os.close(fd)
        return path
    
    def create_temporary_directory(self, prefix="nebulafusion_"):
        """Create a temporary directory and return its path."""
        import tempfile
        return tempfile.mkdtemp(prefix=prefix)
    
    def open_file(self, file_path):
        """Open a file with the default application."""
        try:
            if platform.system() == "Windows":
                os.startfile(file_path)
            elif platform.system() == "Darwin":  # macOS
                subprocess.call(["open", file_path])
            else:  # Linux and others
                subprocess.call(["xdg-open", file_path])
            return True
        except Exception as e:
            print(f"Error opening file {file_path}: {e}")
            return False
    
    def open_folder(self, folder_path):
        """Open a folder in the file explorer."""
        try:
            if platform.system() == "Windows":
                os.startfile(folder_path)
            elif platform.system() == "Darwin":  # macOS
                subprocess.call(["open", folder_path])
            else:  # Linux and others
                subprocess.call(["xdg-open", folder_path])
            return True
        except Exception as e:
            print(f"Error opening folder {folder_path}: {e}")
            return False
    
    def get_file_extension(self, file_path):
        """Get the extension of a file."""
        return os.path.splitext(file_path)[1]
    
    def get_file_name(self, file_path):
        """Get the name of a file without the path."""
        return os.path.basename(file_path)
    
    def get_file_directory(self, file_path):
        """Get the directory containing a file."""
        return os.path.dirname(file_path)
    
    def join_paths(self, *paths):
        """Join multiple path components."""
        return os.path.join(*paths)
    
    def normalize_path(self, path):
        """Normalize a path (resolve '..' and '.')."""
        return os.path.normpath(path)
    
    def absolute_path(self, path):
        """Convert a path to an absolute path."""
        return os.path.abspath(path)
    
    def relative_path(self, path, start=None):
        """Convert a path to a relative path."""
        return os.path.relpath(path, start)
    
    def is_absolute_path(self, path):
        """Check if a path is absolute."""
        return os.path.isabs(path)
    
    def get_file_mime_type(self, file_path):
        """Get the MIME type of a file."""
        import mimetypes
        mime_type, encoding = mimetypes.guess_type(file_path)
        return mime_type
    
    def extract_zip(self, zip_file, extract_to):
        """Extract a ZIP file to a directory."""
        try:
            import zipfile
            with zipfile.ZipFile(zip_file, 'r') as zip_ref:
                zip_ref.extractall(extract_to)
            self.file_operation_completed.emit("extract", True)
            return True
        except Exception as e:
            print(f"Error extracting ZIP file {zip_file}: {e}")
            self.file_operation_completed.emit("extract", False)
            return False
    
    def create_zip(self, zip_file, files_to_zip):
        """Create a ZIP file containing the specified files."""
        try:
            import zipfile
            with zipfile.ZipFile(zip_file, 'w', zipfile.ZIP_DEFLATED) as zip_ref:
                for file in files_to_zip:
                    if os.path.isfile(file):
                        zip_ref.write(file, os.path.basename(file))
                    elif os.path.isdir(file):
                        for root, dirs, files in os.walk(file):
                            for f in files:
                                full_path = os.path.join(root, f)
                                archive_name = os.path.relpath(full_path, os.path.dirname(file))
                                zip_ref.write(full_path, archive_name)
            self.file_operation_completed.emit("zip", True)
            return True
        except Exception as e:
            print(f"Error creating ZIP file {zip_file}: {e}")
            self.file_operation_completed.emit("zip", False)
            return False
</file>

<file path="src/utils/logger.py">
#!/usr/bin/env python3
# NebulaFusion Browser - Logger Utility

import os
import sys
import logging
import datetime
from PyQt6.QtCore import QObject, pyqtSignal

class Logger(QObject):
    """
    Logger utility for NebulaFusion browser.
    Provides logging functionality with different log levels and outputs.
    """
    
    # Signals
    log_added = pyqtSignal(str, str, str)  # level, module, message
    
    def __init__(self, module_name):
        """Initialize the logger."""
        super().__init__()
        self.module_name = module_name
        
        # Create logger
        self.logger = logging.getLogger(f"nebulafusion.{module_name}")
        
        # Set default level
        self.logger.setLevel(logging.INFO)
        
        # Check if handlers already exist
        if not self.logger.handlers:
            # Create log directory if it doesn't exist
            log_dir = os.path.expanduser("~/.nebulafusion/logs")
            os.makedirs(log_dir, exist_ok=True)
            
            # Create log file path
            today = datetime.datetime.now().strftime("%Y-%m-%d")
            log_file = os.path.join(log_dir, f"nebulafusion_{today}.log")
            
            # Create file handler
            file_handler = logging.FileHandler(log_file)
            file_handler.setLevel(logging.DEBUG)
            
            # Create console handler
            console_handler = logging.StreamHandler()
            console_handler.setLevel(logging.INFO)
            
            # Create formatter
            formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
            file_handler.setFormatter(formatter)
            console_handler.setFormatter(formatter)
            
            # Add handlers to logger
            self.logger.addHandler(file_handler)
            self.logger.addHandler(console_handler)
    
    def set_level(self, level):
        """Set the logger level."""
        if level == "debug":
            self.logger.setLevel(logging.DEBUG)
        elif level == "info":
            self.logger.setLevel(logging.INFO)
        elif level == "warning":
            self.logger.setLevel(logging.WARNING)
        elif level == "error":
            self.logger.setLevel(logging.ERROR)
        elif level == "critical":
            self.logger.setLevel(logging.CRITICAL)
    
    def debug(self, message):
        """Log a debug message."""
        self.logger.debug(message)
        self.log_added.emit("debug", self.module_name, message)
    
    def info(self, message):
        """Log an info message."""
        self.logger.info(message)
        self.log_added.emit("info", self.module_name, message)
    
    def warning(self, message):
        """Log a warning message."""
        self.logger.warning(message)
        self.log_added.emit("warning", self.module_name, message)
    
    def error(self, message):
        """Log an error message."""
        self.logger.error(message)
        self.log_added.emit("error", self.module_name, message)
    
    def critical(self, message):
        """Log a critical message."""
        self.logger.critical(message)
        self.log_added.emit("critical", self.module_name, message)
    
    def exception(self, message):
        """Log an exception message."""
        self.logger.exception(message)
        self.log_added.emit("exception", self.module_name, message)
    
    @staticmethod
    def get_all_logs(limit=100):
        """Get all logs from the log file."""
        log_dir = os.path.expanduser("~/.nebulafusion/logs")
        today = datetime.datetime.now().strftime("%Y-%m-%d")
        log_file = os.path.join(log_dir, f"nebulafusion_{today}.log")
        
        if not os.path.exists(log_file):
            return []
        
        with open(log_file, "r") as f:
            lines = f.readlines()
        
        # Return last 'limit' lines
        return lines[-limit:]
    
    @staticmethod
    def clear_logs():
        """Clear all logs."""
        log_dir = os.path.expanduser("~/.nebulafusion/logs")
        today = datetime.datetime.now().strftime("%Y-%m-%d")
        log_file = os.path.join(log_dir, f"nebulafusion_{today}.log")
        
        if os.path.exists(log_file):
            with open(log_file, "w") as f:
                f.write("")
</file>

<file path="src/utils/url_utils.py">
#!/usr/bin/env python3
# NebulaFusion Browser - URL Utilities

import os
import sys
import re
import urllib.parse
from PyQt6.QtCore import QObject, pyqtSignal, QUrl

class UrlUtils(QObject):
    """
    URL utility functions for NebulaFusion browser.
    Provides URL parsing, validation, and manipulation.
    """
    
    # Signals
    url_validated = pyqtSignal(str, bool)  # url, is_valid
    
    def __init__(self):
        """Initialize the URL utilities."""
        super().__init__()
        
        # Common TLDs for validation
        self.common_tlds = [
            "com", "org", "net", "edu", "gov", "mil", "io", "co", "info", "biz",
            "me", "tv", "app", "dev", "ai", "uk", "us", "ca", "au", "de", "fr",
            "jp", "cn", "ru", "br", "in", "it", "nl", "es", "se", "no", "fi",
            "dk", "ch", "at", "be", "ie", "nz", "sg", "ae", "sa", "za", "mx",
            "ar", "cl", "pe", "co", "ve", "ec", "bo", "py", "uy", "cr", "pa",
            "do", "hn", "sv", "ni", "gt", "cu", "pr", "jm", "bs", "bb", "tt",
            "lc", "vc", "gd", "ag", "dm", "kn", "tc", "vg", "ai", "ms", "ky",
            "bm", "gl", "pm", "fo", "is", "li", "lu", "mc", "sm", "va", "ad",
            "gi", "je", "gg", "im", "mt", "cy", "gr", "tr", "il", "lb", "jo",
            "kw", "qa", "bh", "om", "ye", "ir", "iq", "sy", "eg", "ly", "tn",
            "dz", "ma", "mr", "ml", "sn", "gm", "gw", "gn", "sl", "lr", "ci",
            "gh", "tg", "bj", "ne", "ng", "cm", "td", "cf", "ga", "cg", "cd",
            "ao", "na", "bw", "zw", "mz", "zm", "mw", "tz", "ke", "ug", "rw",
            "bi", "et", "dj", "so", "er", "sd", "ss", "mg", "mu", "re", "sc",
            "mv", "lk", "bd", "np", "bt", "mm", "th", "la", "kh", "vn", "my",
            "ph", "id", "tl", "bn", "pw", "fm", "mh", "nr", "sb", "vu", "fj",
            "to", "ws", "ck", "nu", "tv", "ki", "pf", "nc", "wf", "as", "gu",
            "mp", "pg", "nf", "cx", "cc", "hm", "tk", "travel", "museum", "jobs",
            "mobi", "tel", "asia", "coop", "cat", "pro", "int", "aero", "post",
            "xyz", "top", "club", "site", "online", "shop", "blog", "tech", "store",
            "cloud", "space", "live", "life", "world", "today", "digital", "network",
            "design", "game", "games", "media", "news", "video", "music", "art",
            "health", "care", "doctor", "hospital", "school", "academy", "university",
            "college", "education", "institute", "center", "foundation", "church",
            "community", "social", "group", "team", "company", "business", "agency",
            "studio", "works", "creative", "solutions", "consulting", "partners",
            "limited", "ltd", "inc", "llc", "corp", "gmbh", "legal", "law", "attorney",
            "lawyer", "accountant", "tax", "finance", "financial", "bank", "money",
            "insurance", "invest", "investment", "fund", "capital", "holdings",
            "property", "properties", "realty", "estate", "construction", "build",
            "builder", "building", "house", "home", "homes", "land", "farm", "garden",
            "food", "restaurant", "cafe", "coffee", "bar", "pub", "beer", "wine",
            "pizza", "sushi", "kitchen", "cook", "cooking", "chef", "recipe", "recipes",
            "diet", "fitness", "gym", "yoga", "run", "running", "bike", "biking",
            "swim", "swimming", "golf", "tennis", "soccer", "football", "baseball",
            "basketball", "hockey", "sport", "sports", "fan", "fans", "team", "league",
            "racing", "car", "cars", "auto", "automotive", "vehicle", "vehicles",
            "motorcycle", "motorcycles", "boat", "boats", "yacht", "yachts", "plane",
            "planes", "jet", "jets", "airline", "airlines", "flight", "flights",
            "travel", "traveling", "traveler", "vacation", "vacations", "holiday",
            "holidays", "tour", "tours", "tourism", "tourist", "cruise", "cruises",
            "resort", "resorts", "hotel", "hotels", "motel", "motels", "hostel",
            "hostels", "camping", "camp", "beach", "mountain", "mountains", "lake",
            "lakes", "river", "rivers", "ocean", "sea", "island", "islands", "park",
            "parks", "forest", "nature", "wildlife", "animal", "animals", "pet",
            "pets", "dog", "dogs", "cat", "cats", "bird", "birds", "fish", "horse",
            "horses", "farm", "farming", "garden", "gardening", "plant", "plants",
            "flower", "flowers", "tree", "trees", "photography", "photo", "photos",
            "picture", "pictures", "image", "images", "camera", "video", "videos",
            "film", "films", "movie", "movies", "cinema", "theater", "theatre",
            "concert", "concerts", "festival", "festivals", "event", "events",
            "wedding", "weddings", "party", "parties", "dance", "dancing", "music",
            "band", "bands", "singer", "singers", "song", "songs", "album", "albums",
            "artist", "artists", "art", "arts", "gallery", "galleries", "museum",
            "museums", "exhibition", "exhibitions", "fashion", "style", "design",
            "designer", "designers", "model", "models", "beauty", "makeup", "hair",
            "salon", "spa", "massage", "nail", "nails", "tattoo", "tattoos", "jewelry",
            "jewellery", "watch", "watches", "clothing", "clothes", "fashion", "shoe",
            "shoes", "handbag", "handbags", "accessory", "accessories", "furniture",
            "furnishings", "decor", "decoration", "decorations", "interior", "exteriors",
            "architecture", "architect", "architects", "engineering", "engineer",
            "engineers", "science", "scientist", "scientists", "research", "lab",
            "laboratory", "laboratories", "technology", "technologies", "tech",
            "computer", "computers", "software", "hardware", "program", "programming",
            "code", "coding", "developer", "developers", "web", "website", "websites",
            "host", "hosting", "server", "servers", "cloud", "data", "database",
            "storage", "backup", "security", "secure", "protection", "privacy",
            "private", "vpn", "network", "networks", "internet", "online", "digital",
            "virtual", "mobile", "phone", "phones", "smartphone", "smartphones",
            "tablet", "tablets", "laptop", "laptops", "desktop", "desktops", "device",
            "devices", "gadget", "gadgets", "electronic", "electronics", "electric",
            "electrical", "power", "energy", "solar", "wind", "water", "gas", "oil",
            "fuel", "green", "eco", "environment", "environmental", "sustainable",
            "sustainability", "recycle", "recycling", "organic", "natural", "bio",
            "health", "healthy", "wellness", "medical", "medicine", "doctor", "doctors",
            "dentist", "dentists", "dental", "hospital", "hospitals", "clinic",
            "clinics", "pharmacy", "pharmacies", "drug", "drugs", "vitamin", "vitamins",
            "supplement", "supplements", "therapy", "therapist", "therapists",
            "counseling", "counselor", "counselors", "psychology", "psychologist",
            "psychologists", "psychiatry", "psychiatrist", "psychiatrists", "mental",
            "education", "educational", "learn", "learning", "teach", "teaching",
            "teacher", "teachers", "student", "students", "school", "schools",
            "university", "universities", "college", "colleges", "academy", "academies",
            "institute", "institutes", "course", "courses", "class", "classes",
            "training", "coach", "coaching", "tutor", "tutoring", "tutors", "career",
            "careers", "job", "jobs", "employment", "employer", "employers", "hire",
            "hiring", "recruit", "recruiting", "recruitment", "resume", "resumes",
            "interview", "interviews", "work", "working", "worker", "workers",
            "business", "businesses", "company", "companies", "startup", "startups",
            "entrepreneur", "entrepreneurs", "enterprise", "enterprises", "corporate",
            "corporation", "corporations", "industry", "industries", "industrial",
            "manufacture", "manufacturing", "manufacturer", "manufacturers", "product",
            "products", "service", "services", "solution", "solutions", "consulting",
            "consultant", "consultants", "advisor", "advisors", "expert", "experts",
            "professional", "professionals", "specialist", "specialists", "broker",
            "brokers", "agent", "agents", "agency", "agencies", "firm", "firms",
            "partner", "partners", "partnership", "partnerships", "association",
            "associations", "foundation", "foundations", "organization", "organizations",
            "charity", "charities", "nonprofit", "community", "communities", "society",
            "club", "clubs", "group", "groups", "team", "teams", "member", "members",
            "membership", "forum", "forums", "board", "boards", "committee", "committees",
            "council", "councils", "government", "governments", "political", "politics",
            "policy", "policies", "law", "laws", "legal", "lawyer", "lawyers", "attorney",
            "attorneys", "court", "courts", "justice", "judge", "judges", "police",
            "military", "army", "navy", "air", "force", "defense", "security", "guard",
            "guards", "protection", "emergency", "fire", "firefighter", "firefighters",
            "rescue", "safety", "safe", "insurance", "insure", "insurer", "insurers",
            "bank", "banks", "banking", "financial", "finance", "money", "cash",
            "credit", "loan", "loans", "mortgage", "mortgages", "invest", "investing",
            "investment", "investments", "investor", "investors", "fund", "funds",
            "funding", "capital", "wealth", "tax", "taxes", "taxation", "accounting",
            "accountant", "accountants", "budget", "budgeting", "save", "saving",
            "savings", "retire", "retirement", "pension", "estate", "will", "trust",
            "property", "properties", "real", "estate", "land", "housing", "house",
            "houses", "home", "homes", "apartment", "apartments", "condo", "condos",
            "rent", "rental", "rentals", "lease", "leasing", "buy", "buying", "sell",
            "selling", "sale", "sales", "auction", "auctions", "bid", "bidding",
            "market", "marketing", "advertise", "advertising", "advertisement",
            "advertisements", "promote", "promotion", "promotions", "brand", "branding",
            "brands", "logo", "logos", "identity", "campaign", "campaigns", "media",
            "press", "news", "newspaper", "newspapers", "magazine", "magazines",
            "journal", "journals", "blog", "blogs", "blogger", "bloggers", "article",
            "articles", "story", "stories", "book", "books", "ebook", "ebooks",
            "publish", "publishing", "publisher", "publishers", "author", "authors",
            "write", "writing", "writer", "writers", "content", "copy", "copyright",
            "trademark", "trademarks", "patent", "patents", "intellectual", "property",
            "creative", "creation", "create", "creator", "creators", "make", "maker",
            "makers", "craft", "crafts", "art", "artist", "artists", "design", "designer",
            "designers", "style", "fashion", "shop", "shopping", "store", "stores",
            "mall", "outlet", "outlets", "market", "marketplace", "buy", "buyer",
            "buyers", "sell", "seller", "sellers", "vendor", "vendors", "supply",
            "supplier", "suppliers", "wholesale", "retail", "deal", "deals", "discount",
            "discounts", "coupon", "coupons", "save", "savings", "free", "cheap",
            "price", "prices", "cost", "costs", "value", "quality", "review", "reviews",
            "rate", "rating", "ratings", "compare", "comparison", "best", "top",
            "popular", "trend", "trends", "trending", "hot", "new", "latest", "modern",
            "contemporary", "classic", "vintage", "antique", "retro", "custom",
            "personalize", "personalized", "unique", "original", "authentic", "genuine",
            "official", "authorized", "premium", "luxury", "exclusive", "elite",
            "vip", "pro", "professional", "expert", "master", "guru", "genius",
            "wizard", "ninja", "hero", "champion", "winner", "success", "successful",
            "achieve", "achievement", "goal", "goals", "dream", "dreams", "inspire",
            "inspiration", "motivate", "motivation", "positive", "happy", "happiness",
            "joy", "fun", "enjoy", "love", "life", "live", "living", "lifestyle",
            "experience", "adventure", "explore", "discovery", "discover", "find",
            "search", "seek", "guide", "guides", "help", "support", "assist", "service",
            "care", "trust", "reliable", "dependable", "honest", "integrity", "ethical",
            "moral", "fair", "just", "right", "good", "better", "best", "perfect",
            "excellent", "outstanding", "superior", "supreme", "ultimate", "extreme",
            "mega", "super", "hyper", "ultra", "maximum", "minimum", "medium", "average",
            "standard", "basic", "simple", "easy", "quick", "fast", "rapid", "swift",
            "instant", "immediate", "now", "today", "daily", "weekly", "monthly",
            "yearly", "annual", "season", "seasonal", "summer", "winter", "spring",
            "fall", "autumn", "holiday", "christmas", "halloween", "easter", "birthday",
            "anniversary", "wedding", "baby", "family", "friend", "friends", "partner",
            "partners", "relationship", "relationships", "date", "dating", "match",
            "matching", "meet", "meeting", "connect", "connection", "connections",
            "network", "networking", "social", "society", "community", "local",
            "global", "international", "world", "worldwide", "universal", "earth",
            "planet", "space", "universe", "galaxy", "star", "stars", "sun", "moon",
            "sky", "heaven", "paradise", "dream", "fantasy", "magic", "magical",
            "mystic", "mystical", "spiritual", "spirit", "soul", "mind", "body",
            "heart", "life", "death", "god", "goddess", "angel", "demon", "devil",
            "evil", "good", "light", "dark", "black", "white", "red", "blue", "green",
            "yellow", "orange", "purple", "pink", "brown", "gray", "silver", "gold",
            "color", "colors", "colour", "colours", "rainbow", "nature", "natural",
            "earth", "water", "fire", "air", "wind", "storm", "rain", "snow", "ice",
            "cloud", "clouds", "sky", "sun", "moon", "star", "stars", "day", "night",
            "morning", "evening", "afternoon", "noon", "midnight", "time", "hour",
            "minute", "second", "moment", "instant", "now", "today", "tomorrow",
            "yesterday", "week", "month", "year", "decade", "century", "millennium",
            "age", "era", "period", "history", "future", "past", "present", "eternal",
            "forever", "always", "never", "sometimes", "often", "rarely", "seldom",
            "occasionally", "frequently", "regularly", "constantly", "continuously",
            "intermittently", "periodically", "sporadically", "randomly", "suddenly",
            "gradually", "slowly", "quickly", "rapidly", "swiftly", "hastily",
            "leisurely", "carefully", "cautiously", "recklessly", "boldly", "bravely",
            "fearlessly", "timidly", "shyly", "confidently", "proudly", "humbly",
            "modestly", "honestly", "sincerely", "truly", "really", "actually",
            "literally", "virtually", "practically", "essentially", "basically",
            "fundamentally", "primarily", "mainly", "mostly", "largely", "generally",
            "usually", "typically", "commonly", "normally", "naturally", "obviously",
            "clearly", "evidently", "apparently", "seemingly", "presumably", "supposedly",
            "allegedly", "reputedly", "reportedly", "arguably", "conceivably",
            "possibly", "probably", "likely", "unlikely", "certainly", "definitely",
            "absolutely", "undoubtedly", "unquestionably", "indisputably", "undeniably",
            "irrefutably", "incontrovertibly", "incontestably", "indubitably"
        ]
    
    def is_valid_url(self, url):
        """Check if a URL is valid."""
        # Check if URL is empty
        if not url:
            self.url_validated.emit(url, False)
            return False
        
        # Check if URL is already a QUrl
        if isinstance(url, QUrl):
            url = url.toString()
        
        # Check if URL has a scheme
        if "://" in url:
            # Parse URL
            parsed_url = urllib.parse.urlparse(url)
            
            # Check if scheme is valid
            if parsed_url.scheme not in ["http", "https", "file", "ftp", "ftps"]:
                self.url_validated.emit(url, False)
                return False
            
            # Check if netloc is valid
            if not parsed_url.netloc:
                self.url_validated.emit(url, False)
                return False
            
            self.url_validated.emit(url, True)
            return True
        else:
            # Check if URL is a valid domain
            if self._is_valid_domain(url):
                self.url_validated.emit(url, True)
                return True
            
            # Check if URL is a valid IP address
            if self._is_valid_ip(url):
                self.url_validated.emit(url, True)
                return True
            
            # Check if URL is a valid local file path
            if self._is_valid_file_path(url):
                self.url_validated.emit(url, True)
                return True
            
            # URL is not valid
            self.url_validated.emit(url, False)
            return False
    
    def _is_valid_domain(self, domain):
        """Check if a domain is valid."""
        # Remove any path or query
        domain = domain.split("/")[0].split("?")[0]
        
        # Check if domain has at least one dot
        if "." not in domain:
            return False
        
        # Check if domain has a valid TLD
        parts = domain.split(".")
        tld = parts[-1].lower()
        
        # Check if TLD is in common TLDs
        if tld not in self.common_tlds:
            return False
        
        # Check if domain name is valid
        domain_name = ".".join(parts[:-1])
        if not re.match(r"^[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?$", domain_name):
            return False
        
        return True
    
    def _is_valid_ip(self, ip):
        """Check if an IP address is valid."""
        # Check if IP is IPv4
        if re.match(r"^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$", ip):
            # Check if each octet is valid
            octets = ip.split(".")
            for octet in octets:
                if int(octet) > 255:
                    return False
            return True
        
        # Check if IP is IPv6
        if re.match(r"^([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$", ip):
            return True
        
        return False
    
    def _is_valid_file_path(self, path):
        """Check if a file path is valid."""
        # Check if path is a valid file path
        if os.path.exists(path):
            return True
        
        return False
    
    def normalize_url(self, url):
        """Normalize a URL."""
        # Check if URL is already a QUrl
        if isinstance(url, QUrl):
            url = url.toString()
        
        # Check if URL has a scheme
        if "://" not in url:
            # Check if URL is a valid domain
            if self._is_valid_domain(url):
                url = "https://" + url
            # Check if URL is a valid IP address
            elif self._is_valid_ip(url):
                url = "http://" + url
            # Check if URL is a valid local file path
            elif self._is_valid_file_path(url):
                url = "file://" + url
        
        # Parse URL
        parsed_url = urllib.parse.urlparse(url)
        
        # Normalize scheme
        scheme = parsed_url.scheme.lower()
        
        # Normalize netloc
        netloc = parsed_url.netloc.lower()
        
        # Normalize path
        path = parsed_url.path
        if not path:
            path = "/"
        
        # Normalize query
        query = parsed_url.query
        
        # Normalize fragment
        fragment = parsed_url.fragment
        
        # Build normalized URL
        normalized_url = urllib.parse.urlunparse((scheme, netloc, path, "", query, fragment))
        
        return normalized_url
    
    def get_domain(self, url):
        """Get the domain from a URL."""
        # Check if URL is already a QUrl
        if isinstance(url, QUrl):
            url = url.toString()
        
        # Parse URL
        parsed_url = urllib.parse.urlparse(url)
        
        # Get domain
        domain = parsed_url.netloc
        
        # Remove port if present
        if ":" in domain:
            domain = domain.split(":")[0]
        
        return domain
    
    def get_base_url(self, url):
        """Get the base URL (scheme + domain) from a URL."""
        # Check if URL is already a QUrl
        if isinstance(url, QUrl):
            url = url.toString()
        
        # Parse URL
        parsed_url = urllib.parse.urlparse(url)
        
        # Get base URL
        base_url = parsed_url.scheme + "://" + parsed_url.netloc
        
        return base_url
    
    def get_path(self, url):
        """Get the path from a URL."""
        # Check if URL is already a QUrl
        if isinstance(url, QUrl):
            url = url.toString()
        
        # Parse URL
        parsed_url = urllib.parse.urlparse(url)
        
        # Get path
        path = parsed_url.path
        
        return path
    
    def get_query(self, url):
        """Get the query from a URL."""
        # Check if URL is already a QUrl
        if isinstance(url, QUrl):
            url = url.toString()
        
        # Parse URL
        parsed_url = urllib.parse.urlparse(url)
        
        # Get query
        query = parsed_url.query
        
        return query
    
    def get_query_params(self, url):
        """Get the query parameters from a URL as a dictionary."""
        # Check if URL is already a QUrl
        if isinstance(url, QUrl):
            url = url.toString()
        
        # Parse URL
        parsed_url = urllib.parse.urlparse(url)
        
        # Get query parameters
        query_params = urllib.parse.parse_qs(parsed_url.query)
        
        # Convert lists to single values if only one value
        for key, value in query_params.items():
            if len(value) == 1:
                query_params[key] = value[0]
        
        return query_params
    
    def get_fragment(self, url):
        """Get the fragment from a URL."""
        # Check if URL is already a QUrl
        if isinstance(url, QUrl):
            url = url.toString()
        
        # Parse URL
        parsed_url = urllib.parse.urlparse(url)
        
        # Get fragment
        fragment = parsed_url.fragment
        
        return fragment
    
    def build_url(self, base_url, path="", query_params=None, fragment=""):
        """Build a URL from components."""
        # Check if base URL is already a QUrl
        if isinstance(base_url, QUrl):
            base_url = base_url.toString()
        
        # Parse base URL
        parsed_url = urllib.parse.urlparse(base_url)
        
        # Get scheme and netloc
        scheme = parsed_url.scheme
        netloc = parsed_url.netloc
        
        # Normalize path
        if path and not path.startswith("/"):
            path = "/" + path
        
        # Build query string
        query = ""
        if query_params:
            query = urllib.parse.urlencode(query_params)
        
        # Build URL
        url = urllib.parse.urlunparse((scheme, netloc, path, "", query, fragment))
        
        return url
    
    def join_url(self, base_url, relative_url):
        """Join a base URL and a relative URL."""
        # Check if base URL is already a QUrl
        if isinstance(base_url, QUrl):
            base_url = base_url.toString()
        
        # Check if relative URL is already a QUrl
        if isinstance(relative_url, QUrl):
            relative_url = relative_url.toString()
        
        # Join URLs
        joined_url = urllib.parse.urljoin(base_url, relative_url)
        
        return joined_url
    
    def encode_url(self, url):
        """Encode a URL."""
        # Check if URL is already a QUrl
        if isinstance(url, QUrl):
            url = url.toString()
        
        # Parse URL
        parsed_url = urllib.parse.urlparse(url)
        
        # Encode path
        path = urllib.parse.quote(parsed_url.path)
        
        # Encode query
        query = parsed_url.query
        
        # Encode fragment
        fragment = urllib.parse.quote(parsed_url.fragment)
        
        # Build encoded URL
        encoded_url = urllib.parse.urlunparse((parsed_url.scheme, parsed_url.netloc, path, "", query, fragment))
        
        return encoded_url
    
    def decode_url(self, url):
        """Decode a URL."""
        # Check if URL is already a QUrl
        if isinstance(url, QUrl):
            url = url.toString()
        
        # Parse URL
        parsed_url = urllib.parse.urlparse(url)
        
        # Decode path
        path = urllib.parse.unquote(parsed_url.path)
        
        # Decode query
        query = parsed_url.query
        
        # Decode fragment
        fragment = urllib.parse.unquote(parsed_url.fragment)
        
        # Build decoded URL
        decoded_url = urllib.parse.urlunparse((parsed_url.scheme, parsed_url.netloc, path, "", query, fragment))
        
        return decoded_url
    
    def is_same_domain(self, url1, url2):
        """Check if two URLs have the same domain."""
        # Get domains
        domain1 = self.get_domain(url1)
        domain2 = self.get_domain(url2)
        
        # Compare domains
        return domain1 == domain2
    
    def is_subdomain(self, url, domain):
        """Check if a URL is a subdomain of a domain."""
        # Get URL domain
        url_domain = self.get_domain(url)
        
        # Check if URL domain is a subdomain of domain
        return url_domain.endswith("." + domain) or url_domain == domain
    
    def is_secure(self, url):
        """Check if a URL uses HTTPS."""
        # Check if URL is already a QUrl
        if isinstance(url, QUrl):
            url = url.toString()
        
        # Parse URL
        parsed_url = urllib.parse.urlparse(url)
        
        # Check if scheme is HTTPS
        return parsed_url.scheme.lower() == "https"
    
    def to_qurl(self, url):
        """Convert a URL string to a QUrl object."""
        # Check if URL is already a QUrl
        if isinstance(url, QUrl):
            return url
        
        # Convert to QUrl
        return QUrl(url)
    
    def from_qurl(self, qurl):
        """Convert a QUrl object to a URL string."""
        # Check if URL is already a string
        if isinstance(qurl, str):
            return qurl
        
        # Convert to string
        return qurl.toString()
    
    def get_file_name_from_url(self, url):
        """Get the file name from a URL."""
        # Check if URL is already a QUrl
        if isinstance(url, QUrl):
            url = url.toString()
        
        # Parse URL
        parsed_url = urllib.parse.urlparse(url)
        
        # Get path
        path = parsed_url.path
        
        # Get file name
        file_name = os.path.basename(path)
        
        # Remove query string and fragment
        file_name = file_name.split("?")[0].split("#")[0]
        
        return file_name
    
    def get_file_extension_from_url(self, url):
        """Get the file extension from a URL."""
        # Get file name
        file_name = self.get_file_name_from_url(url)
        
        # Get file extension
        _, file_extension = os.path.splitext(file_name)
        
        return file_extension
    
    def is_downloadable(self, url):
        """Check if a URL is likely to be a downloadable file."""
        # Get file extension
        file_extension = self.get_file_extension_from_url(url).lower()
        
        # Check if file extension is in downloadable extensions
        downloadable_extensions = [
            ".zip", ".rar", ".7z", ".tar", ".gz", ".bz2", ".xz",
            ".exe", ".msi", ".dmg", ".pkg", ".deb", ".rpm",
            ".pdf", ".doc", ".docx", ".xls", ".xlsx", ".ppt", ".pptx",
            ".txt", ".csv", ".json", ".xml", ".html", ".htm",
            ".jpg", ".jpeg", ".png", ".gif", ".bmp", ".svg", ".webp",
            ".mp3", ".wav", ".ogg", ".flac", ".aac", ".m4a",
            ".mp4", ".avi", ".mkv", ".mov", ".wmv", ".flv", ".webm",
            ".iso", ".img", ".bin", ".cue",
            ".apk", ".ipa", ".xpi", ".crx",
            ".ttf", ".otf", ".woff", ".woff2",
            ".py", ".js", ".css", ".php", ".java", ".c", ".cpp", ".h", ".cs", ".rb", ".go", ".rs", ".swift",
            ".sh", ".bat", ".ps1", ".vbs", ".pl", ".lua"
        ]
        
        return file_extension in downloadable_extensions
    
    def is_media(self, url):
        """Check if a URL is likely to be a media file."""
        # Get file extension
        file_extension = self.get_file_extension_from_url(url).lower()
        
        # Check if file extension is in media extensions
        media_extensions = [
            ".jpg", ".jpeg", ".png", ".gif", ".bmp", ".svg", ".webp",
            ".mp3", ".wav", ".ogg", ".flac", ".aac", ".m4a",
            ".mp4", ".avi", ".mkv", ".mov", ".wmv", ".flv", ".webm"
        ]
        
        return file_extension in media_extensions
    
    def is_image(self, url):
        """Check if a URL is likely to be an image file."""
        # Get file extension
        file_extension = self.get_file_extension_from_url(url).lower()
        
        # Check if file extension is in image extensions
        image_extensions = [
            ".jpg", ".jpeg", ".png", ".gif", ".bmp", ".svg", ".webp", ".ico", ".tiff", ".tif"
        ]
        
        return file_extension in image_extensions
    
    def is_video(self, url):
        """Check if a URL is likely to be a video file."""
        # Get file extension
        file_extension = self.get_file_extension_from_url(url).lower()
        
        # Check if file extension is in video extensions
        video_extensions = [
            ".mp4", ".avi", ".mkv", ".mov", ".wmv", ".flv", ".webm", ".m4v", ".mpg", ".mpeg", ".3gp", ".3g2"
        ]
        
        return file_extension in video_extensions
    
    def is_audio(self, url):
        """Check if a URL is likely to be an audio file."""
        # Get file extension
        file_extension = self.get_file_extension_from_url(url).lower()
        
        # Check if file extension is in audio extensions
        audio_extensions = [
            ".mp3", ".wav", ".ogg", ".flac", ".aac", ".m4a", ".wma", ".mid", ".midi", ".opus"
        ]
        
        return file_extension in audio_extensions
    
    def is_document(self, url):
        """Check if a URL is likely to be a document file."""
        # Get file extension
        file_extension = self.get_file_extension_from_url(url).lower()
        
        # Check if file extension is in document extensions
        document_extensions = [
            ".pdf", ".doc", ".docx", ".xls", ".xlsx", ".ppt", ".pptx",
            ".txt", ".csv", ".json", ".xml", ".html", ".htm", ".md", ".rtf", ".odt", ".ods", ".odp"
        ]
        
        return file_extension in document_extensions
    
    def is_archive(self, url):
        """Check if a URL is likely to be an archive file."""
        # Get file extension
        file_extension = self.get_file_extension_from_url(url).lower()
        
        # Check if file extension is in archive extensions
        archive_extensions = [
            ".zip", ".rar", ".7z", ".tar", ".gz", ".bz2", ".xz", ".tgz", ".tbz2", ".txz"
        ]
        
        return file_extension in archive_extensions
    
    def is_executable(self, url):
        """Check if a URL is likely to be an executable file."""
        # Get file extension
        file_extension = self.get_file_extension_from_url(url).lower()
        
        # Check if file extension is in executable extensions
        executable_extensions = [
            ".exe", ".msi", ".dmg", ".pkg", ".deb", ".rpm", ".app", ".bat", ".sh", ".com", ".cmd", ".vbs", ".ps1"
        ]
        
        return file_extension in executable_extensions
</file>

<file path="tests/test_browser.py">
#!/usr/bin/env python3
# NebulaFusion Browser - Test Browser

import os
import sys
import unittest
from PyQt6.QtWidgets import QApplication
from PyQt6.QtCore import QUrl
from PyQt6.QtTest import QTest
from PyQt6.QtCore import Qt

# Add parent directory to path
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

# Import browser modules
from src.core.application import Application
from src.core.web_engine import WebEngine
from src.core.tab_manager import TabManager
from src.core.history import HistoryManager
from src.core.bookmarks import BookmarksManager
from src.core.cookies import CookiesManager
from src.core.downloads import DownloadManager
from src.plugins.plugin_loader import PluginLoader
from src.plugins.plugin_manager import PluginManager
from src.plugins.hook_registry import HookRegistry
from src.themes.theme_manager import ThemeManager

class TestBrowser(unittest.TestCase):
    """Test cases for the browser."""
    
    @classmethod
    def setUpClass(cls):
        """Set up the test environment."""
        # Create application
        cls.app = QApplication.instance() or QApplication(sys.argv)
        
        # Create browser application
        cls.browser = Application()
        
        # Initialize browser
        cls.browser.initialize()
    
    @classmethod
    def tearDownClass(cls):
        """Clean up the test environment."""
        # Clean up browser
        cls.browser.cleanup()
    
    def test_browser_initialization(self):
        """Test browser initialization."""
        # Check if browser is initialized
        self.assertTrue(self.browser.initialized)
        
        # Check if managers are initialized
        self.assertIsNotNone(self.browser.tab_manager)
        self.assertIsNotNone(self.browser.history_manager)
        self.assertIsNotNone(self.browser.bookmarks_manager)
        self.assertIsNotNone(self.browser.cookies_manager)
        self.assertIsNotNone(self.browser.download_manager)
        self.assertIsNotNone(self.browser.plugin_loader)
        self.assertIsNotNone(self.browser.plugin_manager)
        self.assertIsNotNone(self.browser.hook_registry)
        self.assertIsNotNone(self.browser.theme_manager)
    
    def test_tab_manager(self):
        """Test tab manager."""
        # Get tab manager
        tab_manager = self.browser.tab_manager
        
        # Check initial tab count
        initial_count = tab_manager.get_tab_count()
        
        # Create new tab
        tab_index = tab_manager.new_tab()
        
        # Check if tab count increased
        self.assertEqual(tab_manager.get_tab_count(), initial_count + 1)
        
        # Check if tab exists
        self.assertIsNotNone(tab_manager.get_tab(tab_index))
        
        # Close tab
        tab_manager.close_tab(tab_index)
        
        # Check if tab count decreased
        self.assertEqual(tab_manager.get_tab_count(), initial_count)
    
    def test_history_manager(self):
        """Test history manager."""
        # Get history manager
        history_manager = self.browser.history_manager
        
        # Add history entry
        url = "https://example.com"
        title = "Example Domain"
        history_manager.add_history(url, title)
        
        # Get history
        history = history_manager.get_history()
        
        # Check if history entry exists
        found = False
        for entry in history:
            if entry["url"] == url and entry["title"] == title:
                found = True
                break
        
        self.assertTrue(found)
        
        # Remove history entry
        history_manager.remove_history(url)
        
        # Get history again
        history = history_manager.get_history()
        
        # Check if history entry was removed
        found = False
        for entry in history:
            if entry["url"] == url and entry["title"] == title:
                found = True
                break
        
        self.assertFalse(found)
    
    def test_bookmarks_manager(self):
        """Test bookmarks manager."""
        # Get bookmarks manager
        bookmarks_manager = self.browser.bookmarks_manager
        
        # Add bookmark
        url = "https://example.com"
        title = "Example Domain"
        folder = "Test Folder"
        
        # Add folder if it doesn't exist
        if folder not in bookmarks_manager.get_folders():
            bookmarks_manager.add_folder(folder)
        
        # Add bookmark
        bookmarks_manager.add_bookmark(url, title, folder)
        
        # Get bookmarks
        bookmarks = bookmarks_manager.get_bookmarks(folder)
        
        # Check if bookmark exists
        found = False
        for bookmark in bookmarks:
            if bookmark["url"] == url and bookmark["title"] == title:
                found = True
                break
        
        self.assertTrue(found)
        
        # Remove bookmark
        bookmarks_manager.remove_bookmark(url, folder)
        
        # Get bookmarks again
        bookmarks = bookmarks_manager.get_bookmarks(folder)
        
        # Check if bookmark was removed
        found = False
        for bookmark in bookmarks:
            if bookmark["url"] == url and bookmark["title"] == title:
                found = True
                break
        
        self.assertFalse(found)
        
        # Remove folder
        bookmarks_manager.remove_folder(folder)
        
        # Check if folder was removed
        self.assertNotIn(folder, bookmarks_manager.get_folders())
    
    def test_cookies_manager(self):
        """Test cookies manager."""
        # Get cookies manager
        cookies_manager = self.browser.cookies_manager
        
        # Check if cookies manager is initialized
        self.assertTrue(cookies_manager.initialized)
    
    def test_download_manager(self):
        """Test download manager."""
        # Get download manager
        download_manager = self.browser.download_manager
        
        # Check if download manager is initialized
        self.assertTrue(download_manager.initialized)
    
    def test_plugin_loader(self):
        """Test plugin loader."""
        # Get plugin loader
        plugin_loader = self.browser.plugin_loader
        
        # Check if plugin loader is initialized
        self.assertTrue(hasattr(plugin_loader, "loaded_plugins"))
    
    def test_plugin_manager(self):
        """Test plugin manager."""
        # Get plugin manager
        plugin_manager = self.browser.plugin_manager
        
        # Check if plugin manager is initialized
        self.assertTrue(hasattr(plugin_manager, "plugin_dirs"))
    
    def test_hook_registry(self):
        """Test hook registry."""
        # Get hook registry
        hook_registry = self.browser.hook_registry
        
        # Check if hook registry is initialized
        self.assertTrue(hasattr(hook_registry, "hooks"))
        
        # Check if hooks are initialized
        for hook_name in hook_registry.available_hooks:
            self.assertIn(hook_name, hook_registry.hooks)
    
    def test_theme_manager(self):
        """Test theme manager."""
        # Get theme manager
        theme_manager = self.browser.theme_manager
        
        # Check if theme manager is initialized
        self.assertTrue(hasattr(theme_manager, "available_themes"))
        
        # Check if default themes are available
        self.assertIn("Default", theme_manager.available_themes)
        self.assertIn("Dark", theme_manager.available_themes)
        self.assertIn("Light", theme_manager.available_themes)
        self.assertIn("Neon", theme_manager.available_themes)
        self.assertIn("Minimal", theme_manager.available_themes)
        
        # Get current theme
        current_theme = theme_manager.get_current_theme()
        
        # Check if current theme is valid
        self.assertIsNotNone(current_theme)
        
        # Apply a different theme
        original_theme = theme_manager.current_theme
        
        if original_theme != "Dark":
            theme_manager.apply_theme("Dark")
            self.assertEqual(theme_manager.current_theme, "Dark")
        else:
            theme_manager.apply_theme("Light")
            self.assertEqual(theme_manager.current_theme, "Light")
        
        # Restore original theme
        theme_manager.apply_theme(original_theme)
        self.assertEqual(theme_manager.current_theme, original_theme)
    
    def test_unique_features(self):
        """Test unique features."""
        # Test Reality Augmentation
        # This is a placeholder for testing the Reality Augmentation feature
        # In a real test, we would create a tab, load a page, apply augmentation, and verify the result
        
        # Test Collaborative Browsing
        # This is a placeholder for testing the Collaborative Browsing feature
        # In a real test, we would create a session, join it, send messages, and verify the result
        
        # Test Content Transformation
        # This is a placeholder for testing the Content Transformation feature
        # In a real test, we would create a tab, load a page, apply transformation, and verify the result
        
        # Test Time-Travel Browsing
        # This is a placeholder for testing the Time-Travel Browsing feature
        # In a real test, we would create a tab, load a page, create snapshots, restore them, and verify the result
        
        # Test Dimensional Tabs
        # This is a placeholder for testing the Dimensional Tabs feature
        # In a real test, we would create a tab, create dimensions, switch between them, and verify the result
        
        # Test Neural Interface Customization
        # This is a placeholder for testing the Neural Interface Customization feature
        # In a real test, we would customize the interface, apply changes, and verify the result
        
        # For now, we'll just pass this test
        self.assertTrue(True)

if __name__ == "__main__":
    unittest.main()
</file>

<file path="tests/test_plugin_system.py">
#!/usr/bin/env python3
# NebulaFusion Browser - Test Plugin System

import os
import sys
import unittest
from PyQt6.QtWidgets import QApplication
from PyQt6.QtCore import QUrl
from PyQt6.QtTest import QTest
from PyQt6.QtCore import Qt

# Add parent directory to path
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

# Import browser modules
from src.core.application import Application
from src.plugins.plugin_loader import PluginLoader
from src.plugins.plugin_manager import PluginManager
from src.plugins.hook_registry import HookRegistry
from src.plugins.plugin_api import PluginAPI
from src.plugins.plugin_base import PluginBase

class TestPluginSystem(unittest.TestCase):
    """Test cases for the plugin system."""
    
    @classmethod
    def setUpClass(cls):
        """Set up the test environment."""
        # Create application
        cls.app = QApplication.instance() or QApplication(sys.argv)
        
        # Create browser application
        cls.browser = Application()
        
        # Initialize browser
        cls.browser.initialize()
    
    @classmethod
    def tearDownClass(cls):
        """Clean up the test environment."""
        # Clean up browser
        cls.browser.cleanup()
    
    def test_plugin_loader(self):
        """Test plugin loader."""
        # Get plugin loader
        plugin_loader = self.browser.plugin_loader
        
        # Check if plugin loader is initialized
        self.assertTrue(hasattr(plugin_loader, "loaded_plugins"))
        
        # Get sample plugin path
        sample_plugin_path = os.path.join(
            os.path.dirname(os.path.dirname(os.path.abspath(__file__))),
            "src", "plugins", "sample_plugins", "sample_plugin"
        )
        
        # Check if sample plugin exists
        self.assertTrue(os.path.exists(sample_plugin_path))
        
        # Load sample plugin
        plugin_id = plugin_loader.load_plugin(sample_plugin_path)
        
        # Check if plugin was loaded
        self.assertIsNotNone(plugin_id)
        self.assertIn(plugin_id, plugin_loader.loaded_plugins)
        
        # Get plugin
        plugin = plugin_loader.get_plugin(plugin_id)
        
        # Check plugin properties
        self.assertEqual(plugin["id"], "sample_plugin")
        self.assertEqual(plugin["name"], "Sample Plugin")
        self.assertEqual(plugin["version"], "1.0.0")
        self.assertEqual(plugin["author"], "NebulaFusion Team")
        
        # Activate plugin
        success = plugin_loader.activate_plugin(plugin_id)
        
        # Check if plugin was activated
        self.assertTrue(success)
        self.assertTrue(plugin_loader.loaded_plugins[plugin_id]["enabled"])
        
        # Deactivate plugin
        success = plugin_loader.deactivate_plugin(plugin_id)
        
        # Check if plugin was deactivated
        self.assertTrue(success)
        self.assertFalse(plugin_loader.loaded_plugins[plugin_id]["enabled"])
        
        # Unload plugin
        success = plugin_loader.unload_plugin(plugin_id)
        
        # Check if plugin was unloaded
        self.assertTrue(success)
        self.assertNotIn(plugin_id, plugin_loader.loaded_plugins)
    
    def test_hook_registry(self):
        """Test hook registry."""
        # Get hook registry
        hook_registry = self.browser.hook_registry
        
        # Check if hook registry is initialized
        self.assertTrue(hasattr(hook_registry, "hooks"))
        
        # Check if hooks are initialized
        for hook_name in hook_registry.available_hooks:
            self.assertIn(hook_name, hook_registry.hooks)
        
        # Create a test hook
        hook_name = "onTestHook"
        plugin_id = "test_plugin"
        
        # Create a callback function
        callback_called = [False]
        def callback(*args):
            callback_called[0] = True
        
        # Register hook
        success = hook_registry.register_hook(hook_name, plugin_id, callback)
        
        # Check if hook was registered
        self.assertTrue(success)
        self.assertIn(plugin_id, hook_registry.hooks[hook_name])
        
        # Trigger hook
        hook_registry.trigger_hook(hook_name)
        
        # Check if callback was called
        self.assertTrue(callback_called[0])
        
        # Unregister hook
        success = hook_registry.unregister_hook(hook_name, plugin_id)
        
        # Check if hook was unregistered
        self.assertTrue(success)
        self.assertNotIn(plugin_id, hook_registry.hooks[hook_name])
    
    def test_plugin_api(self):
        """Test plugin API."""
        # Create a test manifest
        manifest = {
            "id": "test_plugin",
            "name": "Test Plugin",
            "version": "1.0.0",
            "author": "Test Author",
            "description": "Test Description",
            "permissions": ["tabs", "bookmarks", "history"]
        }
        
        # Create plugin API
        plugin_api = PluginAPI(self.browser, "test_plugin", manifest)
        
        # Check if API components are initialized
        self.assertIsNotNone(plugin_api.logger)
        self.assertIsNotNone(plugin_api.hooks)
        self.assertIsNotNone(plugin_api.tabs)
        self.assertIsNotNone(plugin_api.bookmarks)
        self.assertIsNotNone(plugin_api.history)
        self.assertIsNotNone(plugin_api.downloads)
        self.assertIsNotNone(plugin_api.cookies)
        self.assertIsNotNone(plugin_api.storage)
        self.assertIsNotNone(plugin_api.ui)
        self.assertIsNotNone(plugin_api.network)
        self.assertIsNotNone(plugin_api.filesystem)
        self.assertIsNotNone(plugin_api.settings)
        
        # Check if unique feature APIs are initialized
        self.assertIsNotNone(plugin_api.reality)
        self.assertIsNotNone(plugin_api.collaboration)
        self.assertIsNotNone(plugin_api.transformation)
        self.assertIsNotNone(plugin_api.timetravel)
        self.assertIsNotNone(plugin_api.dimensions)
        self.assertIsNotNone(plugin_api.voice)
        
        # Check permission checking
        self.assertTrue(plugin_api.has_permission("tabs"))
        self.assertTrue(plugin_api.has_permission("bookmarks"))
        self.assertTrue(plugin_api.has_permission("history"))
        self.assertFalse(plugin_api.has_permission("cookies"))
    
    def test_plugin_base(self):
        """Test plugin base class."""
        # Create a test manifest
        manifest = {
            "id": "test_plugin",
            "name": "Test Plugin",
            "version": "1.0.0",
            "author": "Test Author",
            "description": "Test Description",
            "permissions": ["tabs", "bookmarks", "history"]
        }
        
        # Create plugin API
        plugin_api = PluginAPI(self.browser, "test_plugin", manifest)
        
        # Create plugin instance
        plugin = PluginBase(plugin_api)
        
        # Check plugin properties
        self.assertEqual(plugin.plugin_id, "test_plugin")
        self.assertEqual(plugin.manifest, manifest)
        
        # Check plugin methods
        self.assertTrue(plugin.activate())
        self.assertTrue(plugin.deactivate())
        plugin.configure()  # Should not raise an exception
        
        # Check plugin getters
        self.assertEqual(plugin.get_name(), "Test Plugin")
        self.assertEqual(plugin.get_version(), "1.0.0")
        self.assertEqual(plugin.get_author(), "Test Author")
        self.assertEqual(plugin.get_description(), "Test Description")
        self.assertEqual(plugin.get_permissions(), ["tabs", "bookmarks", "history"])
        
        # Check permission checking
        self.assertTrue(plugin.has_permission("tabs"))
        self.assertTrue(plugin.has_permission("bookmarks"))
        self.assertTrue(plugin.has_permission("history"))
        self.assertFalse(plugin.has_permission("cookies"))
    
    def test_plugin_manager(self):
        """Test plugin manager."""
        # Get plugin manager
        plugin_manager = self.browser.plugin_manager
        
        # Check if plugin manager is initialized
        self.assertTrue(hasattr(plugin_manager, "plugin_dirs"))
        
        # Get plugins
        plugins = plugin_manager.get_plugins()
        
        # Check if plugins are returned
        self.assertIsInstance(plugins, list)
        
        # Get store plugins
        store_plugins = plugin_manager.get_store_plugins()
        
        # Check if store plugins are returned
        self.assertIsInstance(store_plugins, list)
        self.assertTrue(len(store_plugins) > 0)
        
        # Check if each store plugin has required fields
        for plugin in store_plugins:
            self.assertIn("id", plugin)
            self.assertIn("name", plugin)
            self.assertIn("version", plugin)
            self.assertIn("author", plugin)
            self.assertIn("description", plugin)
            self.assertIn("url", plugin)

if __name__ == "__main__":
    unittest.main()
</file>

<file path="tests/test_theming_system.py">
#!/usr/bin/env python3
# NebulaFusion Browser - Test Theming System

import os
import sys
import unittest
from PyQt6.QtWidgets import QApplication
from PyQt6.QtCore import QUrl
from PyQt6.QtTest import QTest
from PyQt6.QtCore import Qt

# Add parent directory to path
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

# Import browser modules
from src.core.application import Application
from src.themes.theme_manager import ThemeManager

class TestThemingSystem(unittest.TestCase):
    """Test cases for the theming system."""
    
    @classmethod
    def setUpClass(cls):
        """Set up the test environment."""
        # Create application
        cls.app = QApplication.instance() or QApplication(sys.argv)
        
        # Create browser application
        cls.browser = Application()
        
        # Initialize browser
        cls.browser.initialize()
    
    @classmethod
    def tearDownClass(cls):
        """Clean up the test environment."""
        # Clean up browser
        cls.browser.cleanup()
    
    def test_theme_manager(self):
        """Test theme manager."""
        # Get theme manager
        theme_manager = self.browser.theme_manager
        
        # Check if theme manager is initialized
        self.assertTrue(hasattr(theme_manager, "available_themes"))
        
        # Check if default themes are available
        self.assertIn("Default", theme_manager.available_themes)
        self.assertIn("Dark", theme_manager.available_themes)
        self.assertIn("Light", theme_manager.available_themes)
        self.assertIn("Neon", theme_manager.available_themes)
        self.assertIn("Minimal", theme_manager.available_themes)
        
        # Get current theme
        current_theme = theme_manager.get_current_theme()
        
        # Check if current theme is valid
        self.assertIsNotNone(current_theme)
        
        # Apply a different theme
        original_theme = theme_manager.current_theme
        
        if original_theme != "Dark":
            theme_manager.apply_theme("Dark")
            self.assertEqual(theme_manager.current_theme, "Dark")
        else:
            theme_manager.apply_theme("Light")
            self.assertEqual(theme_manager.current_theme, "Light")
        
        # Restore original theme
        theme_manager.apply_theme(original_theme)
        self.assertEqual(theme_manager.current_theme, original_theme)
    
    def test_theme_creation(self):
        """Test theme creation."""
        # Get theme manager
        theme_manager = self.browser.theme_manager
        
        # Create a test theme
        test_theme = {
            "name": "Test Theme",
            "description": "A test theme for NebulaFusion browser.",
            "author": "Test Author",
            "version": "1.0.0",
            "dark": False,
            "stylesheet": """
            /* Test Theme for NebulaFusion Browser */
            QMainWindow {
                background-color: #F0F0F0;
                color: #333333;
            }
            """,
            "colors": {
                "primary": "#3498DB",
                "secondary": "#2ECC71",
                "accent": "#F1C40F",
                "background": "#F0F0F0",
                "foreground": "#333333",
                "surface": "#FFFFFF",
                "error": "#E74C3C",
                "warning": "#F39C12",
                "success": "#2ECC71",
                "info": "#3498DB"
            }
        }
        
        # Create theme
        success = theme_manager.create_theme(test_theme, save=False)
        
        # Check if theme was created
        self.assertTrue(success)
        self.assertIn("Test Theme", theme_manager.available_themes)
        
        # Get theme
        theme = theme_manager.get_theme("Test Theme")
        
        # Check theme properties
        self.assertEqual(theme["name"], "Test Theme")
        self.assertEqual(theme["description"], "A test theme for NebulaFusion browser.")
        self.assertEqual(theme["author"], "Test Author")
        self.assertEqual(theme["version"], "1.0.0")
        self.assertEqual(theme["dark"], False)
        self.assertIn("stylesheet", theme)
        self.assertIn("colors", theme)
        
        # Apply theme
        original_theme = theme_manager.current_theme
        success = theme_manager.apply_theme("Test Theme")
        
        # Check if theme was applied
        self.assertTrue(success)
        self.assertEqual(theme_manager.current_theme, "Test Theme")
        
        # Restore original theme
        theme_manager.apply_theme(original_theme)
        
        # Delete theme
        del theme_manager.available_themes["Test Theme"]
    
    def test_dark_mode_toggle(self):
        """Test dark mode toggle."""
        # Get theme manager
        theme_manager = self.browser.theme_manager
        
        # Get original theme
        original_theme = theme_manager.current_theme
        original_dark_mode = theme_manager.is_dark_mode()
        
        # Toggle dark mode
        theme_manager.toggle_dark_mode()
        
        # Check if dark mode was toggled
        self.assertNotEqual(theme_manager.is_dark_mode(), original_dark_mode)
        
        # Toggle dark mode again
        theme_manager.toggle_dark_mode()
        
        # Check if dark mode was toggled back
        self.assertEqual(theme_manager.is_dark_mode(), original_dark_mode)
        
        # Restore original theme
        theme_manager.apply_theme(original_theme)

if __name__ == "__main__":
    unittest.main()
</file>

<file path="todo.md">
# PyQt Browser Todo List

## Requirements Analysis
- [x] Analyze core browser requirements
- [x] Define unique browser features
- [x] Create project structure
- [x] Brainstorm and select browser name

## Design Phase
- [x] Design browser architecture
- [x] Design plugin system architecture
- [x] Design theming system
- [x] Design settings management
- [x] Design security model and sandboxing

## Implementation Phase
### Core Browser Features
- [x] Implement tabbed browsing
- [x] Implement navigation controls
- [x] Implement history management
- [x] Implement bookmarks system
- [x] Implement private/incognito mode
- [x] Implement cookie persistence
- [x] Implement download manager
- [x] Implement security features

### Plugin System
- [x] Implement plugin loader
- [x] Implement plugin hooks
- [x] Create plugin API
- [x] Implement plugin UI management
- [x] Implement plugin sandboxing
- [ ] Create sample plugins

### Theming System
- [x] Implement theme manager
- [x] Create default themes
- [x] Implement theme switching
- [x] Support light/dark mode
- [x] Create theme settings UI

### Settings Management
- [x] Implement settings storage
- [x] Create settings UI
- [x] Implement settings import/export
- [x] Add plugin settings integration

### Security Integration
- [ ] Integrate security features across modules
- [ ] Implement plugin permission system
- [ ] Add content security policies
- [ ] Implement secure cookie handling
- [ ] Add sandboxing for all plugin operations

### Unique Features
- [ ] Implement Reality Augmentation
- [ ] Add Collaborative Browsing
- [ ] Create Content Transformation
- [ ] Implement Time-Travel Browsing
- [ ] Add Neural Interface Customization
- [ ] Implement Dimensional Tabs
- [ ] Add Voice Command System

## Testing Phase
- [ ] Test core browser functionality
- [ ] Test plugin system and hooks
- [ ] Test theming system
- [ ] Test settings management
- [ ] Test security features
- [ ] Test unique features
- [ ] Perform security audit

## Packaging
- [ ] Create documentation
- [ ] Package project files
- [ ] Create zip archive
- [ ] Prepare final delivery
</file>

<file path="unique_features.md">
# Unique Browser Features and Name Brainstorming

## Browser Name Ideas
- **NexusFox** - Representing the interconnected nature of browsing and plugins
- **QuantumLeap** - Suggesting a revolutionary jump in browser technology
- **ChromaSphere** - Highlighting the colorful, customizable nature
- **PyroSurf** - Playing on Python + web surfing with a fiery twist
- **Nebula** - Vast, expansive, and full of possibilities
- **Vortex** - Suggesting a powerful force pulling content together
- **EchoStream** - Representing the flow of information
- **ZenithWave** - Suggesting the peak of browsing technology
- **PulsarWeb** - Fast, rhythmic, and dynamic
- **Kaleidoscope** - Representing the ever-changing, colorful web experience

## Selected Name: **"NebulaFusion"**
A fusion of the cosmic "Nebula" concept with the idea of bringing together (fusion) different technologies and plugins. The name suggests something vast, beautiful, and mysterious like a nebula in space, while "Fusion" represents the seamless integration of plugins and features.

## Unique Features Not Found in Other Browsers

### 1. Reality Augmentation Layer
- Overlay web content with real-world information using device camera
- Scan QR codes directly from the browser interface
- Translate text in images on webpages in real-time
- Visual search by highlighting objects on webpages

### 2. Collaborative Browsing
- Share browsing sessions in real-time with other NebulaFusion users
- Collaborative annotation of webpages
- Shared cursor visibility for teaching/demonstration
- Voice chat integration during shared sessions
- Permission-based control sharing

### 3. Content Transformation Engine
- Convert webpage content between different formats (article to presentation, text to audio)
- Customize webpage layouts on-the-fly with drag-and-drop interface
- Extract and reorganize content from multiple pages into a single view
- Apply reading templates (focus mode, research mode, entertainment mode)

### 4. Time-Travel Browsing
- Capture full-page snapshots at configurable intervals
- Visual timeline of webpage changes
- Compare different versions of the same page
- Restore and interact with previous versions of dynamic webpages
- Schedule future visits to pages with change detection

### 5. Neural Interface Customization
- Browser learns user behavior patterns and adapts UI accordingly
- Predictive content loading based on browsing patterns
- Attention-aware content highlighting based on eye-tracking (if available)
- Mood-based theme switching using sentiment analysis of browsing content
- Adaptive resource allocation based on page importance to user

### 6. Dimensional Tabs
- Organize tabs in 3D space rather than linear tab bar
- Group related tabs into "constellations" that visually represent relationships
- Zoom in/out of tab groups with spatial organization
- Tab relationships visualized with connecting lines showing navigation paths
- Tab hibernation with visual aging indicators

### 7. Plugin Marketplace with Reputation System
- Built-in marketplace for discovering and installing plugins
- User rating and review system for plugins
- Plugin developer reputation tracking
- Resource usage metrics for installed plugins
- Plugin compatibility verification

### 8. Context-Aware Voice Commands
- Natural language voice control of browser functions
- Context-sensitive commands based on current webpage
- Voice-activated plugin functions
- Custom voice command creation
- Voice profile switching for multi-user environments

### 9. Adaptive Security Visualization
- Visual representation of website security status
- Real-time visualization of tracking attempts
- Interactive privacy dashboard showing data sharing
- Security scoring system with detailed breakdown
- Visual alerts for suspicious website behavior

### 10. Immersive Reader with Environmental Adaptation
- Reading mode that adapts to environmental conditions (time of day, ambient light)
- Biometric feedback integration to adjust text size/contrast based on reading ease
- Background ambient sounds matched to content type
- Reading speed optimization with dynamic text presentation
- Attention-maintaining subtle animations for long-form content
</file>

</files>
